<!-- flowengineeditor.multi-trigger.html (lines 1–200) -->
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Flow Engine Editor</title>
  <link rel="stylesheet" href="FE_drawflow-css.min.css">
  <link rel="stylesheet" href="FE_drawflow-extra.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@simonwep/pickr/dist/themes/nano.min.css"/>
  <script src="https://cdn.jsdelivr.net/npm/@simonwep/pickr"></script>
  <script src="FE_flowvars.js"></script>
  <style>
    body { background: #191919; color: #e6e6e6; }
    #controls { padding: 16px; background: #222; border-bottom: 1px solid #333; }
    #main { display: flex; }
    #drawflow {
      flex: 3; height: 700px;
      background: #222 url('data:image/svg+xml;utf8,<svg width="40" height="40" viewBox="0 0 40 40" fill="none" xmlns="http://www.w3.org/2000/svg"><rect width="1" height="40" fill="%23333"/><rect y="39" width="40" height="1" fill="%23333"/></svg>');
      border-right: 1px solid #333;
    }
    #editor { flex: 1; min-width: 340px; padding: 18px 16px 16px 16px; background: #181818; }
    #nodeEditor label { margin-top: 6px; margin-right: 6px; display:inline-block; }
    #nodeEditor input, #nodeEditor select { margin-bottom: 7px; margin-right:8px;}
    .log-info { color: #b7ffac; }
    .log-error { color: #ffb6b6; }
    button {
      background: #169c00; color: #f3f3f3;
      border: none; padding: 6px 14px; border-radius: 7px;
      margin-right: 4px; cursor:pointer;
    }
    button:hover { background: #02c258; }
    .logic-node {
      min-width: 65px !important;
      max-width: 65px !important;
      width: 65px !important;
      min-height: 32px !important;
      max-height: 32px !important;
      height: 32px !important;
      font-size: 13px !important;
      padding: 2px 0px !important;
      text-align: center !important;
      display: flex;
      align-items: center;
      justify-content: center;
      margin: 0 auto !important;
    }
    .current-value {
      font-size: 12px;
      font-weight: 500;
      margin-top: 2px;
      padding: 2px 8px;
      border-radius: 6px;
      display: inline-block;
      background: transparent !important;
    }
    .main-path.highlighted {
      stroke: limegreen !important;
      stroke-width: 4px !important;
      filter: drop-shadow(0 0 6px #0f0) !important;
    }
    .drawflow-node.executed {
      border: 3px solid #ffe54e !important;
      box-shadow: 0 0 18px #ffe54e !important;
    }
    #sendFlow.need-save {
      background: #e6462d !important;   /* red */
      color: #fff !important;
      border: 2px solid #900 !important;
      font-weight: bold;
      box-shadow: 0 0 8px #e6462d77;
    }
    .cv-on    { color: #0c0; }
    .cv-off   { color: #e34c4c; }
    .cv-num   { color: #3af; }
    .cv-other { color: #eec150; }
    .drawflow-node {
      border-radius: 18px !important;
      box-shadow: 0 2px 14px 0 #00000022;
      overflow: hidden;
      border: 1.5px solid #29475e;
      background: #232a2d;
    }
    .drawflow-node .drawflow-content {
      border-radius: 0 0 16px 16px;
      padding: 9px 8px;
    }
    .drawflow-node[data-node-type="device"] {
      background: #1E90FF !important;
      border: 1.5px solid #d04040 !important;
      transition: background 0.2s, border 0.2s;
    }
    .drawflow-node[data-node-type="device"].selected {
      background: #00008B !important;
      border: 2.2px solid #02f84c !important;
      color: #fff !important;
    }
    .drawflow-node[data-node-type="condition"] {
      background: #fe9a3c !important;
      border: 1.5px solid #d04040 !important;
      transition: background 0.2s, border 0.2s;
    }
    .drawflow-node[data-node-type="condition"].selected {
      background: #fe7b00 !important;
      border: 2.2px solid #02f84c !important;
      color: #fff !important;
    }
    .drawflow-node[data-node-type="eventTrigger"] {
      background: #fd6057 !important;
      border: 1.5px solid #d04040 !important;
      transition: background 0.2s, border 0.2s;
    }
    .drawflow-node[data-node-type="eventTrigger"].selected {
      background: #8B0000  !important;
      border: 2.2px solid #02f84c !important;
      color: #fff !important;
    }
    .drawflow-node[data-node-type="setVariable"] {
      background: #1de9b6 !important;
      border: 1.5px solid #d04040 !important;
      transition: background 0.2s, border 0.2s;
    }
    .drawflow-node[data-node-type="setVariable"].selected {
      background: #159084  !important;
      border: 2.2px solid #02f84c !important;
      color: #fff !important;
    }
    #exportVarsBtn.need-export {
      background: #e6462d !important;   /* red */
      color: #fff !important;
      border: 2px solid #900 !important;
      font-weight: bold;
      box-shadow: 0 0 8px #e6462d77;
    }
    .device-tile,
    .device-tile.selected,
    .condition-tile,
    .condition-tile.selected,
    .eventTrigger-tile,
    .eventTrigger-tile.selected,
    .setVariable-tile,
    .setVariable-tile.selected { background: transparent !important; }
  </style>
</head>
<body>
  <div id="controls">
    <div style="margin-bottom:5px;">
      <b>Flow Engine Editor</b> <small>- Ver. 1.0.0</small><br>
      <input id="hubitatToken" placeholder="Token" style="width:100px; margin-left:6px;">
      <input id="hubitatAppId" placeholder="Flow File API App ID" style="width:100px; margin-left:6px;">
      <button id="loadDevices" title="Load all devices from Hubitat">Load Devices</button>
      <button id="loadFlowFromHubitatDropdown" title="Load a saved flow from Hubitat">Load Flow</button>
      <select id="hubitatFileDropdown" style="width:260px;display:none;"></select>
      <button id="sendFlow" title="Save current flow to Hubitat">Save Flow</button>
      <b> | </b>
      <input id="flowName" placeholder="Flow Name" style="width:250px; font-weight:bold; font-size:16px;">
      <b> | </b>
      <button id="newFlow" title="Start a new flow from scratch">Start New Flow</button>
      <button id="refreshAllTiles" title="Refresh all node tiles">Refresh Tiles</button>
    </div>
    <div>
      <button id="addTrigger" title="Add an Event Trigger node">Add Event Trigger</button>
      <button id="addDevice" title="Add an Action (Device) node">Add Action</button>
      <button id="addCondition" title="Add a Condition node">Add Condition</button>
      <button id="addLogicAND" title="Add an AND logic node">Add AND</button>
      <button id="addLogicOR" title="Add an OR logic node">Add OR</button>
      <button id="addLogicNOT" title="Add a NOT logic node">Add NOT</button>
      <button id="addDelay" title="Add a Delay (milliseconds) node">Add Delay ms</button>
      <button id="addDelayMin" title="Add a Delay (minutes) node">Add Delay min</button>
      <button id="addNotification" title="Add a Notification node">Add Notification</button>
      <button id="addSetVariable" title="Add a Set Variable node">Add Set Variable</button>
      <button id="addNotMatchingVar" title="Add a Devices Not Matching to JSON node">Add Not Var</button>
      <button id="addSaveDeviceState" title="Add Save Device State node">Save Device State</button>
      <button id="addRestoreDeviceState" title="Add Restore Device State node">Restore Device State</button>
      <button id="addDoNothing" title="Add a Do Nothing node">Add Do Nothing</button>
    </div>
  </div>
  <div id="main">
    <div id="drawflow"></div>
    <div id="editor">
      <div id="header" style="font-size:25px;" title="Test this node (Simulate execution of this Node)">
        <b>Node Editor</b>
      </div>
      <div id="nodeEditor">Click a node to edit</div>
      <div id="variableManager"></div>
      <div id="logBox"
           style="margin-top:20px;max-height:200px;overflow:auto;border-top:1px solid #333;padding-top:10px;font-family:monospace;font-size:12px;">
        Logs:<br>
      </div>
    </div>
  </div>
  <script src="FE_drawflow-js.min.js"></script>
  <script>
    window.FE_global_var_names = [];
    window.FE_flowvars = [];
    window.FE_global_vars = [];

    function markFlowNeedsSave(needed = true) {
      const btn = document.getElementById('sendFlow');
      if (!btn) return;
      if (needed) {
        btn.classList.add('need-save');
      } else {
        btn.classList.remove('need-save');
      }
    }

    // ---- CENTRALIZED CREDENTIAL CHECK ----
    function hubitatCredentialsAreValid(logIfMissing = false) {
      const appId = document.getElementById("hubitatAppId")?.value?.trim();
      const token = document.getElementById("hubitatToken")?.value?.trim();
      if (!appId || !token) {
        if (logIfMissing) logAction("Missing App ID or Token. Please enter both.", "warn");
        return false;
      }
      return true;
    }

    // ---- WARNING BANNER LOGIC ----
    function showHubitatWarning(show) {
      let warn = document.getElementById("hubitatWarnBanner");
      if (!warn) {
        warn = document.createElement("div");
        warn.id = "hubitatWarnBanner";
        warn.style = "background: #ffc107; color: #111; padding: 9px 22px; font-weight: bold; text-align:center; font-size:16px; border-bottom: 2px solid #b8860b;";
        warn.innerHTML = "⚠️ Please enter both Hubitat App ID and Token to use Flow Engine Editor features.";
        document.body.insertBefore(warn, document.body.firstChild);
      }
      warn.style.display = show ? "block" : "none";
    }

    // ---- BUTTONS DISABLE LOGIC ----
    function updateHubitatButtonStates() {
      const valid = hubitatCredentialsAreValid();
      const buttonIds = [
        "loadDevices", 
        "loadFlowFromHubitatDropdown", 
        "sendFlow"
        // Add other button IDs that need disabling here if any
      ];
      buttonIds.forEach(id => {
        const btn = document.getElementById(id);
        if (btn) btn.disabled = !valid;
      });
      showHubitatWarning(!valid);
    }
    document.getElementById("hubitatAppId").addEventListener("input", updateHubitatButtonStates);
    document.getElementById("hubitatToken").addEventListener("input", updateHubitatButtonStates);
    window.addEventListener("DOMContentLoaded", updateHubitatButtonStates);

    // ---- OPTIONAL: CLEAR DEVICES/FLOW IF CREDS MISSING ----
    function clearUiIfCredentialsMissing() {
      if (!hubitatCredentialsAreValid()) {
        // Optional: Clear device/flow UI, or gray out editor
        // For example:
        if (typeof window.devices !== "undefined") window.devices = [];
        if (window.editor && window.editor.clear) window.editor.clear();
        // Or clear device/flow-related UI
      }
    }
    document.getElementById("hubitatAppId").addEventListener("input", clearUiIfCredentialsMissing);
    document.getElementById("hubitatToken").addEventListener("input", clearUiIfCredentialsMissing);

    // ---- OPTIONAL: VALIDATE FORMAT ----
    function validateHubitatInputFormat() {
      // You can make this more robust if your tokens/appIds have a known format
      const appId = document.getElementById("hubitatAppId")?.value?.trim();
      const token = document.getElementById("hubitatToken")?.value?.trim();
      if (appId && !/^[a-zA-Z0-9]+$/.test(appId)) {
        showHubitatWarning(true);
        document.getElementById("hubitatWarnBanner").innerText = "⚠️ Invalid App ID format. Only letters and numbers are allowed.";
      } else if (token && !/^[a-zA-Z0-9\-]+$/.test(token)) {
        showHubitatWarning(true);
        document.getElementById("hubitatWarnBanner").innerText = "⚠️ Invalid Token format.";
      } else {
        showHubitatWarning(!hubitatCredentialsAreValid());
        if (hubitatCredentialsAreValid()) document.getElementById("hubitatWarnBanner").innerText =
          "⚠️ Please enter both Hubitat App ID and Token to use Flow Engine Editor features.";
      }
    }
    document.getElementById("hubitatAppId").addEventListener("input", validateHubitatInputFormat);
    document.getElementById("hubitatToken").addEventListener("input", validateHubitatInputFormat);

    window.addEventListener("DOMContentLoaded", function() {
      setTimeout(updateHubitatButtonStates, 350); // For autofill
    });
      
    function logAction(msg, type = "info") {
      const logBox = document.getElementById("logBox");
      if (logBox) {
        logBox.innerHTML += `<span class="log-${type}">${msg}</span><br>`;
        logBox.scrollTop = logBox.scrollHeight;
      }
    }

    // --- Auto-load FE_global_vars.json ---
    async function autoLoadGlobalVarsFromHubitat(retries = 8) {
      try {
        if (typeof fetchHubitatVarFileContent === "function") {
          const txt = await fetchHubitatVarFileContent("FE_global_vars.json");
          if (txt && txt.trim()) {
            if (window.flowVars && window.flowVars.setGlobalVars) {
              try {
                window.flowVars.setGlobalVars(txt && txt.trim() ? JSON.parse(txt) : []);
                logAction("Auto-loaded FE_global_vars.json", "info");
              } catch (e) {
                window.flowVars.setGlobalVars([]);
                console.warn("Globals JSON invalid or missing. Starting with empty globals.");
              }
            }
            
            // --- PARSE AND STORE DIRECTLY ---
            let parsed = [];
            try { 
              parsed = JSON.parse(txt);
            } catch (e) { 
              parsed = [];
            }
            window.FE_global_vars = parsed;
            window.FE_global_var_names = parsed.map(v => v.name).filter(Boolean);
            if (window.flowVars && typeof window.flowVars.renderManager === "function") {
              window.flowVars.renderManager(document.getElementById("variableManager"), { globalVars: true });
            } 

            if (window.flowVars && window.flowVars.setGlobalVars) {
              try {
                window.flowVars.setGlobalVars(txt && txt.trim() ? JSON.parse(txt) : []);
                logAction("Auto-collected glabal variables", "info");
              } catch (e) {
                window.flowVars.setGlobalVars([]);
                console.warn("Globals JSON invalid or missing. Starting with empty globals.");
              }
            }

            // --- FORCE RE-RENDER IF NODE EDITOR OPEN ---
            if (window.editor && window.editor.selected_id) {
              const node = window.editor.getNodeFromId(window.editor.selected_id);
              if (node) renderEditor(node);
            }
          } else {
            // --- FILE MISSING: CREATE EMPTY ---
            const emptyGlobals = [];
            window.FE_global_vars = emptyGlobals;
            window.FE_global_var_names = [];
            if (typeof uploadToHubitatFile === "function") {
              await uploadToHubitatFile("FE_global_vars.json", JSON.stringify(emptyGlobals), { mimeType: "application/json" });
              logAction("FE_global_vars.json not found: Created new empty FE_global_vars.json", "warn");
            } else if (retries > 0) {
              setTimeout(() => autoLoadGlobalVarsFromHubitat(retries - 1), 300);
              logAction("Waiting for uploadToHubitatFile to become available...", "info");
            } else {
              logAction("No FE_global_vars.json found to auto-load and cannot create (missing upload function). Continuing with empty globals.", "warn");
            }
          }
        }
      } catch (e) {
        logAction("Error loading FE_global_vars.json (continuing): " + e, "error");
        // Fallback: set arrays to empty
        window.FE_global_vars = [];
        window.FE_global_var_names = [];
      }
    }
    // --- END Auto-load FE_global_vars.json ---

    // ---- Time device for time/day-of-week conditions
    const TIME_DEVICE = {
      id: "__time__",
      label: "Time",
      name: "Time",
      attributes: {
        currentTime: "", // "HH:mm"
        timeOfDay: ["sunrise", "sunset"],
        dayOfWeek: [
          "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"
        ]
      },
      commands: []
    };

    const MODE_DEVICE = {
      id: "__mode__",
      label: "Home Location",
      name: "Mode",
      attributes: { mode: "" },
      commands: []
    };

    // Add Variable virtual device for Conditions only
    const VARIABLE_DEVICE = {
      id: "__variable__",
      label: "Variable",
      name: "Variable",
      attributes: { value: "" }
    };

    const devs = Array.isArray(window.devices) ? window.devices : [];
    let conditionDevices = [...devs];

    // Only add Variable for Conditions
    conditionDevices.unshift(VARIABLE_DEVICE);

    function isValidFlowName(flowName) {
      return /^[a-zA-Z0-9_-]+$/.test(flowName);
    }

    // --- Here comes the nodeTileHtml function ---
    function nodeTileHtml(type, data, nodeId) {
      function getCurrentValue(deviceId, attr) {
        const devs = window.devices || [];
        const dev = devs.find(d => d.id == deviceId);
        if (dev && dev.attributes && attr && dev.attributes[attr] !== undefined) {
          return dev.attributes[attr];
        }
        return "";
      }

      const t = (type || "").toLowerCase();

      if (t === "donothing") {
        return `<div class="logic-node">Do Nothing</div>`;
      }
      if (t === "and") {
        return `<div class="logic-node">AND</div>`;
      }
      if (t === "or") {
        return `<div class="logic-node">OR</div>`;
      }
      if (t === "not") {
        return `<div class="logic-node">NOT</div>`;
      }
      if (t === "delay") {
        let label = data && data.ms ? `Delay ${data.ms} ms` : "Delay";
        if (data && data.minutes) label = `Delay ${data.minutes} min`;
        return `<div class="logic-node">${label}</div>`;
      }
      if (t === "delaymin") {
        let label = data && data.delayMin ? `Delay ${data.delayMin} min` : "Delay (min)";
        return `<div class="logic-node">${label}</div>`;
      }

      if (t === "savedevicestate") {
        let label = data.deviceLabel || data.deviceId || "<i>Pick device…</i>";
        return `<div class="device-tile"><b>Save Device State</b><br><span style="font-size:11px">${label}</span></div>`;
      }
      if (t === "restoredevicestate") {
        let label = data.deviceLabel || data.deviceId || "<i>Pick device…</i>";
        return `<div class="device-tile"><b>Restore Device State</b><br><span style="font-size:11px">${label}</span></div>`;
      }

      if (t === "setvariable") {
        let vName = data.varName || "Variable";
        let vValue = data.varValue || "Value";
        return `<div class="setVariable-tile">
          Set Variable<br>
          <span style="font-size:11px">
            ${vName} = ${vValue}
          </span>
        </div>`;
      }

      if (t === "notmatchingvar") {
        let devLabel = "";
        try {
          if (data && data.deviceIds && Array.isArray(data.deviceIds) && data.deviceIds.length) {
            const devs = window.devices || [];
            devLabel = data.deviceIds.map(id => {
              const dev = devs.find(d => d.id == id);
              return dev ? (dev.label || dev.name || id) : id;
            }).join(", ");
          }
        } catch (e) { devLabel = ""; }
        let attribute = (data && typeof data.attribute === "string" && data.attribute !== "undefined") ? data.attribute : "";
        let value = (data && typeof data.value === "string" && data.value !== "undefined") ? data.value : "";

        // MAIN FIX: Always show custom outputVar as entered (never undefined or blank)
        let outputVar = (
          data && typeof data.outputVar === "string" &&
          data.outputVar.trim() &&
          data.outputVar.trim().toLowerCase() !== "undefined"
        ) ? data.outputVar : "Devices Not Matching to JSON";

        let scope = (data && data.varScope === "global") ? "Global" : "Flow";
        return `<div class="setVariable-tile">
          <b>Devices Not Matching to JSON</b><br>
          <span style="font-size:11px">
            ${devLabel ? "Devices: " + devLabel + "<br>" : ""}
            ${attribute ? "Attr: " + attribute + "<br>" : ""}
            ${value ? "Not: " + value + "<br>" : ""}
            <hr>
            <b>Output variable / file name:</b> ${outputVar}<br><b>Attr Type:</b> ${scope}
          </span>
        </div>`;
      }

      if (t === "notification") {
        let devLabels = [];
        let ids = Array.isArray(data.targetDeviceId) ? data.targetDeviceId : [data.targetDeviceId];
        (ids || []).forEach(id => {
          let dev = (window.devices || []).find(d => d.id == id);
          if (dev) devLabels.push(dev.label || dev.name || dev.id);
        });
        let devLabelStr = devLabels.length ? devLabels.join(", ") : "<i>No device</i>";

        let type = (data.notificationType === "speech") ? "Speech" : "Push";
        let msg = data.message || "";
        return `<div class="device-tile">
          ${type} Notifications<br>
          <span style="font-size:11px">
            Device: ${devLabelStr}<br>
            ${msg ? `Message: "${msg}"<br>` : ""}
          </span>
        </div>`;
      }

      // ---- Custom rendering for Time Virtual Device Nodes (for "condition" or "eventTrigger") ----
      if (type === "eventTrigger" || type === "condition") {
        let isSelected = false;
        if (editor && editor.selected_id && nodeId) {
          if (editor.selected_id == nodeId) isSelected = true;
        }
        let tileClass = (type === "condition" ? "condition-tile" : "trigger-tile") + (isSelected ? " selected" : "");

        const devs = window.devices || [];
        const dev = devs.find(d => d.id == data.deviceId);
        let label = dev ? (dev.label || dev.name || data.deviceId) : (data.deviceLabel || data.deviceId || '');
        let attribute = data.attribute || '';
        let comparator = data.comparator || '';
        let value = "";
        if (data.comparator === "between" && Array.isArray(data.value)) {
          value = `(${data.value[0]} to ${data.value[1]})`;
        } else if (data.value) {
          value = '(' + data.value + ')';
        }

        let currentStr = "";
        if (dev && dev.attributes && attribute && dev.attributes[attribute] !== undefined) {
          currentStr = `<div class="current-value">current ${attribute}: ${dev.attributes[attribute]}</div>`;
        }

        let forMinutesStr = '';
        if (
            type === "eventTrigger" &&
            data.sustainedMin &&
            Number(data.sustainedMin) > 0
        ) {
            forMinutesStr = `<div class="current-value" style="color:#eec150">For ${data.sustainedMin} min</div>`;
        }

        return `<div class="${tileClass}">
            ${type === "eventTrigger" ? "Event Trigger" : "Condition"}<br>
            <span style="font-size:11px">
            ${label} ${attribute} ${comparator} ${value}<br><hr>
            </span>
            ${forMinutesStr}
            ${currentStr}
        </div>`;
      }

      // --- MULTI DEVICE TILE PATCH ---
      if (type === "device") {
        let isSelected = false;
        if (editor && editor.selected_id && nodeId) {
          if (editor.selected_id == nodeId) isSelected = true;
        }
        let tileClass = "device-tile" + (isSelected ? " selected" : "");

        // Show Location Mode tile (not colored)
        if (data.deviceId === "__mode__") {
          let value = "";
          if (Array.isArray(data.value)) value = data.value.join(", ");
          else value = data.value || "";
          return `<div>
            <b>Location Mode</b><br>
            <span style="font-size:11px">${data.command || ""} (${value})<br><hr></span>
          </div>`;
        }
        let label = data.deviceLabel ||
          (Array.isArray(data.deviceIds) ? data.deviceIds.join(", ") : data.deviceId);
        if (!label) label = "<i>Pick device(s)…</i>";
        let cmd = data.command || "";
        let val = data.value ? `(${data.value})` : "";

        const devs = window.devices || [];
        let allAttrVals = "";
        if (Array.isArray(data.deviceIds) && data.attribute) {
          allAttrVals = data.deviceIds.map(id => {
            const dev = devs.find(d => d.id == id);
            if (!dev || !dev.attributes || dev.attributes[data.attribute] === undefined) return "";
            return `<div class="current-value">current ${data.attribute}: ${dev.attributes[data.attribute]}</div>`;
          }).join("");
        } else if (data.deviceId && data.attribute) {
          const dev = devs.find(d => d.id == data.deviceId);
          if (dev && dev.attributes && dev.attributes[data.attribute] !== undefined) {
            allAttrVals = `<div class="current-value">current ${data.attribute}: ${dev.attributes[data.attribute]}</div>`;
          }
        }

        let colorPreview = "";
        if (cmd === "setColor" && data.color) {
          colorPreview = `<div style="margin-top:4px;width:30px;height:14px;border-radius:5px;background:${data.color};border:1px solid #555;display:inline-block;"></div>`;
        }

        return `<div class="${tileClass}">Action<br>
          <span style="font-size:11px">${label} ${cmd} ${val}<br><hr></span>
          ${(data.showStatus !== false) ? allAttrVals : ""}
          ${colorPreview}
        </div>`;
      }

      // Fallback for normal eventTrigger or condition (non-Time)
      if (type === "eventTrigger" || type === "condition") {
        let isSelected = false;
        if (editor && editor.selected_id && nodeId) {
          if (editor.selected_id == nodeId) isSelected = true;
        }
        if(type === "condition") {
          let tileClass = "condition-tile" + (isSelected ? " selected" : "");
        }
        if(type === "eventTrigger") {
          let tileClass = "eventTrigger-tile" + (isSelected ? " selected" : "");
        }

        let label = (data.deviceLabel || data.deviceId || '');
        let attribute = data.attribute || '';
        let comparator = data.comparator || '';
        let value = "";
        if (data.comparator === "between" && Array.isArray(data.value)) {
          value = `(${data.value[0]} to ${data.value[1]})`;
        } else if (data.value) {
          value = '(' + data.value + ')';
        }

        // Show current value for the selected attribute, with "current [attribute]: [value]" style
        const devs = window.devices || [];
        const dev = devs.find(d => d.id == data.deviceId);
        let currentStr = "";
        if (dev && dev.attributes && attribute && dev.attributes[attribute] !== undefined) {
          currentStr = `<div class="current-value">current ${attribute}: ${dev.attributes[attribute]}</div>`;
        }
        // For (minutes) display if set
        let forMinutesStr = '';
        if (
            type === "eventTrigger" &&
            data.sustainedMin &&
            Number(data.sustainedMin) > 0
        ) {
            forMinutesStr = `<div class="current-value" style="color:#eec150">For ${data.sustainedMin} min</div>`;
        }

        return `<div>
            ${type === "eventTrigger" ? "Event Trigger" : "Condition"}<br>
            <span style="font-size:11px">
            ${label} ${attribute} ${comparator} ${value}<br><hr>
            </span>
            ${forMinutesStr}
            ${currentStr}
        </div>`;
      }
    }

    function updateTileHtml(node) {
      if (editor && typeof editor.updateNodeHtmlFromId === "function") {
        editor.updateNodeHtmlFromId(node.id, nodeTileHtml(node.name, node.data, node.id));
      }
    }

    document.addEventListener("DOMContentLoaded", function () {
      // --- Wait for credentials autofill, then auto-load globals ---
      function tryAutoLoadGlobalsWhenReady(retries = 30) {
        const appIdEl = document.getElementById("hubitatAppId");
        const tokenEl = document.getElementById("hubitatToken");
        if (appIdEl && tokenEl && appIdEl.value && tokenEl.value) {
          autoLoadGlobalVarsFromHubitat();
        } else if (retries > 0) {
          setTimeout(() => tryAutoLoadGlobalsWhenReady(retries - 1), 200);
        }
      }
      tryAutoLoadGlobalsWhenReady();

      function rememberInput(inputId, storageKey) {
        const el = document.getElementById(inputId);
        if (localStorage.getItem(storageKey)) {
          el.value = localStorage.getItem(storageKey);
        }
        el.addEventListener("input", function() {
          localStorage.setItem(storageKey, el.value.trim());
        });
      }
      rememberInput("hubitatAppId", "hubitatAppId");
      rememberInput("hubitatToken", "hubitatToken");

      document.getElementById("loadDevices").onclick = async () => {
        if (!hubitatCredentialsAreValid(true)) return;
        logAction("loadDevices button clicked.");
        await fetchModesFromAppFile();
        devices = await fetchDevicesFromApp();
        devices.forEach(dev => {
          if (Array.isArray(dev.attributes)) {
            const attrMap = {};
            dev.attributes.forEach(a => {
              if (a.name !== undefined) attrMap[a.name] = a.currentValue;
            });
            dev.attributes = attrMap;
          }
        });
        devices.push(TIME_DEVICE);
        devices.push(MODE_DEVICE);
        window.devices = devices;

        // Set current mode on Home Location device
        const currentModeObj = (window.hubitatModes || []).find(m => m.id === "current");
        const currentMode = currentModeObj ? currentModeObj.name : "";
        const modeDev = window.devices.find(d => d.id === "__mode__");
        if (modeDev) {
          modeDev.attributes.mode = currentMode;
        }

        // (add specials)
        if (editor && editor.drawflow && editor.drawflow.Home && editor.drawflow.Home.data) {
          Object.values(editor.drawflow.Home.data).forEach(updateTileHtml);
          if (editor.selected_id) {
            renderEditor(editor.getNodeFromId(editor.selected_id));
          }
        }
        logAction("Devices loaded: " + devices.length);
      };

      // Auto-load devices if credentials are filled (with delayed check for browser autofill)
      setTimeout(() => {
        const appIdEl = document.getElementById("hubitatAppId");
        const tokenEl = document.getElementById("hubitatToken");
        if (appIdEl.value && tokenEl.value) {
          document.getElementById("loadDevices").click();
        }
      }, 350);

      document.getElementById("flowName").value = "";

      const flowNameInput = document.getElementById("flowName");
      function sanitizeFlowName(str) {
        return (str || "")
          .replace(/\s+/g, "_")      // Replace all whitespace with underscores
          .replace(/[^a-zA-Z0-9_\-]/g, "") // Only allow a-z, A-Z, 0-9, _, -
          .replace(/_{2,}/g, "_")    // No double underscores
          .replace(/^_+|_+$/g, "");  // No leading/trailing underscores
      }
      flowNameInput.addEventListener("input", function() {
        const sanitized = sanitizeFlowName(flowNameInput.value);
        if (flowNameInput.value !== sanitized) {
          flowNameInput.value = sanitized;
          logAction("No spaces or symbols allowed in Flow Name. Changed to: " + sanitized, "warn");
        }
      });
      flowNameInput.addEventListener("blur", function() {
        flowNameInput.value = sanitizeFlowName(flowNameInput.value);
      });

      let devices = [];

      function patchFlowWithDeviceLabels(flow, devices) {
        if (
          flow && flow.drawflow && flow.drawflow.drawflow &&
          flow.drawflow.drawflow.Home && flow.drawflow.drawflow.Home.data
        ) {
          Object.values(flow.drawflow.drawflow.Home.data).forEach(node => {
            if (node.name === "notMatchingVar") {
              if (!node.data.outputVar || node.data.outputVar === "undefined") {
                node.data.outputVar = "Devices Not Matching to JSON";
              }
            }
          });
        }
        if (!flow) flow = {};
        if (!flow.drawflow) flow.drawflow = {};
        if (!flow.drawflow.drawflow) flow.drawflow.drawflow = {};
        if (!flow.drawflow.drawflow.Home) flow.drawflow.drawflow.Home = { data: {} };
        if (!flow.drawflow.drawflow.Home.data) flow.drawflow.drawflow.Home.data = {}; 

        Object.values(flow.drawflow.drawflow.Home.data).forEach(node => {
          if (
            ["device", "condition", "eventTrigger"].includes(node.name) &&
            node.data &&
            node.data.deviceId
          ) {
            let dev = devices.find(d => d.id == node.data.deviceId);
            if (dev) {
              node.data.deviceLabel = dev.label || dev.name || node.data.deviceId;
            } else {
              node.data.deviceLabel = node.data.deviceId;
            }
          }
        });
      }

      const ATTRIBUTE_KNOWN_VALUES = {
        "contact":        ["open", "closed"],
        "switch":         ["on", "off"],
        "door":           ["open", "closed", "unknown"],
        "lock":           ["locked", "unlocked", "unknown"],
        "motion":         ["active", "inactive"],
        "presence":       ["present", "not present"],
        "water":          ["wet", "dry"],
        "smoke":          ["clear", "detected", "tested"],
        "carbonMonoxide": ["clear", "detected", "tested"],
        "acceleration":   ["active", "inactive"],
        "tamper":         ["clear", "detected"],
        "shade":          ["open", "closed", "partially open", "unknown"],
        "windowShade":    ["open", "closed", "partially open", "unknown"],
        "thermostatMode": [
          "off", "heat", "emergency heat", "cool", "auto", "fan only", "dry", "eco"
        ],
        "thermostatOperatingState": [
          "heating", "cooling", "idle", "pending heat", "pending cool", "fan only", "vent economizer"
        ],
        "thermostatFanMode": [
          "auto", "on", "circulate"
        ],
        "alarm":          ["off", "strobe", "siren", "both"],
        "valve":          ["open", "closed"],
        "button":         ["pushed", "held", "doubleTapped", "released"],
        "temperature":    [],
        "humidity":       [],
        "illuminance":    [],
        "energy":         [],
        "power":          [],
        "level":          []
      };

      function getSortedDevicesWithSpecials(devices) {
        const modeDevice = devices.find(d => d.id === "__mode__");
        const timeDevice = devices.find(d => d.id === "__time__");
        const variableDevice = devices.find(d => d.id === "__variable__");
        const realDevices = devices
          .filter(d => d.id !== "__mode__" && d.id !== "__time__" && d.id !== "__variable__")
          .slice()
          .sort((a, b) => {
            const aLabel = (a.label || a.name || a.id || "").toLowerCase();
            const bLabel = (b.label || b.name || b.id || "").toLowerCase();
            if (aLabel < bLabel) return -1;
            if (aLabel > bLabel) return 1;
            return 0;
          });
        const arr = [];
        if (modeDevice) arr.push(modeDevice);
        if (timeDevice) arr.push(timeDevice);
        if (variableDevice) arr.push(variableDevice);
        if (realDevices.length) arr.push({ id: "__divider__", label: "───────────────" });
        arr.push(...realDevices);
        return arr;
      }

      /**
       * Renders a device search/filter + (single/multi) select picker.
       * @param {HTMLElement} el - Where to append the picker.
       * @param {Array} devices - List of all devices.
       * @param {Array} selectedIds - Array of currently selected device IDs.
       * @param {Function} onChange - Called with (newSelectedIds, newDeviceLabels) when selection changes.
       * @param {boolean} multi - true for multi-select, false for single-select
       */
      function renderDevicePicker(el, devices, selectedIds, onChange, multi = true) {
        // Remove old content if called multiple times
        const existing = el.querySelector('.device-picker-block');
        if (existing) existing.remove();

        // Picker wrapper
        const pickerWrap = document.createElement("div");
        pickerWrap.className = "device-picker-block";
        pickerWrap.style = "margin-bottom:8px";

        // Search input
        const devFilterInput = document.createElement("input");
        devFilterInput.type = "text";
        devFilterInput.placeholder = "Search devices…";
        devFilterInput.style = "width:98%;margin-bottom:3px;padding:3px 7px;border-radius:7px;border:1px solid #333;font-size:13px;";
        pickerWrap.appendChild(devFilterInput);

        // Select dropdown
        const devSelect = document.createElement("select");
        devSelect.multiple = multi;
        devSelect.size = Math.min(10, devices.length);
        devSelect.style.width = "98%";
        devSelect.style.display = "block";
        devSelect.style.marginBottom = "12px";
        pickerWrap.appendChild(devSelect);

        // Helper: Fill dropdown
        function populate(filtered) {
          devSelect.innerHTML = "";
          getSortedDevicesWithSpecials(filtered).forEach((d) => {
            if (d.id === "__divider__") {
              const divider = document.createElement("option");
              divider.disabled = true;
              divider.textContent = d.label;
              divider.style.background = "#444";
              devSelect.appendChild(divider);
            } else {
              const opt = document.createElement("option");
              opt.value = d.id;
              opt.textContent = d.label || d.name || d.id;
              if (multi ? selectedIds.includes(d.id) : selectedIds[0] === d.id) opt.selected = true;
              devSelect.appendChild(opt);
            }
          });
        }
        populate(devices);

        // Live filter
        devFilterInput.oninput = function() {
          const filter = devFilterInput.value.trim().toLowerCase();
          if (!filter) { populate(devices); return; }
          const filtered = devices.filter(d =>
            (d.label || d.name || d.id || "").toLowerCase().includes(filter) ||
            d.id === "__time__" || d.id === "__mode__"
          );
          populate(filtered);
        };
        setTimeout(() => devFilterInput.focus(), 100);

        // On change
        devSelect.onchange = () => {
          let newSelected = Array.from(devSelect.selectedOptions).map(opt => opt.value);
          if (!multi) newSelected = newSelected.slice(0, 1); // Single
          const labels = newSelected.map(id => {
            const dev = devices.find(d => d.id == id);
            return dev ? (dev.label || dev.name || id) : id;
          });
          if (onChange) onChange(newSelected, labels);
          markFlowNeedsSave(true);
        };

        el.appendChild(pickerWrap);
      }

      // PATCH START: renderEditor, multi-trigger support
      function renderEditor(node) {
        if (!node) { document.getElementById("nodeEditor").innerHTML = "Click a node to edit"; return; }
        const el = document.getElementById("nodeEditor");
        el.innerHTML = "";

        // DEVICE NODE (Action)
        if (node.name === "device") {
          if (!devices || devices.length === 0) {
            el.innerHTML = "<div style='color:#eec150; margin-bottom:10px;'>No devices loaded!<br>Click 'Load Devices' at the top.</div>";
            return;
          }

          // --- Show/Hide tick box (showStatus) ---
          let showStatus = true;
          if (typeof node.data.showStatus === "boolean") showStatus = node.data.showStatus;
          const showStatusDiv = document.createElement("div");
          showStatusDiv.style = "margin-bottom: 8px; display:flex; align-items:center; gap:5px;";
          const showStatusCheckbox = document.createElement("input");
          showStatusCheckbox.type = "checkbox";
          showStatusCheckbox.checked = showStatus;
          showStatusCheckbox.onchange = () => {
            node.data.showStatus = showStatusCheckbox.checked;
            editor.updateNodeDataFromId(node.id, node.data);
            editor.updateNodeHtmlFromId(node.id, nodeTileHtml(node.name, node.data, node.id));
          };
          showStatusDiv.appendChild(showStatusCheckbox);
          const showStatusLbl = document.createElement("label");
          showStatusLbl.textContent = "Show status";
          showStatusLbl.style.margin = "0";
          showStatusDiv.appendChild(showStatusLbl);
          el.appendChild(showStatusDiv);

          // --- Device Label ---
          // --- Device(s) label and dropdown (now with search, single-select) ---
          const devLabel = document.createElement("label");
          devLabel.textContent = "Device(s)";
          devLabel.style.display = "block";
          el.appendChild(devLabel);

          renderDevicePicker(
            el,
            devices,
            Array.isArray(node.data.deviceIds)
              ? node.data.deviceIds
              : node.data.deviceId ? [node.data.deviceId] : [],
            (newSelectedIds, newDeviceLabels) => {
              node.data.deviceIds = newSelectedIds;
              node.data.deviceId = newSelectedIds.length === 1 ? newSelectedIds[0] : "";
              node.data.deviceLabel = newDeviceLabels.join(", ");
              node.data.attribute = "";
              node.data.command = "";
              node.data.value = "";
              node.data.color = "";
              editor.updateNodeDataFromId(node.id, node.data);
              editor.updateNodeHtmlFromId(node.id, nodeTileHtml(node.name, node.data, node.id));
              if (typeof buildPickers === "function") buildPickers();
              markFlowNeedsSave(true);
            },
            true // MULTI-select
          );

          // --- Picker container ---
          const pickerDiv = document.createElement("div");
          pickerDiv.id = "action-pickers-" + node.id;
          pickerDiv.style.marginTop = "8px";
          el.appendChild(pickerDiv);

          // --- Picker builder ---
          function buildPickers() {
            pickerDiv.innerHTML = "";

            const selectedDevices = Array.isArray(node.data.deviceIds)
              ? node.data.deviceIds.map(id => devices.find(d => d.id == id)).filter(Boolean)
              : node.data.deviceId
                ? [devices.find(d => d.id == node.data.deviceId)].filter(Boolean)
                : [];

            // ---- Handle special devices: Time or Mode ----
            if (selectedDevices.length === 1 && selectedDevices[0].id === "__time__") {
              // Time picker
              const timeLabel = document.createElement("label");
              timeLabel.textContent = "Time";
              timeLabel.style.display = "block";
              pickerDiv.appendChild(timeLabel);

              const timeInput = document.createElement("input");
              timeInput.type = "time";
              timeInput.value = node.data.value || "";
              timeInput.style.display = "block";
              timeInput.style.marginBottom = "12px";
              timeInput.onchange = () => {
                node.data.value = timeInput.value;
                editor.updateNodeDataFromId(node.id, node.data);
                editor.updateNodeHtmlFromId(node.id, nodeTileHtml(node.name, node.data, node.id));
              };
              pickerDiv.appendChild(timeInput);
              return;
            }

            // --- Standard device attribute/command pickers ---
            let sharedAttributes = [];
            let sharedCommands = [];
            if (selectedDevices.length > 0) {
              sharedAttributes = Object.keys(selectedDevices[0].attributes || {});
              sharedCommands = Array.isArray(selectedDevices[0].commands)
                ? selectedDevices[0].commands.slice()
                : [];
              for (let i = 1; i < selectedDevices.length; i++) {
                sharedAttributes = sharedAttributes.filter(attr =>
                  Object.prototype.hasOwnProperty.call(selectedDevices[i].attributes, attr)
                );
                if (Array.isArray(selectedDevices[i].commands)) {
                  sharedCommands = sharedCommands.filter(cmd =>
                    selectedDevices[i].commands.includes(cmd)
                  );
                } else {
                  sharedCommands = [];
                }
              }
            }

            // --- Attribute Picker ---
            const attrLabel = document.createElement("label");
            attrLabel.textContent = "Attribute";
            attrLabel.style.display = "block";
            pickerDiv.appendChild(attrLabel);

            const attrSelect = document.createElement("select");
            attrSelect.style.display = "block";
            attrSelect.style.marginBottom = "12px";
            attrSelect.innerHTML = `<option value="">Pick an attribute…</option>` +
              sharedAttributes.map(attr =>
                `<option value="${attr}" ${node.data.attribute == attr ? "selected" : ""}>${attr}</option>`
              ).join('');
            attrSelect.value = node.data.attribute || "";
            attrSelect.onchange = () => {
              node.data.attribute = attrSelect.value;
              node.data.command = "";
              node.data.value = "";
              editor.updateNodeDataFromId(node.id, node.data);
              editor.updateNodeHtmlFromId(node.id, nodeTileHtml(node.name, node.data, node.id));
              buildPickers();
            };
            pickerDiv.appendChild(attrSelect);

            // --- Command Picker ---
            const cmdLabel = document.createElement("label");
            cmdLabel.textContent = "Command";
            cmdLabel.style.display = "block";
            pickerDiv.appendChild(cmdLabel);

            const cmdSelect = document.createElement("select");
            cmdSelect.style.display = "block";
            cmdSelect.style.marginBottom = "12px";
            cmdSelect.innerHTML = `<option value="">Pick a command…</option>` +
              sharedCommands.map(cmd =>
                `<option value="${cmd}" ${node.data.command == cmd ? "selected" : ""}>${cmd}</option>`
              ).join('');
            cmdSelect.value = node.data.command || "";
            cmdSelect.onchange = () => {
              node.data.command = cmdSelect.value;
              node.data.value = "";
              editor.updateNodeDataFromId(node.id, node.data);
              editor.updateNodeHtmlFromId(node.id, nodeTileHtml(node.name, node.data, node.id));
              buildPickers();
            };
            pickerDiv.appendChild(cmdSelect);

            // --- Color Picker (for setColor command only) ---
            if (node.data.command === "setColor") {
              const colorLabel = document.createElement("label");
              colorLabel.textContent = "Color";
              colorLabel.style.display = "block";
              pickerDiv.appendChild(colorLabel);

              const colorInput = document.createElement("input");
              colorInput.type = "color";
              colorInput.value = node.data.color || "#ffffff";
              colorInput.style.display = "block";
              colorInput.style.marginBottom = "12px";
              colorInput.onchange = () => {
                node.data.color = colorInput.value;
                editor.updateNodeDataFromId(node.id, node.data);
                editor.updateNodeHtmlFromId(node.id, nodeTileHtml(node.name, node.data, node.id));
              };
              pickerDiv.appendChild(colorInput);
            }

            // --- Value Picker ---
            const valueLabel = document.createElement("label");
            valueLabel.textContent = "Value";
            valueLabel.style.display = "block";
            pickerDiv.appendChild(valueLabel);

            if (
              selectedDevices.length === 1 &&
              selectedDevices[0].id === "__mode__" &&
              node.data.attribute === "mode"
            ) {
              // Multi-select dropdown for modes
              const allModes = (window.hubitatModes || []).filter(m => m.id !== "current");
              const modeSelect = document.createElement("select");
              modeSelect.multiple = true;
              modeSelect.size = Math.min(7, allModes.length);
              modeSelect.style.display = "block";
              modeSelect.style.marginBottom = "12px";

              // Always store value as array for multi-select
              if (!Array.isArray(node.data.value)) {
                if (typeof node.data.value === "string" && node.data.value) {
                  node.data.value = [node.data.value];
                } else {
                  node.data.value = [];
                }
              }

              modeSelect.innerHTML = allModes.map(mode =>
                `<option value="${mode.name}" ${node.data.value.includes(mode.name) ? "selected" : ""}>${mode.name}</option>`
              ).join('');

              // Autofill to first mode if empty
              if (node.data.value.length === 0 && allModes.length > 0) {
                node.data.value = [allModes[0].name];
                Array.from(modeSelect.options)[0].selected = true;
                editor.updateNodeDataFromId(node.id, node.data);
              }

              modeSelect.onchange = () => {
                node.data.value = Array.from(modeSelect.selectedOptions).map(opt => opt.value);
                editor.updateNodeDataFromId(node.id, node.data);
                editor.updateNodeHtmlFromId(node.id, nodeTileHtml(node.name, node.data, node.id));
              };
              pickerDiv.appendChild(modeSelect);

            } else {
              if (node.data.comparator === "between") {
                // Render two inputs, for lower and upper bounds
                let betweenValues = Array.isArray(node.data.value)
                  ? node.data.value
                  : typeof node.data.value === "string" && node.data.value.includes(",")
                    ? node.data.value.split(",")
                    : ["",""];
                if (betweenValues.length < 2) betweenValues = [betweenValues[0] || "", ""];

                // Min
                let minInput = document.createElement("input");
                minInput.type = "text";
                minInput.value = betweenValues[0];
                minInput.placeholder = "Min";
                minInput.style.width = "45%";
                minInput.style.marginRight = "7px";

                // Max
                let maxInput = document.createElement("input");
                maxInput.type = "text";
                maxInput.value = betweenValues[1];
                maxInput.placeholder = "Max";
                maxInput.style.width = "45%";

                function updateBetweenValues() {
                  node.data.value = [minInput.value, maxInput.value];
                  editor.updateNodeDataFromId(node.id, node.data);
                  editor.updateNodeHtmlFromId(node.id, nodeTileHtml(node.name, node.data, node.id));
                }

                minInput.onchange = maxInput.onchange = updateBetweenValues;
                pickerDiv.appendChild(minInput);
                pickerDiv.appendChild(maxInput);
              } else {
                // Default
                let valueField = document.createElement("input");
                valueField.type = "text";
                valueField.value = Array.isArray(node.data.value) ? node.data.value.join(",") : (node.data.value || "");
                valueField.style.display = "block";
                valueField.style.marginBottom = "12px";
                valueField.onchange = () => {
                  node.data.value = valueField.value;
                  editor.updateNodeDataFromId(node.id, node.data);
                  editor.updateNodeHtmlFromId(node.id, nodeTileHtml(node.name, node.data, node.id));
                };
                pickerDiv.appendChild(valueField);
              }
            }
          }

          // Initial build
          buildPickers();
        }

        // EVENT TRIGGER NODE (with multi-device support)
        // ---- Event Trigger Node ----
        // EVENT TRIGGER NODE (full logic)
        if (node.name === "eventTrigger") {
            // ---- Device picker setup (Home Location, Time, Variable, divider, all others) ----
            const devices = Array.isArray(window.devices) ? window.devices.slice() : [];
            const homeLoc = devices.find(d => d.id === "__mode__");
            const timeDev = devices.find(d => d.id === "__time__");
            const varDev = { id: "__variable__", label: "Variable", name: "Variable" };
            const rest = devices.filter(d => !["__mode__", "__time__"].includes(d.id));
            let pickerDevices = [];
            if (homeLoc) pickerDevices.push(homeLoc);
            if (timeDev) pickerDevices.push(timeDev);
            pickerDevices.push(varDev);
            if (rest.length) pickerDevices.push({ id: "__divider__", label: "───────────────" });
            pickerDevices = pickerDevices.concat(rest.sort((a, b) => {
              const la = (a.label || a.name || a.id).toLowerCase();
              const lb = (b.label || b.name || b.id).toLowerCase();
              return la.localeCompare(lb);
            }));

            // --- Device(s) label ---
            const devLabel = document.createElement("label");
            devLabel.textContent = "Device";
            devLabel.style.display = "block";
            el.appendChild(devLabel);

            // --- Device picker ---
            renderDevicePicker(
              el,
              pickerDevices,
              [node.data.deviceId || (Array.isArray(node.data.deviceIds) ? node.data.deviceIds[0] : "")].filter(Boolean),
              (newSelectedIds, newDeviceLabels) => {
                node.data.deviceId = newSelectedIds[0] || "";
                node.data.deviceIds = [node.data.deviceId];
                if (node.data.deviceId !== "__variable__") node.data.varName = "";
                node.data.attribute = "";
                node.data.comparator = "";
                node.data.value = "";
                editor.updateNodeDataFromId(node.id, node.data);
                markFlowNeedsSave(true);
                renderEditor(node);
              },
              false // single select
            );

            // ---- Stop if nothing picked
            if (!node.data.deviceId) return;

            // --- "Variable" Virtual Device Special Case ---
            if (node.data.deviceId === "__variable__") {
                const globalVars = Array.isArray(window.FE_global_vars) ? window.FE_global_vars : [];
                const allVars = globalVars.map(v => v.name).filter(Boolean).sort((a, b) => a.localeCompare(b));

                const varNameLabel = document.createElement("label");
                varNameLabel.textContent = "Variable Name";
                varNameLabel.style.display = "block";
                el.appendChild(varNameLabel);

                const varNameSelect = document.createElement("select");
                varNameSelect.style.display = "block";
                varNameSelect.style.marginBottom = "12px";
                varNameSelect.innerHTML =
                  `<option value="">Pick a variable…</option>` +
                  allVars.map(v =>
                    `<option value="${v}" ${node.data.varName == v ? "selected" : ""}>${v}</option>`
                  ).join('');
                varNameSelect.value = node.data.varName || "";
                varNameSelect.onchange = () => {
                  node.data.varName = varNameSelect.value;
                  editor.updateNodeDataFromId(node.id, node.data);
                  markFlowNeedsSave(true);
                };
                el.appendChild(varNameSelect);

                // Comparators for variable
                const compLabel = document.createElement("label");
                compLabel.textContent = "Comparator";
                compLabel.style.display = "block";
                el.appendChild(compLabel);

                const compSelect = document.createElement("select");
                compSelect.style.display = "block";
                compSelect.style.marginBottom = "12px";
                const comparators = [
                    "==", "!=", "<", "<=", ">", ">=", "between", "contains", "not contains", "changes"
                ];
                const comparatorLabels = {
                    "==": "equals (==)",
                    "!=": "not equals (!=)",
                    "<": "less than (<)",
                    "<=": "less than or equal (<=)",
                    ">": "greater than (>)",
                    ">=": "greater than or equal (>=)",
                    "between": "between",
                    "contains": "contains",
                    "not contains": "not contains",
                    "changes": "changes"
                };
                compSelect.innerHTML = `<option value="">Pick…</option>` +
                    comparators.map(cmp =>
                        `<option value="${cmp}" ${node.data.comparator == cmp ? "selected" : ""}>${comparatorLabels[cmp]}</option>`
                    ).join('');
                compSelect.value = node.data.comparator || "";
                compSelect.onchange = () => {
                    node.data.comparator = compSelect.value;
                    editor.updateNodeDataFromId(node.id, node.data);
                    markFlowNeedsSave(true);
                    renderEditor(node);
                };
                el.appendChild(compSelect);

                // Value field
                const valLabel = document.createElement("label");
                valLabel.textContent = "Value";
                valLabel.style.display = "block";
                el.appendChild(valLabel);

                if (node.data.comparator === "between") {
                    // Two inputs for min/max
                    let betweenValues = Array.isArray(node.data.value)
                        ? node.data.value
                        : typeof node.data.value === "string" && node.data.value.includes(",")
                            ? node.data.value.split(",")
                            : ["", ""];
                    if (betweenValues.length < 2) betweenValues = [betweenValues[0] || "", ""];
                    let minInput = document.createElement("input");
                    minInput.type = "text";
                    minInput.value = betweenValues[0];
                    minInput.placeholder = "Min";
                    minInput.style.width = "45%";
                    minInput.style.marginRight = "7px";
                    let maxInput = document.createElement("input");
                    maxInput.type = "text";
                    maxInput.value = betweenValues[1];
                    maxInput.placeholder = "Max";
                    maxInput.style.width = "45%";
                    function updateBetweenValues() {
                        node.data.value = [minInput.value, maxInput.value];
                        editor.updateNodeDataFromId(node.id, node.data);
                        markFlowNeedsSave(true);
                    }
                    minInput.onchange = maxInput.onchange = updateBetweenValues;
                    el.appendChild(minInput);
                    el.appendChild(maxInput);
                } else {
                    let valueField = document.createElement("input");
                    valueField.type = "text";
                    valueField.value = Array.isArray(node.data.value) ? node.data.value.join(",") : (node.data.value || "");
                    valueField.style.display = "block";
                    valueField.style.marginBottom = "12px";
                    valueField.oninput = () => {
                        node.data.value = valueField.value;
                        editor.updateNodeDataFromId(node.id, node.data);
                        markFlowNeedsSave(true);
                    };
                    el.appendChild(valueField);
                }
                return;
            }

            // --- Home Location (Mode) special handling ---
            if (node.data.deviceId === "__mode__") {
                const attrLabel = document.createElement("label");
                attrLabel.textContent = "Attribute";
                attrLabel.style.display = "block";
                el.appendChild(attrLabel);

                const attrSelect = document.createElement("select");
                attrSelect.style.display = "block";
                attrSelect.style.marginBottom = "12px";
                attrSelect.innerHTML = `<option value="mode" selected>mode</option>`;
                attrSelect.value = node.data.attribute || "mode";
                attrSelect.onchange = () => {
                  node.data.attribute = attrSelect.value;
                  node.data.comparator = "";
                  node.data.value = [];
                  editor.updateNodeDataFromId(node.id, node.data);
                  markFlowNeedsSave(true);
                  renderEditor(node);
                };
                el.appendChild(attrSelect);

                // Comparator
                const compLabel = document.createElement("label");
                compLabel.textContent = "Comparator";
                compLabel.style.display = "block";
                el.appendChild(compLabel);

                const compSelect = document.createElement("select");
                compSelect.style.display = "block";
                compSelect.style.marginBottom = "12px";
                const comparators = ["==", "!="];
                compSelect.innerHTML = `<option value="">Pick…</option>` +
                  comparators.map(cmp =>
                    `<option value="${cmp}" ${node.data.comparator == cmp ? "selected" : ""}>${cmp === "==" ? "equals (==)" : "not equals (!=)"}</option>`
                  ).join('');
                compSelect.value = node.data.comparator || "";
                compSelect.onchange = () => {
                  node.data.comparator = compSelect.value;
                  editor.updateNodeDataFromId(node.id, node.data);
                  markFlowNeedsSave(true);
                  renderEditor(node);
                };
                el.appendChild(compSelect);

                // Mode value multi-select
                if (node.data.comparator) {
                    const valueLabel = document.createElement("label");
                    valueLabel.textContent = "Value";
                    valueLabel.style.display = "block";
                    el.appendChild(valueLabel);

                    const allModes = (window.hubitatModes || []).filter(m => m.id !== "current");
                    const modeSelect = document.createElement("select");
                    modeSelect.multiple = true;
                    modeSelect.size = Math.min(7, allModes.length);
                    modeSelect.style.display = "block";
                    modeSelect.style.marginBottom = "12px";

                    if (!Array.isArray(node.data.value)) {
                        if (typeof node.data.value === "string" && node.data.value) {
                          node.data.value = [node.data.value];
                        } else {
                          node.data.value = [];
                        }
                    }
                    modeSelect.innerHTML = allModes.map(mode =>
                      `<option value="${mode.name}" ${node.data.value.includes(mode.name) ? "selected" : ""}>${mode.name}</option>`
                    ).join('');

                    if (node.data.value.length === 0 && allModes.length > 0) {
                      node.data.value = [allModes[0].name];
                      Array.from(modeSelect.options)[0].selected = true;
                      editor.updateNodeDataFromId(node.id, node.data);
                    }

                    modeSelect.onchange = () => {
                      node.data.value = Array.from(modeSelect.selectedOptions).map(opt => opt.value);
                      editor.updateNodeDataFromId(node.id, node.data);
                      editor.updateNodeHtmlFromId(node.id, nodeTileHtml(node.name, node.data, node.id));
                    };
                    el.appendChild(modeSelect);
                }
                return;
            }

            // --- Regular Device ---
            // --- Attribute dropdown ---
            const dev = devices.find(d => d.id === node.data.deviceId);
            if (!dev || !dev.attributes) return;
            const attrLabel = document.createElement("label");
            attrLabel.textContent = "Attribute";
            attrLabel.style.display = "block";
            el.appendChild(attrLabel);

            const attrSelect = document.createElement("select");
            attrSelect.style.display = "block";
            attrSelect.style.marginBottom = "12px";
            attrSelect.innerHTML = `<option value="">Pick an attribute…</option>` +
              Object.keys(dev.attributes).map(attr =>
                `<option value="${attr}" ${node.data.attribute == attr ? "selected" : ""}>${attr}</option>`
              ).join('');
            attrSelect.value = node.data.attribute || "";
            attrSelect.onchange = () => {
                node.data.attribute = attrSelect.value;
                node.data.comparator = "";
                node.data.value = "";
                editor.updateNodeDataFromId(node.id, node.data);
                markFlowNeedsSave(true);
                renderEditor(node);
            };
            el.appendChild(attrSelect);

            // --- Comparator dropdown ---
            if (node.data.attribute) {
                const compLabel = document.createElement("label");
                compLabel.textContent = "Comparator";
                compLabel.style.display = "block";
                el.appendChild(compLabel);

                const compSelect = document.createElement("select");
                compSelect.style.display = "block";
                compSelect.style.marginBottom = "12px";
                const comparators = [
                    "==", "!=", "<", "<=", ">", ">=", "between", "contains", "not contains", "changes"
                ];
                const comparatorLabels = {
                    "==": "equals (==)",
                    "!=": "not equals (!=)",
                    "<": "less than (<)",
                    "<=": "less than or equal (<=)",
                    ">": "greater than (>)",
                    ">=": "greater than or equal (>=)",
                    "between": "between",
                    "contains": "contains",
                    "not contains": "not contains",
                    "changes": "changes"
                };
                compSelect.innerHTML = `<option value="">Pick…</option>` +
                    comparators.map(cmp =>
                        `<option value="${cmp}" ${node.data.comparator == cmp ? "selected" : ""}>${comparatorLabels[cmp]}</option>`
                    ).join('');
                compSelect.value = node.data.comparator || "";
                compSelect.onchange = () => {
                    node.data.comparator = compSelect.value;
                    editor.updateNodeDataFromId(node.id, node.data);
                    markFlowNeedsSave(true);
                    renderEditor(node);
                };
                el.appendChild(compSelect);
            }

            // --- Value input ---
            if (node.data.attribute && node.data.comparator) {
                const valLabel = document.createElement("label");
                valLabel.textContent = "Value";
                valLabel.style.display = "block";
                el.appendChild(valLabel);

                if (node.data.comparator === "between") {
                    // Two inputs for min/max
                    let betweenValues = Array.isArray(node.data.value)
                        ? node.data.value
                        : typeof node.data.value === "string" && node.data.value.includes(",")
                            ? node.data.value.split(",")
                            : ["", ""];
                    if (betweenValues.length < 2) betweenValues = [betweenValues[0] || "", ""];
                    let minInput = document.createElement("input");
                    minInput.type = "text";
                    minInput.value = betweenValues[0];
                    minInput.placeholder = "Min";
                    minInput.style.width = "45%";
                    minInput.style.marginRight = "7px";
                    let maxInput = document.createElement("input");
                    maxInput.type = "text";
                    maxInput.value = betweenValues[1];
                    maxInput.placeholder = "Max";
                    maxInput.style.width = "45%";
                    function updateBetweenValues() {
                        node.data.value = [minInput.value, maxInput.value];
                        editor.updateNodeDataFromId(node.id, node.data);
                        markFlowNeedsSave(true);
                    }
                    minInput.onchange = maxInput.onchange = updateBetweenValues;
                    el.appendChild(minInput);
                    el.appendChild(maxInput);
                } else {
                    let valueField = document.createElement("input");
                    valueField.type = "text";
                    valueField.value = Array.isArray(node.data.value) ? node.data.value.join(",") : (node.data.value || "");
                    valueField.style.display = "block";
                    valueField.style.marginBottom = "12px";
                    valueField.oninput = () => {
                        node.data.value = valueField.value;
                        editor.updateNodeDataFromId(node.id, node.data);
                        markFlowNeedsSave(true);
                    };
                    el.appendChild(valueField);
                }
            }
            return;
        }

        // CONDITION NODE (multi-device support, like eventTrigger)
        if (node.name === "condition") {
          // Build device dropdown (Home Location, Time, Variable, divider, all others A–Z)
          const devices = Array.isArray(window.devices) ? window.devices.slice() : [];
          const homeLoc = devices.find(d => d.id === "__mode__");
          const timeDev = devices.find(d => d.id === "__time__");
          const varDev = { id: "__variable__", label: "Variable", name: "Variable" };
          const rest = devices.filter(d => !["__mode__", "__time__"].includes(d.id));
          // Insert Variable in correct spot (always after Time if Time exists)
          let pickerDevices = [];
          if (homeLoc) pickerDevices.push(homeLoc);
          if (timeDev) pickerDevices.push(timeDev);
          pickerDevices.push(varDev);
          if (rest.length) pickerDevices.push({ id: "__divider__", label: "───────────────" });
          pickerDevices = pickerDevices.concat(rest.sort((a, b) => {
            const la = (a.label || a.name || a.id).toLowerCase();
            const lb = (b.label || b.name || b.id).toLowerCase();
            return la.localeCompare(lb);
          }));

          // --- Device(s) label ---
          const devLabel = document.createElement("label");
          devLabel.textContent = "Device(s)";
          devLabel.style.display = "block";
          el.appendChild(devLabel);

          // --- Device picker (single-select) ---
          renderDevicePicker(
            el,
            pickerDevices,
            [node.data.deviceId || (Array.isArray(node.data.deviceIds) ? node.data.deviceIds[0] : "")].filter(Boolean),
            (newSelectedIds, newDeviceLabels) => {
              node.data.deviceId = newSelectedIds[0] || "";
              node.data.deviceIds = [node.data.deviceId];
              if (node.data.deviceId !== "__variable__") node.data.varName = "";
              node.data.attribute = "";
              node.data.comparator = "";
              node.data.value = "";
              editor.updateNodeDataFromId(node.id, node.data);
              markFlowNeedsSave(true);
              if (typeof buildPickers === "function") buildPickers();
              renderEditor(node);
            },
            false
          );

          // --- If "Variable" is selected, show variable name dropdown ---
          if (
            node.data.deviceId === "__variable__" ||
            (Array.isArray(node.data.deviceIds) && node.data.deviceIds[0] === "__variable__")
          ) {
            const globalVars = Array.isArray(window.FE_global_vars) ? window.FE_global_vars : [];
            const allVars = globalVars.map(v => v.name).filter(Boolean).sort((a, b) => a.localeCompare(b));
            console.log("DEBUG: Names from FE_global_vars", allVars);


            const varNameLabel = document.createElement("label");
            varNameLabel.textContent = "Variable Name";
            varNameLabel.style.display = "block";
            el.appendChild(varNameLabel);

            const varNameSelect = document.createElement("select");
            varNameSelect.style.display = "block";
            varNameSelect.style.marginBottom = "12px";
            varNameSelect.innerHTML =
              `<option value="">Pick a variable…</option>` +
              allVars.map(v =>
                `<option value="${v}" ${node.data.varName == v ? "selected" : ""}>${v}</option>`
              ).join('');
            varNameSelect.value = node.data.varName || "";
            varNameSelect.onchange = () => {
              node.data.varName = varNameSelect.value;
              editor.updateNodeDataFromId(node.id, node.data);
              markFlowNeedsSave(true);
            };
            el.appendChild(varNameSelect);
          }

          // --- Comparator dropdown ---
          const compLabel = document.createElement("label");
          compLabel.textContent = "Comparator";
          compLabel.style.display = "block";
          el.appendChild(compLabel);

          const compSelect = document.createElement("select");
          compSelect.style.display = "block";
          compSelect.style.marginBottom = "12px";
          const comparators = [
            "==", "!=", "<", "<=", ">", ">=", "between", "contains", "not contains", "changes"
          ];
          const comparatorLabels = {
            "==": "equals (==)",
            "!=": "not equals (!=)",
            "<": "less than (<)",
            "<=": "less than or equal (<=)",
            ">": "greater than (>)",
            ">=": "greater than or equal (>=)",
            "between": "between",
            "contains": "contains",
            "not contains": "not contains",
            "changes": "changes"
          };
          compSelect.innerHTML = `<option value="">Pick…</option>` +
            comparators.map(cmp =>
              `<option value="${cmp}" ${node.data.comparator == cmp ? "selected" : ""}>${comparatorLabels[cmp]}</option>`
            ).join('');
          compSelect.value = node.data.comparator || "";
          compSelect.onchange = () => {
            node.data.comparator = compSelect.value;
            editor.updateNodeDataFromId(node.id, node.data);
            markFlowNeedsSave(true);
            renderEditor(node);
          };
          el.appendChild(compSelect);

          // --- Value input (single or between) ---
          const valLabel = document.createElement("label");
          valLabel.textContent = "Value";
          valLabel.style.display = "block";
          el.appendChild(valLabel);

          if (node.data.comparator === "between") {
            let betweenValues = Array.isArray(node.data.value)
              ? node.data.value
              : typeof node.data.value === "string" && node.data.value.includes(",")
                ? node.data.value.split(",")
                : ["", ""];
            if (betweenValues.length < 2) betweenValues = [betweenValues[0] || "", ""];
            let minInput = document.createElement("input");
            minInput.type = "text";
            minInput.value = betweenValues[0];
            minInput.placeholder = "Min";
            minInput.style.width = "45%";
            minInput.style.marginRight = "7px";
            let maxInput = document.createElement("input");
            maxInput.type = "text";
            maxInput.value = betweenValues[1];
            maxInput.placeholder = "Max";
            maxInput.style.width = "45%";
            function updateBetweenValues() {
              node.data.value = [minInput.value, maxInput.value];
              editor.updateNodeDataFromId(node.id, node.data);
              markFlowNeedsSave(true);
            }
            minInput.onchange = maxInput.onchange = updateBetweenValues;
            el.appendChild(minInput);
            el.appendChild(maxInput);
          } else {
            let valueField = document.createElement("input");
            valueField.type = "text";
            valueField.value = Array.isArray(node.data.value) ? node.data.value.join(",") : (node.data.value || "");
            valueField.style.display = "block";
            valueField.style.marginBottom = "12px";
            valueField.oninput = () => {
              node.data.value = valueField.value;
              editor.updateNodeDataFromId(node.id, node.data);
              markFlowNeedsSave(true);
            };
            el.appendChild(valueField);
          }
        }

        if (node.name === "delay") {
          const el = document.getElementById("nodeEditor");
          el.innerHTML = "<b>Delay (Milliseconds)</b><br><br>";

          const msLabel = document.createElement("label");
          msLabel.textContent = "Delay (ms): ";
          el.appendChild(msLabel);

          const msInput = document.createElement("input");
          msInput.type = "number";
          msInput.min = 1;
          msInput.value = node.data.delayMs || 1000;
          msInput.style.width = "80px";
          msInput.oninput = () => {
            node.data.delayMs = Number(msInput.value) || 1;
            editor.updateNodeDataFromId(node.id, node.data);
            editor.updateNodeHtmlFromId(node.id, nodeTileHtml(node.name, node.data, node.id));
          };
          el.appendChild(msInput);

          return;
        }

        if (node.name === "delayMin") {
          const el = document.getElementById("nodeEditor");
          el.innerHTML = "<b>Delay (Minutes)</b><br><br>";

          const minLabel = document.createElement("label");
          minLabel.textContent = "Delay (minutes): ";
          el.appendChild(minLabel);

          const minInput = document.createElement("input");
          minInput.type = "number";
          minInput.min = 1;
          minInput.value = node.data.delayMin || 1;
          minInput.style.width = "60px";
          minInput.oninput = () => {
            node.data.delayMin = Number(minInput.value) || 1;
            editor.updateNodeDataFromId(node.id, node.data);
            editor.updateNodeHtmlFromId(node.id, nodeTileHtml(node.name, node.data, node.id));
          };
          el.appendChild(minInput);

          return;
        }

        if (node.name === "setVariable") {
          el.innerHTML = "<b>Set Variable</b><br><br>";

          // Variable Name
          const varLabel = document.createElement("label");
          varLabel.textContent = "Variable Name";
          el.appendChild(varLabel);

          const varInput = document.createElement("input");
          varInput.type = "text";
          varInput.placeholder = "Enter variable name";
          varInput.value = node.data.varName || "";
          varInput.style.width = "98%";
          varInput.oninput = () => {
            // Reuse the same sanitizer as flow name
            node.data.varName = sanitizeFlowName(varInput.value);
            varInput.value = node.data.varName; // Show fixed value in UI
            editor.updateNodeDataFromId(node.id, node.data);
            editor.updateNodeHtmlFromId(node.id, nodeTileHtml(node.name, node.data, node.id));
          };
          el.appendChild(varInput);

          // Value
          const valLabel = document.createElement("label");
          valLabel.textContent = "Value";
          el.appendChild(valLabel);

          const valInput = document.createElement("input");
          valInput.type = "text";
          valInput.placeholder = "Value to set";
          valInput.value = node.data.varValue || "";
          valInput.style.width = "98%";
          valInput.oninput = () => {
            node.data.varValue = valInput.value;
            editor.updateNodeDataFromId(node.id, node.data);
            editor.updateNodeHtmlFromId(node.id, nodeTileHtml(node.name, node.data, node.id));
          };
          el.appendChild(valInput);

          // Variable Insert Button
          const plusVarBtn = document.createElement("button");
          plusVarBtn.type = "button";
          plusVarBtn.textContent = "+Var";
          plusVarBtn.title = "Insert a variable into this field";
          plusVarBtn.style.marginLeft = "6px";
          plusVarBtn.style.padding = "2px 8px";
          plusVarBtn.style.fontSize = "13px";
          plusVarBtn.style.borderRadius = "7px";
          plusVarBtn.style.background = "#334bff";
          plusVarBtn.style.color = "#fff";
          plusVarBtn.onclick = function() {
            if (window.flowVars && window.flowVars.updateCtx) window.flowVars.updateCtx();
            if (!window.flowVars) return alert("FE_flowVars.js not loaded!");
            const allVars = (window.flowVars.getVars ? window.flowVars.getVars() : []);
            if (!allVars.length) return alert("No variables defined!");
            if (allVars.length === 1) {
              let insert = `$(${allVars[0].name})`;
              let start = valInput.selectionStart, end = valInput.selectionEnd;
              let oldVal = valInput.value;
              valInput.value = oldVal.slice(0, start) + insert + oldVal.slice(end);
              valInput.focus();
              valInput.selectionStart = valInput.selectionEnd = start + insert.length;
              valInput.dispatchEvent(new Event('input'));
              return;
            }
            const sel = document.createElement("select");
            sel.innerHTML = allVars.map(v => `<option value="${v.name}">${v.name}</option>`).join('');
            sel.onchange = () => {
              let insert = `$(${sel.value})`;
              let start = valInput.selectionStart, end = valInput.selectionEnd;
              let oldVal = valInput.value;
              valInput.value = oldVal.slice(0, start) + insert + oldVal.slice(end);
              valInput.focus();
              valInput.selectionStart = valInput.selectionEnd = start + insert.length;
              valInput.dispatchEvent(new Event('input'));
              document.body.removeChild(sel);
            };
            sel.style.position = "absolute";
            let r = plusVarBtn.getBoundingClientRect();
            sel.style.left = r.left + "px";
            sel.style.top = (r.bottom + 2) + "px";
            sel.style.zIndex = 9999;
            document.body.appendChild(sel);
            sel.focus();
          };
          el.appendChild(plusVarBtn);

          // Preview of result
          const previewChip = document.createElement("div");
          previewChip.className = "current-value";
          previewChip.style.marginLeft = "2px";
          previewChip.style.fontSize = "13px";
          previewChip.style.fontWeight = "bold";
          previewChip.style.cursor = "pointer";
          previewChip.title = "Preview of value/expression";
          el.appendChild(previewChip);
          function updatePreview() {
            if (window.flowVars && window.flowVars.evaluate) {
              try {
                const v = valInput.value;
                if (!v.trim()) { previewChip.textContent = ""; previewChip.title = ""; return; }
                const result = window.flowVars.evaluate(v);
                let color = "#b7ffac";
                if (typeof result === "number") color = "#3af";
                else if (typeof result === "boolean") color = "#0c0";
                else if (typeof result === "string" && result.startsWith("ERR:")) color = "#f33";
                previewChip.textContent = "= " + result;
                previewChip.style.color = color;
                previewChip.title = (typeof result) + ": " + result;
              } catch(e) {
                previewChip.textContent = "ERR: " + e.message;
                previewChip.style.color = "#f33";
                previewChip.title = e.message;
              }
            }
          }
          valInput.addEventListener("input", updatePreview);
          updatePreview();

          return;
        }

        if (node.name === "notMatchingVar") {
          if (!devices || devices.length === 0) {
            el.innerHTML = "<div style='color:#eec150; margin-bottom:10px;'>No devices loaded!<br>Click 'Load Devices' at the top.</div>";
            return;
          }

          // --- Output JSON name ---
          const outVarLabel = document.createElement("label");
          outVarLabel.textContent = "Output JSON name - Be sure it starts with 'var_'";
          outVarLabel.style.display = "block";
          el.appendChild(outVarLabel);

          const outVarInput = document.createElement("input");
          outVarInput.type = "text";
          outVarInput.value = node.data.outputVar || "";
          outVarInput.style.display = "block";
          outVarInput.style.marginBottom = "12px";
          outVarInput.placeholder = "Result variable";
          outVarInput.oninput = () => {
            node.data.outputVar = sanitizeFlowName(outVarInput.value);
            outVarInput.value = node.data.outputVar; // Show fixed value in UI
            editor.updateNodeDataFromId(node.id, node.data);
            editor.updateNodeHtmlFromId(node.id, nodeTileHtml(node.name, node.data, node.id));
          };
          el.appendChild(outVarInput);

          // --- Show/Hide tick box (showStatus) ---
          let showStatus = true;
          if (typeof node.data.showStatus === "boolean") showStatus = node.data.showStatus;
          const showStatusDiv = document.createElement("div");
          showStatusDiv.style = "margin-bottom: 8px; display:flex; align-items:center; gap:5px;";
          const showStatusCheckbox = document.createElement("input");
          showStatusCheckbox.type = "checkbox";
          showStatusCheckbox.checked = showStatus;
          showStatusCheckbox.onchange = () => {
            node.data.showStatus = showStatusCheckbox.checked;
            editor.updateNodeDataFromId(node.id, node.data);
            editor.updateNodeHtmlFromId(node.id, nodeTileHtml(node.name, node.data, node.id));
          };
          showStatusDiv.appendChild(showStatusCheckbox);
          const showStatusLbl = document.createElement("label");
          showStatusLbl.textContent = "Show status";
          showStatusLbl.style.margin = "0";
          showStatusDiv.appendChild(showStatusLbl);
          el.appendChild(showStatusDiv);

          // --- Device Label ---
          const devLabel = document.createElement("label");
          devLabel.textContent = "Device(s)";
          devLabel.style.display = "block";
          el.appendChild(devLabel);

          // --- Device Select (multi) ---
          const devSelect = document.createElement("select");
          devSelect.multiple = true;
          devSelect.size = Math.min(10, devices.length);
          devSelect.style.width = "98%";
          devSelect.style.display = "block";
          devSelect.style.marginBottom = "12px";
          const selectedIds = Array.isArray(node.data.deviceIds)
            ? node.data.deviceIds
            : node.data.deviceId ? [node.data.deviceId] : [];
          getSortedDevicesWithSpecials(devices).forEach((d) => {
            if (d.id === "__divider__") {
              const divider = document.createElement("option");
              divider.disabled = true;
              divider.textContent = d.label;
              divider.style.background = "#444";
              devSelect.appendChild(divider);
            } else {
              const opt = document.createElement("option");
              opt.value = d.id;
              opt.textContent = d.label || d.name || d.id;
              if (selectedIds.includes(d.id)) opt.selected = true;
              devSelect.appendChild(opt);
            }
          });
          el.appendChild(devSelect);

          // --- Picker container ---
          const pickerDiv = document.createElement("div");
          pickerDiv.id = "notmatchingvar-pickers-" + node.id;
          pickerDiv.style.marginTop = "8px";
          el.appendChild(pickerDiv);

          // --- Picker builder ---
          function buildPickers() {
            pickerDiv.innerHTML = "";

            const selectedDevices = Array.isArray(node.data.deviceIds)
              ? node.data.deviceIds.map(id => devices.find(d => d.id == id)).filter(Boolean)
              : node.data.deviceId
                ? [devices.find(d => d.id == node.data.deviceId)].filter(Boolean)
                : [];

            // --- Time special device ---
            if (selectedDevices.length === 1 && selectedDevices[0].id === "__time__") {
              const timeLabel = document.createElement("label");
              timeLabel.textContent = "Time";
              timeLabel.style.display = "block";
              pickerDiv.appendChild(timeLabel);

              const timeInput = document.createElement("input");
              timeInput.type = "time";
              timeInput.value = node.data.value || "";
              timeInput.style.display = "block";
              timeInput.style.marginBottom = "12px";
              timeInput.onchange = () => {
                node.data.value = timeInput.value;
                editor.updateNodeDataFromId(node.id, node.data);
                editor.updateNodeHtmlFromId(node.id, nodeTileHtml(node.name, node.data, node.id));
              };
              pickerDiv.appendChild(timeInput);
              return;
            }
            
            // --- Standard device attribute pickers ---
            let sharedAttributes = [];
            if (selectedDevices.length > 0) {
              sharedAttributes = Object.keys(selectedDevices[0].attributes || {});
              for (let i = 1; i < selectedDevices.length; i++) {
                sharedAttributes = sharedAttributes.filter(attr =>
                  Object.prototype.hasOwnProperty.call(selectedDevices[i].attributes, attr)
                );
              }
            }
            // --- Attribute Picker ---
            const attrLabel = document.createElement("label");
            attrLabel.textContent = "Attribute";
            attrLabel.style.display = "block";
            pickerDiv.appendChild(attrLabel);

            const attrSelect = document.createElement("select");
            attrSelect.style.display = "block";
            attrSelect.style.marginBottom = "12px";
            attrSelect.innerHTML = `<option value="">Pick an attribute…</option>` +
              sharedAttributes.map(attr =>
                `<option value="${attr}" ${node.data.attribute == attr ? "selected" : ""}>${attr}</option>`
              ).join('');
            attrSelect.value = node.data.attribute || "";
            attrSelect.onchange = () => {
              node.data.attribute = attrSelect.value;
              node.data.comparator = "";
              node.data.value = "";
              editor.updateNodeDataFromId(node.id, node.data);
              editor.updateNodeHtmlFromId(node.id, nodeTileHtml(node.name, node.data, node.id));
              buildPickers();
            };
            pickerDiv.appendChild(attrSelect);

            // --- Comparator Picker ---
            const cmpLabel = document.createElement("label");
            cmpLabel.textContent = "Comparator";
            cmpLabel.style.display = "block";
            pickerDiv.appendChild(cmpLabel);

            const cmpSelect = document.createElement("select");
            cmpSelect.style.display = "block";
            cmpSelect.style.marginBottom = "12px";
            const allComparators = [
              "==", "!=", "<", "<=", ">", ">=", "between", "contains", "not contains", "changes"
            ];
            const comparatorLabels = {
              "==": "equals (==)",
              "!=": "not equals (!=)",
              "<": "less than (<)",
              "<=": "less than or equal (<=)",
              ">": "greater than (>)",
              ">=": "greater than or equal (>=)",
              "between": "between",
              "contains": "contains",
              "not contains": "not contains",
              "changes": "changes"
            };
            cmpSelect.innerHTML = `<option value="">Pick…</option>` +
              allComparators.map(cmp =>
                `<option value="${cmp}" ${node.data.comparator == cmp ? "selected" : ""}>${comparatorLabels[cmp]}</option>`
              ).join('');
            cmpSelect.value = node.data.comparator || "";
            cmpSelect.onchange = () => {
              node.data.comparator = cmpSelect.value;
              editor.updateNodeDataFromId(node.id, node.data);
              editor.updateNodeHtmlFromId(node.id, nodeTileHtml(node.name, node.data, node.id));
              buildPickers();
            };
            pickerDiv.appendChild(cmpSelect);

            // --- Value Picker ---
            const valueLabel = document.createElement("label");
            valueLabel.textContent = "Value";
            valueLabel.style.display = "block";
            pickerDiv.appendChild(valueLabel);

            if (
              selectedDevices.length === 1 &&
              selectedDevices[0].id === "__mode__" &&
              node.data.attribute === "mode"
            ) {
              // Multi-select dropdown for modes
              const allModes = (window.hubitatModes || []).filter(m => m.id !== "current");
              const modeSelect = document.createElement("select");
              modeSelect.multiple = true;
              modeSelect.size = Math.min(7, allModes.length);
              modeSelect.style.display = "block";
              modeSelect.style.marginBottom = "12px";

              // Always store value as array for multi-select
              if (!Array.isArray(node.data.value)) {
                if (typeof node.data.value === "string" && node.data.value) {
                  node.data.value = [node.data.value];
                } else {
                  node.data.value = [];
                }
              }

              modeSelect.innerHTML = allModes.map(mode =>
                `<option value="${mode.name}" ${node.data.value.includes(mode.name) ? "selected" : ""}>${mode.name}</option>`
              ).join('');

              // Autofill to first mode if empty
              if (node.data.value.length === 0 && allModes.length > 0) {
                node.data.value = [allModes[0].name];
                Array.from(modeSelect.options)[0].selected = true;
                editor.updateNodeDataFromId(node.id, node.data);
              }

              modeSelect.onchange = () => {
                node.data.value = Array.from(modeSelect.selectedOptions).map(opt => opt.value);
                editor.updateNodeDataFromId(node.id, node.data);
                editor.updateNodeHtmlFromId(node.id, nodeTileHtml(node.name, node.data, node.id));
              };
              pickerDiv.appendChild(modeSelect);

            } else {
              if (node.data.comparator === "between") {
                // Render two inputs, for lower and upper bounds
                let betweenValues = Array.isArray(node.data.value)
                  ? node.data.value
                  : typeof node.data.value === "string" && node.data.value.includes(",")
                    ? node.data.value.split(",")
                    : ["",""];
                if (betweenValues.length < 2) betweenValues = [betweenValues[0] || "", ""];

                // Min
                let minInput = document.createElement("input");
                minInput.type = "text";
                minInput.value = betweenValues[0];
                minInput.placeholder = "Min";
                minInput.style.width = "45%";
                minInput.style.marginRight = "7px";

                // Max
                let maxInput = document.createElement("input");
                maxInput.type = "text";
                maxInput.value = betweenValues[1];
                maxInput.placeholder = "Max";
                maxInput.style.width = "45%";

                function updateBetweenValues() {
                  node.data.value = [minInput.value, maxInput.value];
                  editor.updateNodeDataFromId(node.id, node.data);
                  editor.updateNodeHtmlFromId(node.id, nodeTileHtml(node.name, node.data, node.id));
                }

                minInput.onchange = maxInput.onchange = updateBetweenValues;
                pickerDiv.appendChild(minInput);
                pickerDiv.appendChild(maxInput);
              } else {
                // Default
                let valueField = document.createElement("input");
                valueField.type = "text";
                valueField.value = Array.isArray(node.data.value) ? node.data.value.join(",") : (node.data.value || "");
                valueField.style.display = "block";
                valueField.style.marginBottom = "12px";
                valueField.onchange = () => {
                  node.data.value = valueField.value;
                  editor.updateNodeDataFromId(node.id, node.data);
                  editor.updateNodeHtmlFromId(node.id, nodeTileHtml(node.name, node.data, node.id));
                };
                pickerDiv.appendChild(valueField);
              }
            }
          }

          // Initial build
          buildPickers();

          // Device select onchange
          devSelect.onchange = () => {
            const newSelected = Array.from(devSelect.selectedOptions).map(opt => opt.value);
            node.data.deviceIds = newSelected;
            node.data.deviceId = newSelected.length === 1 ? newSelected[0] : "";

            // Update deviceLabel for tile display
            const labels = node.data.deviceIds.map(id => {
              const dev = devices.find(d => d.id == id);
              return dev ? (dev.label || dev.name || id) : id;
              markFlowNeedsSave(true);
            });
            node.data.deviceLabel = labels.join(", ");

            // Always clear dependent fields when devices change
            node.data.attribute = "";
            node.data.comparator = "";
            node.data.value = "";

            editor.updateNodeDataFromId(node.id, node.data);
            editor.updateNodeHtmlFromId(node.id, nodeTileHtml(node.name, node.data, node.id));
            buildPickers();
          };
        }

        if (node.name === "saveDeviceState" || node.name === "restoreDeviceState") {
          el.innerHTML = `${node.name === "saveDeviceState" ? "Save Device State" : "Restore Device State"}<br><br>`;

          const devLabel = document.createElement("label");
          devLabel.textContent = "Device";
          devLabel.style.display = "block";
          el.appendChild(devLabel);

          renderDevicePicker(
            el,
            devices,
            node.data.deviceId ? [node.data.deviceId] : [],
            (newSelectedIds, newDeviceLabels) => {
              node.data.deviceId = newSelectedIds[0] || "";
              node.data.deviceLabel = newDeviceLabels[0] || "";
              editor.updateNodeDataFromId(node.id, node.data);
              editor.updateNodeHtmlFromId(node.id, nodeTileHtml(node.name, node.data, node.id));
              markFlowNeedsSave(true);
            },
            false // single-select
          );
          return;
        }

        if (node.name === "notification") {
          const el = document.getElementById("nodeEditor");
          el.innerHTML = "<b>Notification Node</b><br><br>";

          // Type selector
          const typeLabel = document.createElement("label");
          typeLabel.textContent = "Type";
          el.appendChild(typeLabel);

          const typeSelect = document.createElement("select");
          ["push", "speech"].forEach(type => {
            const opt = document.createElement("option");
            opt.value = type;
            opt.textContent = type.charAt(0).toUpperCase() + type.slice(1);
            if (node.data.notificationType === type) opt.selected = true;
            typeSelect.appendChild(opt);
          });
          typeSelect.value = node.data.notificationType || "push";
          typeSelect.onchange = () => {
            node.data.notificationType = typeSelect.value;
            editor.updateNodeDataFromId(node.id, node.data);
            editor.updateNodeHtmlFromId(node.id, nodeTileHtml(node.name, node.data, node.id));
            renderEditor(node); // rerender to update device dropdown label
          };
          el.appendChild(typeSelect);

          // --- Device dropdown (filtered by capability) ---
          const type = typeSelect.value || node.data.notificationType || "push";
          const deviceLabel = document.createElement("label");
          deviceLabel.textContent = (type === "speech") ? "Speaker Device" : "Notification Device";
          el.appendChild(deviceLabel);

          // Filter device list for Notification (push) or Speech
          let filteredDevices = [];
          if (type === "speech") {
            // Find devices with Speech capability
            filteredDevices = devices.filter(d =>
              (d.commands && d.commands.includes("speak")) ||
              (d.capabilities && d.capabilities.includes("SpeechSynthesis"))
            );
          } else {
            // Find devices with Notification capability
            filteredDevices = devices.filter(d =>
              (d.commands && d.commands.includes("deviceNotification")) ||
              (d.capabilities && d.capabilities.includes("Notification"))
            );
          }
          // fallback: if none found, show all devices as an option (prevents blank dropdown)
          if (filteredDevices.length === 0) filteredDevices = devices;
          filteredDevices.sort((a, b) => (a.label || "").localeCompare(b.label || ""));
          const devSelect = document.createElement("select");
            devSelect.multiple = true;
            devSelect.size = Math.min(8, filteredDevices.length); // Show up to 8

            // Support both array and legacy string for selected devices
            const selectedIds = Array.isArray(node.data.targetDeviceId)
              ? node.data.targetDeviceId
              : node.data.targetDeviceId
                ? [node.data.targetDeviceId]
                : [];

            filteredDevices.forEach(d => {
              const opt = document.createElement("option");
              opt.value = d.id;
              opt.textContent = d.label;
              if (selectedIds.includes(d.id)) opt.selected = true;
              devSelect.appendChild(opt);
            });

            devSelect.onchange = () => {
              // Save as array (supports multiple)
              node.data.targetDeviceId = Array.from(devSelect.selectedOptions).map(opt => opt.value);
              editor.updateNodeDataFromId(node.id, node.data);
              editor.updateNodeHtmlFromId(node.id, nodeTileHtml(node.name, node.data, node.id));
              markFlowNeedsSave(true);
            };
            el.appendChild(devSelect);

          // --- Message input ---
          const msgLabel = document.createElement("label");
          msgLabel.textContent = "Message";
          el.appendChild(msgLabel);

          const msgInput = document.createElement("input");
          msgInput.type = "text";
          msgInput.placeholder = "Enter message";
          msgInput.value = node.data.message || "";
          msgInput.style.width = "98%";
          msgInput.oninput = () => {
            node.data.message = msgInput.value;
            editor.updateNodeDataFromId(node.id, node.data);
            editor.updateNodeHtmlFromId(node.id, nodeTileHtml(node.name, node.data, node.id));
            markFlowNeedsSave(true);
          };
          el.appendChild(msgInput);

          const plusVarBtn = document.createElement("button");
          plusVarBtn.type = "button";
          plusVarBtn.textContent = "+Var";
          plusVarBtn.title = "Insert a variable into this field";
          plusVarBtn.style.marginLeft = "6px";
          plusVarBtn.style.padding = "2px 8px";
          plusVarBtn.style.fontSize = "13px";
          plusVarBtn.style.borderRadius = "7px";
          plusVarBtn.style.background = "#334bff";
          plusVarBtn.style.color = "#fff";
          plusVarBtn.onclick = function() {
            if (window.flowVars && window.flowVars.updateCtx) window.flowVars.updateCtx();
            if (!window.flowVars) return alert("FE_flowVars.js not loaded!");
            const allVars = (window.flowVars.getVars ? window.flowVars.getVars() : []);
            if (!allVars.length) return alert("No variables defined!");

            if (allVars.length === 1) {
              let insert = `$(${allVars[0].name})`;
              let start = valInput.selectionStart, end = valInput.selectionEnd;
              let oldVal = valInput.value;
              valInput.value = oldVal.slice(0, start) + insert + oldVal.slice(end);
              valInput.focus();
              valInput.selectionStart = valInput.selectionEnd = start + insert.length;
              valInput.dispatchEvent(new Event('input'));
              return;
            }
            const sel = document.createElement("select");
            sel.innerHTML = allVars.map(v => `<option value="${v.name}">${v.name}</option>`).join('');
            sel.onchange = () => {
              let insert = `$(${sel.value})`;
              let start = msgInput.selectionStart, end = msgInput.selectionEnd;
              let oldVal = msgInput.value;
              msgInput.value = oldVal.slice(0, start) + insert + oldVal.slice(end);
              msgInput.focus();
              msgInput.selectionStart = msgInput.selectionEnd = start + insert.length;
              msgInput.dispatchEvent(new Event('input'));
              document.body.removeChild(sel);
              markFlowNeedsSave(true);
            };
            sel.style.position = "absolute";
            let r = plusVarBtn.getBoundingClientRect();
            sel.style.left = r.left + "px";
            sel.style.top = (r.bottom+2) + "px";
            sel.style.zIndex = 9999;
            document.body.appendChild(sel);
            sel.focus();
          };
          el.appendChild(plusVarBtn);
    
          const previewChip = document.createElement("div");
          previewChip.className = "current-value";
          previewChip.style.marginLeft = "2px";
          previewChip.style.fontSize = "13px";
          previewChip.style.fontWeight = "bold";
          previewChip.style.cursor = "pointer";
          previewChip.title = "Preview of value/expression";
          el.appendChild(previewChip);
          function updatePreview() {
            if (window.flowVars && window.flowVars.evaluate) {
              try {
                const v = msgInput.value;
                if (!v.trim()) { previewChip.textContent = ""; previewChip.title = ""; return; }
                const result = window.flowVars.evaluate(v);
                let color = "#b7ffac";
                if (typeof result === "number") color = "#3af";
                else if (typeof result === "boolean") color = "#0c0";
                else if (typeof result === "string" && result.startsWith("ERR:")) color = "#f33";
                previewChip.textContent = "= " + result;
                previewChip.style.color = color;
                previewChip.title = (typeof result) + ": " + result;
              } catch(e) {
                previewChip.textContent = "ERR: " + e.message;
                previewChip.style.color = "#f33";
                previewChip.title = e.message;
              }
            }
          }
          msgInput.addEventListener("input", updatePreview);
          updatePreview();
          
                return;
              }
            }

      const editor = new Drawflow(document.getElementById("drawflow"));
      // Add moveNodeTo to Drawflow (polyfill for versions that lack it)
      if (!editor.moveNodeTo) {
        editor.moveNodeTo = function(nodeId, x, y) {
          // Robustly find the Home flow data
          let home = this.drawflow && this.drawflow.Home
            ? this.drawflow.Home
            : this.drawflow && this.drawflow.drawflow && this.drawflow.drawflow.Home
              ? this.drawflow.drawflow.Home
              : null;
          if (!home || !home.data) return;

          const node = home.data[nodeId];
          if (!node) return;
          node.pos_x = x;
          node.pos_y = y;

          // Move the actual HTML node in the DOM
          const htmlNode = document.getElementById("node-" + nodeId);
          if (htmlNode) {
            htmlNode.style.left = x + "px";
            htmlNode.style.top = y + "px";
          }

          // Also rerender lines
          if (typeof this.updateConnectionNodes === "function") {
            this.updateConnectionNodes(`node-${nodeId}`);
          }
        }
      }
      editor.reroute = true;
      editor.start();
      editor.on('nodeMoved', function(id) {
        markFlowNeedsSave(true);
      });
      editor.on('connectionRemoved', function(connection) {
        markFlowNeedsSave(true);
      });
      editor.on('connectionCreated', function(connection) {
        markFlowNeedsSave(true);
      });
      editor.on('nodeRemoved', function(id) {
        markFlowNeedsSave(true);
      });

      if (typeof Drawflow !== "undefined" && !Drawflow.prototype.updateNodeHtmlFromId) {
        Drawflow.prototype.updateNodeHtmlFromId = function(id, html) {
          let selector = "#node-" + id;
          if (typeof id === "string" && id.startsWith("node-")) {
           selector = "#" + id;
          }
          const nodeDiv = this.container.querySelector(selector + " .drawflow_content_node");
          if (nodeDiv) nodeDiv.innerHTML = html;
        }
      }

      editor.on("nodeSelected", function (id) {
        editor.selected_id = id;
        renderEditor(editor.getNodeFromId(id));
      });

      document.getElementById("drawflow").addEventListener("click", function(e) {
        if (!e.target.closest(".drawflow-node")) {
          document.getElementById("nodeEditor").innerHTML = "Click a node to edit";
          editor.selected_id = null;
        }
      });

      document.getElementById("addNotMatchingVar").onclick = function () {
        logAction("addNotMatchingVar button clicked.");
        editor.addNode("notMatchingVar", 1, 1, 320, 180, "notMatchingVar", {
            deviceIds: [], attribute: "", value: "", varScope: "flow"}
        ), nodeTileHtml("notMatchingVar", { deviceIds: "", attribute: "", value: "" }, )
        markFlowNeedsSave(true);
        logAction("addNotMatchingVar finished.");
      };

      // --- Save Device State ---
      document.getElementById("addSaveDeviceState").onclick = function() {
        logAction("addSaveDeviceState button clicked.");
        editor.addNode("saveDeviceState", 1, 1, 140, 40, "saveDeviceState", {
         deviceId: "", deviceLabel: "" 
        }, nodeTileHtml("saveDeviceState", { deviceId: "", deviceLabel: "" }, ));
        markFlowNeedsSave(true);
      };

      // --- Restore Device State ---
      document.getElementById("addRestoreDeviceState").onclick = function() {
        logAction("addRestoreDeviceState button clicked.");
        editor.addNode("restoreDeviceState", 1, 1, 120, 40, "restoreDeviceState", {
         deviceId: "", deviceLabel: "" 
        }, nodeTileHtml("restoreDeviceState", { deviceId: "", deviceLabel: "" }, ));
        markFlowNeedsSave(true);
      };

      document.getElementById("addDevice").onclick = () => {
        logAction("addAction button clicked.");
        editor.addNode("device", 1, 1, 100, 100, "device", {
          deviceId: "", attribute: "", command: "", value: ""
        }, nodeTileHtml("device", { deviceId: "", command: "", value: "" }, ));
        // --- PATCH: set data-node-type on new device node
        setTimeout(() => {
          const nodeEls = document.querySelectorAll('.drawflow-node');
          nodeEls.forEach(el => {
            const id = el.id.replace('node-', '');
            if (editor.getNodeFromId && editor.getNodeFromId(id)) {
              const node = editor.getNodeFromId(id);
              if (node && node.name === "device") {
                el.setAttribute('data-node-type', 'device');
              }
              if (node && node.name === "condition") {
                el.setAttribute('data-node-type', 'condition');
              }
              if (node && node.name === "eventTrigger") {
                el.setAttribute('data-node-type', 'eventTrigger');
              }
            }
          });
        }, 100);
        markFlowNeedsSave(true);
        logAction("addAction finished.");
      };

      document.getElementById("addCondition").onclick = () => {
        logAction("addCondition button clicked.");
        editor.addNode("condition", 1, 2, 200, 200, "condition", {
          deviceId: "", attribute: "", value: "", comparator: "=="
        }, nodeTileHtml("condition", { deviceId: "", attribute: "", comparator: "==", value: "" }), undefined, { outputs: ["true", "false"] });
        setTimeout(() => {
          const nodeEls = document.querySelectorAll('.drawflow-node');
          nodeEls.forEach(el => {
            const id = el.id.replace('node-', '');
            if (editor.getNodeFromId && editor.getNodeFromId(id)) {
              const node = editor.getNodeFromId(id);
              if (node && node.name === "device") {
                el.setAttribute('data-node-type', 'device');
              }
              if (node && node.name === "condition") {
                el.setAttribute('data-node-type', 'condition');
              }
              if (node && node.name === "eventTrigger") {
                el.setAttribute('data-node-type', 'eventTrigger');
              }
            }
          });
        }, 100);
        markFlowNeedsSave(true);
        logAction("addCondition finished.");
      };

      document.getElementById("addTrigger").onclick = () => {
        logAction("addTrigger button clicked.");
        editor.addNode("eventTrigger", 0, 1, 50, 50, "eventTrigger", {
          deviceId: "", attribute: "", value: "", comparator: "=="
        }, nodeTileHtml("eventTrigger", { deviceId: "", attribute: "", comparator: "==", value: "" }));
        setTimeout(() => {
          const nodeEls = document.querySelectorAll('.drawflow-node');
          nodeEls.forEach(el => {
            const id = el.id.replace('node-', '');
            if (editor.getNodeFromId && editor.getNodeFromId(id)) {
              const node = editor.getNodeFromId(id);
              if (node && node.name === "device") {
                el.setAttribute('data-node-type', 'device');
              }
              if (node && node.name === "condition") {
                el.setAttribute('data-node-type', 'condition');
              }
              if (node && node.name === "eventTrigger") {
                el.setAttribute('data-node-type', 'eventTrigger');
              }
            }
          });
        }, 100);
        markFlowNeedsSave(true);
        logAction("addTrigger finished.");
      };

      document.getElementById("addSetVariable").onclick = () => {
        logAction("addSetVariable button clicked.");
        editor.addNode("setVariable", 1, 1, 250, 120, "setVariable", {
          varName: "", varValue: ""
        }, nodeTileHtml("setVariable", { varName: "", varValue: "" }));
        logAction("addSetVariable finished.");
      };

      document.getElementById("addNotification").onclick = () => {
        logAction("addNotification button clicked.");
        editor.addNode("notification", 1, 1, 160, 120, "notification", {
          notificationType: "push", // default
          targetDeviceId: "",
          message: ""
        }, nodeTileHtml("notification", { notificationType: "push", message: "" }));
        markFlowNeedsSave(true);
        logAction("addNotification finished.");
      };

      document.getElementById("addLogicAND").onclick = () => {
        markFlowNeedsSave(true);
        editor.addNode("AND", 2, 2, 300, 100, "AND", {}, nodeTileHtml("AND", {}), undefined, { outputs: ["true", "false"] });
      };
      document.getElementById("addLogicOR").onclick = () => {
        markFlowNeedsSave(true);
        editor.addNode("OR", 2, 2, 350, 100, "OR", {}, nodeTileHtml("OR", {}), undefined, { outputs: ["true", "false"] });
      };
      document.getElementById("addLogicNOT").onclick = () => {
        markFlowNeedsSave(true);
        editor.addNode("NOT", 1, 2, 400, 100, "NOT", {}, nodeTileHtml("NOT", {}), undefined, { outputs: ["true", "false"] });
      };

      document.getElementById("addDoNothing").onclick = () => {
        markFlowNeedsSave(true);
        editor.addNode(
          "doNothing", 
          1, 1, 600, 100, 
          "doNothing", 
          {}, 
          '<div class="logic-node">Do Nothing</div>'
        );
      };

      document.getElementById("addDelay").onclick = () => {
        editor.addNode("delay", 1, 1, 500, 100, "delay", {
          delayMs: 1000
        }, nodeTileHtml("delay", { delayMs: 1000 }));
        markFlowNeedsSave(true);
      };
      document.getElementById("addDelayMin").onclick = () => {
        editor.addNode("delayMin", 1, 1, 550, 100, "delayMin", {
          delayMin: 1
        }, nodeTileHtml("delayMin", { delayMin: 1 }));
        markFlowNeedsSave(true);
      };

      document.getElementById("newFlow").onclick  = async function() {
        if (confirm("Clear all nodes and start a new flow? This cannot be undone.")) {
          editor.clear();
          document.getElementById("flowName").value = "";
          document.getElementById("nodeEditor").innerHTML = "Click a node to edit";
          logAction("Started a new flow (all nodes cleared).");
        }
        await autoLoadGlobalVarsFromHubitat();
      };

      async function fetchHubitatFiles() {
        const appId = document.getElementById("hubitatAppId").value.trim();
        const token = document.getElementById("hubitatToken").value.trim();
        if (!appId || !token) {
          logAction("Enter App ID and Access Token!", "error");
          return [];
        }
        try {
          const listFileUrl = `/apps/api/${appId}/listFiles?access_token=${token}`;
          const res = await fetch(listFileUrl);
          if (!res.ok) throw new Error("HTTP " + res.status);
          const data = await res.json();
          return data.files || [];
        } catch (e) {
          logAction("Failed to fetch file list: " + e.message, "error");
          return [];
        }
      }

      async function fetchHubitatFileContent(fileName) {
        const appId = document.getElementById("hubitatAppId").value.trim();
        const token = document.getElementById("hubitatToken").value.trim();
        if (!appId || !token) {
          logAction("Enter App ID and Access Token!", "error");
          throw new Error("Missing credentials");
        }
        const fileUrl = `/apps/api/${appId}/getFile?name=${encodeURIComponent(fileName)}&access_token=${token}`;
        try {
          const response = await fetch(fileUrl);
          const raw = await response.text();
          if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${raw}`);
          }
          try {
            return JSON.parse(raw);
          } catch (err) {
            throw new Error("File is not valid JSON: " + raw);
          }
        } catch (e) {
          logAction("Failed to fetch file content: " + e.message, "error");
          throw e;
        }
      }

      // ---- REFRESH ALL TILES BUTTON ----
      document.getElementById("refreshAllTiles").onclick = async function() {
        logAction("Refreshing devices from Hubitat...");
        // Fetch devices from Hubitat
        const devices = await fetchDevicesFromApp();
        devices.forEach(dev => {
          if (Array.isArray(dev.attributes)) {
            const attrMap = {};
            dev.attributes.forEach(a => {
              if (a.name !== undefined) attrMap[a.name] = a.currentValue;
            });
            dev.attributes = attrMap;
          }
        });
        // Update global window.devices and add TIME/MODE specials
        devices.push(TIME_DEVICE);
        devices.push(MODE_DEVICE);
        window.devices = devices;

        // Set current mode on Home Location device
        const currentModeObj = (window.hubitatModes || []).find(m => m.id === "current");
        const currentMode = currentModeObj ? currentModeObj.name : "";
        const modeDev = window.devices.find(d => d.id === "__mode__");
        if (modeDev) {
          modeDev.attributes.mode = currentMode;
        }

        const data = editor.drawflow.drawflow.Home?.data;
        console.log("Drawflow nodes data:", data);

        if (!data || Object.keys(data).length === 0) {
          logAction("No flow loaded. Nothing to refresh.", "error");
          return;
        }

        Object.values(data).forEach(node => {
          if (["device", "condition", "eventTrigger"].includes(node.name) && node.data && node.data.deviceId) {
            let dev = devices.find(d => d.id == node.data.deviceId);
            node.data.deviceLabel = dev ? (dev.label || dev.name || node.data.deviceId) : node.data.deviceId;
          }
          if (editor && typeof editor.updateNodeHtmlFromId === "function") {
            editor.updateNodeHtmlFromId(node.id, nodeTileHtml(node.name, node.data, node.id));
          }
        });
        logAction("All node tiles refreshed.");
        setTimeout(() => {
          const nodeEls = document.querySelectorAll('.drawflow-node');
          nodeEls.forEach(el => {
            const id = el.id.replace('node-', '');
            if (editor.getNodeFromId && editor.getNodeFromId(id)) {
              const node = editor.getNodeFromId(id);
              if (node && node.name === "device") {
                el.setAttribute('data-node-type', 'device');
              }
              if (node && node.name === "condition") {
                el.setAttribute('data-node-type', 'condition');
              }
              if (node && node.name === "eventTrigger") {
                el.setAttribute('data-node-type', 'eventTrigger');
              }
            }
          });
        }, 200);

        // Nudge all nodes right by 1px
        Object.values(data).forEach(node => {
          editor.moveNodeTo(node.id, node.pos_x + 1, node.pos_y);
        });

        // Nudge all nodes back after a short delay
        setTimeout(() => {
          Object.values(data).forEach(node => {
            editor.moveNodeTo(node.id, node.pos_x - 1, node.pos_y);
          });
          logAction("All connection lines redrawn.");
        }, 30);
      };

      document.getElementById("loadFlowFromHubitatDropdown").onclick = async function() {
        // Prompt if unsaved changes
        const saveBtn = document.getElementById('sendFlow');
        if (saveBtn && saveBtn.classList.contains('need-save')) {
          const proceed = confirm("You have unsaved changes to your Flow. Continue and lose changes?");
          if (!proceed) {
            return; // User cancelled
          }
        }

        if (!hubitatCredentialsAreValid(true)) return;
        const button = document.getElementById("loadFlowFromHubitatDropdown");
        const dropdown = document.getElementById("hubitatFileDropdown");

        button.style.display = "none";
        dropdown.style.display = "inline-block";
        dropdown.innerHTML = "<option>Loading...</option>";

        let files = [];
        try {
          files = await fetchHubitatFiles();
        } catch (err) {
          dropdown.innerHTML = "<option>Failed to load files</option>";
          logAction("Error loading file list: " + (err.message || err), "error");
          setTimeout(() => {
            dropdown.style.display = "none";
            button.style.display = "inline-block";
          }, 1500);
          return;
        }

        dropdown.innerHTML = "";
        if (!files || !files.length) {
          dropdown.innerHTML = "<option>No .json files found</option>";
          setTimeout(() => {
            dropdown.style.display = "none";
            button.style.display = "inline-block";
          }, 1500);
          return;
        }
        dropdown.innerHTML = "<option value=''>Pick a flow file…</option>";
        files.forEach(f => {
          const opt = document.createElement("option");
          opt.value = f;
          opt.textContent = f;
          dropdown.appendChild(opt);
        });

        dropdown.onchange = async function() {
          const fileName = dropdown.value;
          if (!fileName) return;
          // Prompt again for unsaved changes
          const saveBtn = document.getElementById('sendFlow');
          if (saveBtn && saveBtn.classList.contains('need-save')) {
            const proceed = confirm("You have unsaved changes to your Flow. Continue and lose changes?");
            if (!proceed) {
              dropdown.value = "";
              return;
            }
          }
          logAction("Loading from Hubitat File Manager: " + fileName + " ...");
          try {
            const data = await fetchHubitatFileContent(fileName);
            editor.import(data);
            if (data.flowName) document.getElementById("flowName").value = data.flowName;
            document.getElementById("refreshAllTiles").click();
            logAction("Loaded flow from Hubitat File Manager: " + fileName);

            setTimeout(() => {
              const nodeEls = document.querySelectorAll('.drawflow-node');
              nodeEls.forEach(el => {
                const id = el.id.replace('node-', '');
                if (editor.getNodeFromId && editor.getNodeFromId(id)) {
                  const node = editor.getNodeFromId(id);
                  if (node && node.name === "device") el.setAttribute('data-node-type', 'device');
                  if (node && node.name === "condition") el.setAttribute('data-node-type', 'condition');
                  if (node && node.name === "eventTrigger") el.setAttribute('data-node-type', 'eventTrigger');
                }
              });
            }, 200);
          } catch (e) {
            logAction("Error loading from Hubitat File Manager: " + (e.message || e), "error");
          }
          dropdown.style.display = "none";
          button.style.display = "inline-block";
          dropdown.value = "";
        };
      };

      async function fetchDevicesFromApp() {
        const appId = document.getElementById("hubitatAppId").value.trim();
        const token = document.getElementById("hubitatToken").value.trim();
        if (!appId || !token) {
          logAction("Enter App ID and Access Token!", "error");
          return [];
        }
        try {
          const url = `/apps/api/${appId}/devices?access_token=${token}`;
          const res = await fetch(url);
          if (!res.ok) throw new Error("HTTP " + res.status);
          const data = await res.json();
          return data;
        } catch (e) {
          logAction("Failed to fetch devices: " + e.message, "error");
          return [];
        }
      }

      var loadBtn = document.getElementById("loadDevices");
        if (loadBtn) {
          loadBtn.onclick = async () => {
            logAction("loadDevices button clicked.");
            await fetchModesFromAppFile();
            devices = await fetchDevicesFromApp();
            devices.forEach(dev => {
              if (Array.isArray(dev.attributes)) {
                const attrMap = {};
                dev.attributes.forEach(a => {
                  if (a.name !== undefined) attrMap[a.name] = a.currentValue;
                });
                dev.attributes = attrMap;
              }
            });
            devices.push(TIME_DEVICE);
            devices.push(MODE_DEVICE);
            window.devices = devices;

            // Set current mode on Home Location device
            const currentModeObj = (window.hubitatModes || []).find(m => m.id === "current");
            const currentMode = currentModeObj ? currentModeObj.name : "";
            const modeDev = window.devices.find(d => d.id === "__mode__");
            if (modeDev) {
              modeDev.attributes.mode = currentMode;
            }

            // (add specials)          
            if (editor && editor.drawflow && editor.drawflow.Home && editor.drawflow.Home.data) {
              Object.values(editor.drawflow.Home.data).forEach(updateTileHtml);
              if (editor.selected_id) {
                renderEditor(editor.getNodeFromId(editor.selected_id));
              }
            }
            logAction("Devices loaded: " + devices.length);
          };
        }

      document.getElementById("sendFlow").onclick = async () => {
        if (!hubitatCredentialsAreValid(true)) return;
        if (!editor) return;
        const flowName = document.getElementById("flowName").value.trim();
        if (!flowName) {
          alert("Please enter a flow name.");
          return;
        }
        const data = editor.export();

        // PATCH: Save local variables inside the flow JSON
        if (window.flowVars && window.flowVars.getLocalVars) {
          data.variables = window.flowVars.getLocalVars();
        }

        // PATCH: Include the flowName at the top level
        const out = {
          flowName: flowName,
          ...data
        };

        await uploadToHubitatFile(flowName + ".json", JSON.stringify(out, null, 2));
        markFlowNeedsSave(false);
        logAction(`Sent flow "${flowName}" to Hubitat File Manager.`, "success");
      };

      // --- Auto device and tile refresh every 5 seconds ---
      setInterval(async () => {
        // Only run if credentials are filled and devices are loaded
        const appIdEl = document.getElementById("hubitatAppId");
        const tokenEl = document.getElementById("hubitatToken");
        if (!(appIdEl && appIdEl.value && tokenEl && tokenEl.value)) return;

        // Fetch latest devices from Hubitat (same as refreshAllTiles logic)
        const devices = await fetchDevicesFromApp();
        devices.forEach(dev => {
          if (Array.isArray(dev.attributes)) {
            const attrMap = {};
            dev.attributes.forEach(a => {
              if (a.name !== undefined) attrMap[a.name] = a.currentValue;
            });
            dev.attributes = attrMap;
          }
        });
        devices.push(TIME_DEVICE);
        devices.push(MODE_DEVICE);
        window.devices = devices;

        // Set current mode on Home Location device
        const currentModeObj = (window.hubitatModes || []).find(m => m.id === "current");
        const currentMode = currentModeObj ? currentModeObj.name : "";
        const modeDev = window.devices.find(d => d.id === "__mode__");
        if (modeDev) {
          modeDev.attributes.mode = currentMode;
        }

        // Update all node tiles
        const data = editor.drawflow.drawflow.Home?.data;
        if (data && Object.keys(data).length > 0) {
          Object.values(data).forEach(node => {
            if (["device", "condition", "eventTrigger"].includes(node.name) && node.data && node.data.deviceId) {
              let dev = devices.find(d => d.id == node.data.deviceId);
              node.data.deviceLabel = dev ? (dev.label || dev.name || node.data.deviceId) : node.data.deviceId;
            }
            if (editor && typeof editor.updateNodeHtmlFromId === "function") {
              editor.updateNodeHtmlFromId(node.id, nodeTileHtml(node.name, node.data, node.id));
            }
          });
          // Redraw node lines (optional nudge)
          Object.values(data).forEach(node => {
            editor.moveNodeTo(node.id, node.pos_x + 1, node.pos_y);
          });
          setTimeout(() => {
            Object.values(data).forEach(node => {
              editor.moveNodeTo(node.id, node.pos_x - 1, node.pos_y);
            });
          }, 30);
          //logAction("Tiles auto-refreshed.");
        }
      }, 5000); // every 5 seconds

    });

    document.addEventListener("DOMContentLoaded", function() {
      if (window.flowVars && window.flowVars.renderManager) {
        flowVars.renderManager(document.getElementById('variableManager'), { globalVars: false });
      }
    });

    async function uploadToHubitatFile(filename, contents, opts = {}) {
      const appId = document.getElementById("hubitatAppId")?.value.trim();
      const token = document.getElementById("hubitatToken")?.value.trim();
      if (!appId || !token) { alert("Missing Hubitat appId/token"); throw new Error("Missing Hubitat appId/token"); }
      const url = `/apps/api/${appId}/uploadFile?access_token=${token}&name=${encodeURIComponent(filename)}`;
      let body = contents;
      if (typeof contents !== "string") body = JSON.stringify(contents, null, 2);

      const res = await fetch(url, {
          method: "POST",
          body: body,
          headers: { "Content-Type": opts.mimeType || "application/json" }
      });
      if (!res.ok) {
          alert("Failed to upload file to Hubitat: " + (await res.text()));
          throw new Error("Failed to upload file");
      }
      return await res.json().catch(() => true); // works for both JSON and blank responses
    }

    async function fetchModesFromAppFile() {
      if (typeof fetchHubitatVarFileContent !== "function") return [];
      try {
        const txt = await fetchHubitatVarFileContent("FE_flowModes.json");
        if (!txt) { window.hubitatModes = []; return []; }
        const obj = JSON.parse(txt);
        window.hubitatModes = obj.modes || [];
        logAction("Loaded modes: " + window.hubitatModes.map(m => m.name).join(", "));
        return window.hubitatModes;
      } catch (e) {
        logAction("Failed to load FE_flowModes.json: " + e, "error");
        window.hubitatModes = [];
        return [];
      }
    }

   // --- ONLY highlight the last-executed flow's path ---

    // === Helper: Get and save Hubitat IP ===
    function getHubitatIP() {
      let ip = localStorage.getItem("hubitat_ip");
      if (!ip && window.location.hostname.match(/^\d+\.\d+\.\d+\.\d+$/)) ip = window.location.hostname;
      if (!ip) ip = prompt("Enter Hubitat IP address:", "192.168.1.XX") || "";
      if (ip) localStorage.setItem("hubitat_ip", ip);
      return ip;
    }

    // === Highlight only the most recent flow execution (nodes and lines, all lines to last node) ===
    function highlightOnlyLatestRun(activeFlows) {
      // Remove ALL previous highlights
      document.querySelectorAll('.drawflow-node.executed').forEach(n => {
        n.classList.remove('executed');
        n.classList.remove('last-executed');
      });
      document.querySelectorAll('.main-path').forEach(path => {
        path.removeAttribute("stroke");
        path.removeAttribute("style");
        path.classList.remove('highlighted');
      });

      if (!Array.isArray(activeFlows) || activeFlows.length === 0) return;

      // Find the latest run (highest timestamp in its last step)
      let latestFlow = null, latestTs = 0;
      activeFlows.forEach(flow => {
        if (
          flow.steps && flow.steps.length > 0 &&
          flow.steps.every(step => step.nodeId && step.timestamp)
        ) {
          const lastStep = flow.steps[flow.steps.length - 1];
          if (typeof lastStep.timestamp === "number" && lastStep.timestamp > latestTs) {
            latestTs = lastStep.timestamp;
            latestFlow = flow;
          }
        }
      });
      if (!latestFlow) return;

      // Highlight ONLY the nodes for that run
      const steps = latestFlow.steps;
      steps.forEach((step, idx) => {
        const nodeEl = document.getElementById(`node-${step.nodeId}`);
        if (nodeEl) {
          nodeEl.classList.add('executed');
          nodeEl.classList.remove('last-executed');
          if (idx === steps.length - 1) nodeEl.classList.add('last-executed');
        }
      });

      // Highlight the path/lines between nodes in order
      for (let i = 0; i < steps.length - 1; i++) {
        const fromId = steps[i].nodeId;
        const toId = steps[i + 1].nodeId;
        // Try both Drawflow default and data-* selectors for max compatibility
        let path = document.querySelector(`.connection.node_out_node-${fromId}.node_in_node-${toId} .main-path`);
        if (!path) path = document.querySelector(`.connection[data-from="${fromId}"][data-to="${toId}"] .main-path`);
        if (path) {
          path.setAttribute("stroke", "limegreen");
          path.setAttribute("style", "stroke: limegreen !important; stroke-width: 4px !important; filter: drop-shadow(0 0 6px #0f0) !important;");
          path.classList.add("highlighted");
        }
      }
      // Highlight **ALL incoming lines** to the last node
      if (steps.length > 0) {
        const lastNodeId = steps[steps.length - 1].nodeId;
        // Both Drawflow and data-* selectors
        document.querySelectorAll(`.connection.node_in_node-${lastNodeId} .main-path, .connection[data-to="${lastNodeId}"] .main-path`).forEach(path => {
          path.setAttribute("stroke", "limegreen");
          path.setAttribute("style", "stroke: limegreen !important; stroke-width: 4px !important; filter: drop-shadow(0 0 6px #0f0) !important;");
          path.classList.add("highlighted");
        });
      }
    }

    // === Poll the FE_flowtrace file and highlight the latest run ===
    function pollFlowTrace() {
      const HUBITAT_IP = getHubitatIP();
      const url = `http://${HUBITAT_IP}/local/FE_flowtrace.json?nocache=${Date.now()}`;
      fetch(url)
        .then(r => {
          if (!r.ok) throw new Error("Not found");
          return r.json();
        })
        .then(activeFlows => {
          highlightOnlyLatestRun(activeFlows);
        })
        .catch(e => {
          // Ignore errors (404 normal until first flow)
        });
    }

    // === Start polling every 350ms ===
    setInterval(pollFlowTrace, 350);

      function markExportNeeded(needed = true) {
        const btn = document.getElementById('exportVarsBtn');
        if (!btn) return;
        if (needed) {
          btn.classList.add('need-export');
        } else {
          btn.classList.remove('need-export');
        }
      }

      window.addEventListener("beforeunload", function (e) {
        const saveBtn = document.getElementById('sendFlow');
        if (saveBtn && saveBtn.classList.contains('need-save')) {
          // Chrome requires returnValue to be set.
          e.preventDefault();
          e.returnValue = "You have unsaved changes to your Flow. Are you sure you want to leave?";
          // Most browsers will show a generic message, but this ensures a dialog is triggered.
          return e.returnValue;
        }
      });

    </script>
</body>
</html>
