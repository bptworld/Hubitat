<!DOCTYPE html>
<html>
<head>
  <link rel="icon" href="favicon.ico">
  <meta charset="UTF-8">
  <title>Flow Engine Editor</title>
  <!-- ‚îÄ‚îÄ BLOCKING Hubitat Credentials Prompt & Validation ‚îÄ‚îÄ -->
  <script>

// === SAFE HELPERS (idempotent) ===
if (typeof getHomeFrom !== 'function') {
  function getHomeFrom(o) {
    try {
      if (!o || typeof o !== "object") return { data: {} };
      const df = o.drawflow || o;
      if (!df) return { data: {} };
      if (df.Home && typeof df.Home === "object") return df.Home;
      if (df.drawflow && df.drawflow.Home && typeof df.drawflow.Home === "object") return df.drawflow.Home;
    } catch (_){}
    return { data: {} };
  }
}
if (typeof getHomeDataFrom !== 'function') {
  function getHomeDataFrom(o) {
    const h = getHomeFrom(o);
    return (h && h.data && typeof h.data === "object") ? h.data : {};
  }
}
if (typeof hasHomeData !== 'function') {
  function hasHomeData(o) {
    const h = getHomeFrom(o);
    return !!(h && h.data && typeof h.data === "object");
  }
}


    /* legacy popup removed */
document.addEventListener('click', function(e){
  const resetBtn = e.target && e.target.closest ? e.target.closest('#fe-cron-reset') : null;
  if (!resetBtn) return;
  try{ e.preventDefault(); e.stopImmediatePropagation(); e.stopPropagation(); }catch(_){}
  // reset all inputs inside popup
  const modal = document.getElementById('fe-cron-modal');
  if (modal) {
    modal.querySelectorAll('select, input').forEach(function(el){
      if (el.tagName === 'SELECT') {
        el.selectedIndex = 0;
      } else if (el.type === 'checkbox' || el.type === 'radio') {
        el.checked = false;
      } else {
        el.value = '';
      }
    });
  }
  // Clear preview too
  const prev = document.getElementById('fe-cron-preview');
  if (prev) prev.innerHTML = '';
});
</script>


  <link rel="stylesheet" href="FE_drawflow-css.min.css">
  <link rel="stylesheet" href="FE_drawflow-extra.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@simonwep/pickr/dist/themes/nano.min.css"/>
  <script src="https://cdn.jsdelivr.net/npm/@simonwep/pickr"></script>
  <script src="FE_flowvars.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/suncalc@1.9.0/suncalc.js"></script>
<style>
/* Keep scheduler popup within viewport */
#fe-cron-overlay{ position:fixed; inset:0; background:#0009; z-index:10000; display:none; }
#fe-cron-modal{ position:absolute; left:50%; top:50%; transform:translate(-50%,-50%);
  max-width: min(900px, 92vw); width: min(900px, 92vw);
  max-height: 88vh; overflow:auto; border-radius:14px; }
@media (max-width: 720px){
  #fe-cron-modal{ max-width: 96vw; width: 96vw; max-height: 86vh; }
}
</style>
<style>
body { background: #191919; color: #e6e6e6; }
html { margin:0; padding:0; height:100%; font-family:sans-serif; }
#headline { padding: 5px; background: #222; }
#controls { padding: 5px; background: #222; }
#nodeControls { padding: 5px; background: #222; }
</style>
<style>
/* Preview limited to 3 lines with scrollbar */
#fe-cron-preview{
  display:block;
  line-height:1.3;
  max-height: calc(1.3em * 3 + 8px);
  overflow-y:auto;
  overflow-x:hidden;
  white-space:normal;   /* so <br> works */
  font-family: ui-monospace, Consolas, monospace;
}
</style>

<style>
  #sendFlow { background:#4CAF50; color:#fff; }
  #sendFlow.need-save { background:#d9534f !important; color:#fff !important; }
</style>

<style id="feHamburgerDirtyCSS">
/* Hamburger color states */
#feHamburger.fe-clean {
  background: #204a24 !important;
  color: #c9ffd1 !important;
  border-color: #2e7d32 !important;
  box-shadow: 0 0 0 1px #2e7d3255, 0 2px 8px #0006 !important;
}
#feHamburger.fe-dirty {
  background: #4a1f1f !important;
  color: #ffd0d0 !important;
  border-color: #c62828 !important;
  box-shadow: 0 0 0 1px #c6282855, 0 2px 8px #0006 !important;
}
</style>
<style id="feHoverFixCSS">
/* Force hover highlight over inline background/color */
.fe-menu-item { transition: background .12s ease, color .12s ease; }
#feMenu .fe-menu-item:hover,
#feMenuDisplay .fe-menu-item:hover,
#feMenuAlign .fe-menu-item:hover,
#feMenuMainNodes .fe-menu-item:hover,
#feMenuOtherNodes .fe-menu-item:hover,
#feMenuSpecialNodes .fe-menu-item:hover {
  background: #3a6ea5 !important;
  color: #ffffff !important;
}
#feMenu .fe-menu-item:active,
#feMenuDisplay .fe-menu-item:active,
#feMenuAlign .fe-menu-item:active,
#feMenuMainNodes .fe-menu-item:active,
#feMenuOtherNodes .fe-menu-item:active,
#feMenuSpecialNodes .fe-menu-item:active {
  background: #2a517a !important;
  color: #ffffff !important;
}
/* Optional: keyboard focus */
.fe-menu-item:focus-visible {
  outline: none;
  background: #3a6ea5 !important;
  color: #ffffff !important;
}
</style>
<style id="feMenuNoScrollCSS">
/* Never show scrollbars on the dropdown menu */
#feMenu{ max-height:none !important; overflow:visible !important; }
/* Make submenus appear when .fe-open is present (JS will toggle this) */
#feMenu .fe-open{ display:block !important; }
</style>

<style id="feMenuOverlayFix">
/* Disable DnD overlay while menu is open */
body:has(#feHamburger[aria-expanded="true"]) #__feDndOverlay {
  pointer-events: none !important;
}
</style>

<script id="feUltimateBannerAndSizer">
(function(){
  function setHeadH(){
    try{
      var h = (document.getElementById('headline')?.offsetHeight) || 0;
      document.documentElement.style.setProperty('--fe-head-h', h + 'px');
    }catch(_){}
  }
  function moveWarnIntoHeader(){
    var head = document.getElementById('headline') || document.body;
    var warn = document.getElementById('hubitatWarnBanner');
    if (warn && warn.parentElement !== head){
      head.insertBefore(warn, head.firstChild);
    }
    setHeadH();
  }
  // Wrap any existing showHubitatWarning to ensure banner ends up in the header
  var origShow = window.showHubitatWarning;
  window.showHubitatWarning = function(show){
    try { if (typeof origShow === 'function') origShow.apply(this, arguments); } catch(_){}
    var warn = document.getElementById('hubitatWarnBanner');
    if (!warn){
      warn = document.createElement('div');
      warn.id = 'hubitatWarnBanner';
      warn.style.cssText = 'background:#ffc107;color:#111;padding:9px 22px;font-weight:bold;text-align:center;font-size:16px;border-bottom:2px solid #b8860b;';
      warn.textContent = '‚ö†Ô∏è Please enter both Hubitat App ID and Token to use Flow Engine Editor features.';
      (document.getElementById('headline')||document.body).insertBefore(warn, (document.getElementById('headline')||document.body).firstChild);
    }
    warn.style.display = show ? 'block' : 'none';
    moveWarnIntoHeader();
  };
  // Keep things in place even if other scripts tweak the DOM later
  new MutationObserver(moveWarnIntoHeader).observe(document.documentElement, {childList:true, subtree:true});
  window.addEventListener('load', function(){ setHeadH(); moveWarnIntoHeader(); setTimeout(moveWarnIntoHeader,50); setTimeout(moveWarnIntoHeader,250); });
  window.addEventListener('resize', setHeadH);
})();
</script>

<style id="feLayout_OneTrueBlock">
  html,body{height:100%;margin:0;padding:0}
  body{display:grid;grid-template-rows:auto 1fr;overflow:hidden}

  /* Two columns under header */
  #main{
    display:grid;grid-template-columns:min(420px,34vw) 1fr;
    min-height:0;height:auto; /* no calc(), no fixed heights */
  }

  /* Left column scrolls; page never does */
  #editor{height:100%;min-height:0;overflow:auto}

  /* Right canvas fills; transparent so the image can show */
  #drawflow{
    position:relative;height:100%;min-height:0;
    margin:0 !important;padding:0 !important;overflow:hidden !important;
    background:transparent !important; background-image: var(--fe-bg-image, none) !important; background-repeat: repeat !important; background-size: auto !important; background-position: top left !important;
  }

  /* Make the canvas truly fill regardless of library internals */
  #drawflow, #drawflow .drawflow, #drawflow .precanvas{
    height:100% !important;min-height:100% !important;
    margin:0 !important;padding:0 !important;border:0 !important;box-sizing:border-box !important;
  }

  /* Background image behind nodes (controlled by CSS vars) */
  #drawflow .precanvas{position:relative}
  #drawflow .precanvas::before, #drawflow::before{
    content:"";position:absolute;inset:0;pointer-events:none;z-index:0;
    background-image:var(--fe-bg-image, none);
    background-repeat:repeat;
    filter:brightness(var(--fe-bg-brightness,1));
  }
</style>

<style id="feSidebarNarrow">
  :root{ --fe-sidebar: 310px; } /* adjust this if you want thinner/wider */
  #main{ grid-template-columns: var(--fe-sidebar) 1fr !important; }
  #editor{
    min-width: var(--fe-sidebar) !important;
    max-width: var(--fe-sidebar) !important;
  }
</style>

<style id="feSidebarCollapseCSS">
  body.fe-sidebar-collapsed #main { grid-template-columns: 0 1fr !important; }
  body.fe-sidebar-collapsed #editor{
    min-width: 0 !important;
    max-width: 0 !important;
    width: 0 !important;
    padding: 0 !important;
    border: 0 !important;
    overflow: hidden !important;
  }
</style>

<script id="feSidebarCollapseJS">
(function(){
  const btn = document.getElementById('feCollapseInline');
  if (!btn) return;

  function setCollapsed(on){
    document.body.classList.toggle('fe-sidebar-collapsed', !!on);
    try { localStorage.setItem('fe_sidebar_collapsed', on ? '1' : '0'); } catch(_){}

    // üîÑ Update the arrow icon
    btn.textContent = on ? '‚ñ∂' : '‚óÄ';
    btn.setAttribute('aria-label', on ? 'Expand sidebar' : 'Collapse sidebar');
    btn.title = on ? 'Expand sidebar' : 'Collapse sidebar';
  }

  btn.addEventListener('click', () => {
    const collapsed = document.body.classList.contains('fe-sidebar-collapsed');
    setCollapsed(!collapsed);
    try { window.dispatchEvent(new Event('resize')); } catch(_){}
    try { if (typeof window.refreshConnectionsSoon === 'function') window.refreshConnectionsSoon(); } catch(_){}
  });

  // restore saved state
  const saved = localStorage.getItem('fe_sidebar_collapsed') === '1';
  setCollapsed(saved);
})();
</script>

<script id="feAutoPanToContent">
(function(){
  function autoPan(margin){
    margin = Number(margin || 60);
    try{
      var ed = window.editor;
      var canvas = ed && ed.precanvas;
      if(!canvas) return;
      var nodes = canvas.querySelectorAll('.drawflow-node');
      if(!nodes || !nodes.length) return;

      var minX = Infinity, minY = Infinity;
      nodes.forEach(function(n){
        var x = parseFloat(n.style.left) || 0;
        var y = parseFloat(n.style.top) || 0;
        if (x < minX) minX = x;
        if (y < minY) minY = y;
      });

      var tx = margin - minX;
      var ty = margin - minY;
      if (isFinite(tx) && isFinite(ty)){
        ed.canvas_x = tx;
        ed.canvas_y = ty;
        var z = (typeof ed.zoom === 'number') ? ed.zoom : 1;
        ed.precanvas.style.transform = 'translate(' + tx + 'px, ' + ty + 'px) scale(' + z + ')';
        try { if (typeof ed.updateConnectionNodesAll === 'function') ed.updateConnectionNodesAll(); } catch(_){}
      }
    }catch(_){}
  }

  function whenNodesReady(){
    var canvas = document.querySelector('#drawflow .precanvas');
    if(!canvas) return;
    var obs = new MutationObserver(function(){
      if (canvas.querySelector('.drawflow-node')) {
        setTimeout(function(){ autoPan(60); }, 40);
        obs.disconnect();
      }
    });
    obs.observe(canvas, {childList:true, subtree:true});
  }

  if (document.readyState === 'complete' || document.readyState === 'interactive'){
    whenNodesReady();
  } else {
    document.addEventListener('DOMContentLoaded', whenNodesReady, {once:true});
  }

  // expose in case you want to call it manually from console
  window.feAutoPanToContent = autoPan;
})();
</script>







<style id="feMenuFitCSS">
  /* Prevent internal scrollbars; we will fit the panels instead */
  #feMenu, #feMenuDisplay, #feMenuAlign, #feMenuMainNodes, #feMenuOtherNodes, #feMenuSpecialNodes{
    max-height: none !important;
    overflow: visible !important;
  }
</style>

<script id="feMenuFitToViewport">
(function(){
  const GAP = 10; // padding from top/bottom of viewport

  // parent button id -> submenu id  (root menu NOT included)
  const pairs = [
    ['feMenu-display',     'feMenuDisplay'],
    ['feMenu-align',       'feMenuAlign'],
    ['feMenu-mainnodes',   'feMenuMainNodes'],
    ['feMenu-othernodes',  'feMenuOtherNodes'],
    ['feMenu-specialnodes','feMenuSpecialNodes'],
  ];

  // Read a pixel value safely (handles 'auto')
  function px(el, prop, fallback=0){
    const v = getComputedStyle(el)[prop];
    const n = parseFloat(v);
    return Number.isFinite(n) ? n : fallback;
  }

  // Clamp submenu by nudging its absolute 'top' so it fits the viewport.
  // 1) start from the submenu's base top (inline/top from CSS, usually 2px)
  // 2) if it would overflow the bottom, move it up
  // 3) if that pushes it off the top, move it back down
  function clampSubmenu(panel){
    if (!panel || getComputedStyle(panel).display === 'none') return;

    // Cache the original 'top' once, so every open starts from the same anchor
    if (!panel.dataset.baseTopPx){
      const base = px(panel, 'top', 0);
      panel.dataset.baseTopPx = String(base);
    }
    const baseTop = parseFloat(panel.dataset.baseTopPx) || 0;

    // Reset to base before measuring
    panel.style.top = baseTop + 'px';

    const vh   = window.innerHeight;
    const rect = panel.getBoundingClientRect();

    let dy = 0;
    // Pull up if overflowing the bottom
    if (rect.bottom + GAP > vh){
      dy -= (rect.bottom + GAP - vh);
    }
    // Push down if now above the top
    if (rect.top + dy < GAP){
      dy += (GAP - (rect.top + dy));
    }

    // Apply the adjustment in the submenu's own coordinate system
    const newTop = Math.round(baseTop + dy);
    panel.style.top = newTop + 'px';
  }

  function hook(btnId, panelId){
    const btn   = document.getElementById(btnId);
    const panel = document.getElementById(panelId);
    if (!btn || !panel || btn.__feClampHooked) return;
    btn.__feClampHooked = true;

    // Clamp right after YOUR code has opened the submenu
    const run = () => setTimeout(() => clampSubmenu(panel), 0);

    // Works for hover- and click-opened menus
    btn.addEventListener('mouseenter', run, {capture:false});
    btn.addEventListener('click', run, {capture:false});

    // If the submenu becomes visible when you hover into it, clamp again
    panel.addEventListener('mouseenter', () => clampSubmenu(panel), {capture:false});
  }

  function refitVisible(){
    for (const [btnId, panelId] of pairs){
      const panel = document.getElementById(panelId);
      if (panel && getComputedStyle(panel).display !== 'none'){
        clampSubmenu(panel);
      }
    }
  }

  function init(){
    pairs.forEach(([b,p]) => hook(b,p));
    window.addEventListener('resize', refitVisible);
  }

  if (document.readyState !== 'loading') init();
  else document.addEventListener('DOMContentLoaded', init, {once:true});
})();
</script>

<style id="feLogPanelCSS">
  #logBox { background:#232a2d; border-radius:14px; box-shadow:0 2px 10px #0005; }
  #logHeader:hover { filter:brightness(1.08); }
  #clearLogBtn { transition:opacity .12s ease; }
  #clearLogBtn:hover { opacity:.9; }
</style>

<style id="feOverlayKillSwitch">
/* Ensure any drag overlay never eats release events */
#__feDndOverlay { pointer-events: none !important; }
</style>

<style id="feCanvasBackground">
/* Single source of truth for canvas background */
#drawflow{ background:transparent !important; background-image: var(--fe-bg-image, none) !important; background-repeat: repeat !important; background-size: auto !important; background-position: top left !important; position:relative !important; }
#drawflow .precanvas{ position:relative !important; z-index:1 !important; }
/* Tiled background behind nodes using CSS variables */
#drawflow .precanvas::before, #drawflow::before{
  content:""; position:absolute; inset:0; pointer-events:none; z-index:0;
  background-image: var(--fe-bg-image, none);
  background-repeat: repeat;
  background-size: auto;
  background-position: top left;
  filter: brightness(var(--fe-bg-brightness, 1));
}
</style>

</head>
<body>
<div id="headline">
    <div>
      <span id="feMenuWrap" style="position:relative; display:inline-block; margin-right:10px;">
        <button id="feHamburger" aria-haspopup="true" aria-expanded="false" title="Menu" style="font-size:18px; line-height:1; padding:6px 10px; border-radius:8px; box-shadow:0 2px 8px #0004; cursor:pointer; background:#232a2d; color:#eaeaea; border:1px solid #444;" aria-controls="feMenu">&#9776;</button>
        <div id="feMenu" role="menu" style="display:none; position:absolute; top:36px; left:0; background:#232a2d; border:1px solid #444; box-shadow:0 8px 18px #0009; border-radius:10px; padding:6px; z-index:5000; min-width:180px;">  
            <button id="sendFlow"        class="fe-menu-item" style="display:block;width:100%;text-align:left;background:none;color:#eee;border:none;padding:8px 10px;border-radius:8px;cursor:pointer;"> üíæ Save</button>  
            <button id="saveAsFlow"      class="fe-menu-item" style="display:block;width:100%;text-align:left;background:none;color:#eee;border:none;padding:8px 10px;border-radius:8px;cursor:pointer;"> üìù Save As</button>  
            <button id="exportAnonFlow"      class="fe-menu-item" style="display:block;width:100%;text-align:left;background:none;color:#eee;border:none;padding:8px 10px;border-radius:8px;cursor:pointer;"> üì§ Export</button>  
            <button id="renameFlow"      class="fe-menu-item" style="display:block;width:100%;text-align:left;background:none;color:#eee;border:none;padding:8px 10px;border-radius:8px;cursor:pointer;"> ‚úèÔ∏è Rename</button>  
            <button id="deleteFlowAppBtn"      class="fe-menu-item" style="display:block;width:100%;text-align:left;background:none;color:#eee;border:none;padding:8px 10px;border-radius:8px;cursor:pointer;"> üóëÔ∏è Delete</button>  
            <button id="newFlow"         class="fe-menu-item" style="display:block;width:100%;text-align:left;background:none;color:#eee;border:none;padding:8px 10px;border-radius:8px;cursor:pointer;"> ‚ûï New</button>  
            <div class="fe-menu-divider" style="height:1px;background:#394148;margin:6px 4px;"></div>  
            <div style="position:relative;">    
                <button id="feMenu-display" class="fe-menu-item" style="display:block;width:100%;text-align:left;background:none;color:#eee;border:none;
                    padding:8px 10px;border-radius:8px;cursor:pointer;"> üñ•Ô∏è 
                    Display Options ‚ñ∂
                </button>    
                <div id="feMenuDisplay" role="menu" style="display:none; position:absolute; top:2px; left:calc(100% + 6px); background:#232a2d;border:1px solid #444; box-shadow:0 8px 18px #0009; border-radius:10px; padding:6px;z-index:6000; min-width:200px;">      
                    <button id="bgImageBtn" class="fe-menu-item" style="display:block;width:100%;text-align:left;background:none;color:#eee;border:none;padding:8px 10px;border-radius:8px;cursor:pointer;"> üñºÔ∏è Image</button>
                    <button id="removeBgBtn" class="fe-menu-item" style="display:block;width:100%;text-align:left;background:none;color:#eee;border:none;padding:8px 10px;border-radius:8px;cursor:pointer;"> ‚ùå Remove Image</button>
                    <input type="file" id="bgImageFile" accept="image/*" style="display:none;">
                    <input type="range" id="gridBrightnessSlider" min="0" max="1" step="0.01" value="1" style="vertical-align:middle; width:100px;">
                    <button id="toggleScrollbarsBtn" class="fe-menu-item" style="display:block;width:100%;text-align:left;background:none;color:#eee;border:none;padding:8px 10px;border-radius:8px;cursor:pointer;"> üìú Scroll Bars</button>
                    <button id="statusButton" class="fe-menu-item" style="display:block;width:100%;text-align:left;background:none;color:#eee;border:none;padding:8px 10px;border-radius:8px;cursor:pointer;"> üìä Tile Status</button>
                    <button id="minimapToggleButton" class="fe-menu-item" style="display:block;width:100%;text-align:left;background:none;color:#eee;border:none;padding:8px 10px;border-radius:8px;cursor:pointer;"> üó∫Ô∏è Mini-map</button>
                </div>
            </div>
            <div class="fe-menu-divider" style="height:1px;background:#394148;margin:6px 4px;"></div>
            <div style="position:relative;">
                <button id="feMenu-align" class="fe-menu-item" style="display:block;width:100%;text-align:left;background:none;color:#eee;border:none;padding:8px 10px;border-radius:8px;cursor:pointer;"> üìê Alignment ‚ñ∂</button>
                <div id="feMenuAlign" role="menu" style="display:none; position:absolute; top:2px; left:calc(100% + 6px); background:#232a2d;border:1px solid #444; box-shadow:0 8px 18px #0009; border-radius:10px; padding:6px;z-index:6000; min-width:200px;">
                    <button id="alignLeftBtn"   class="fe-menu-item" style="display:block;width:100%;text-align:left;background:none;color:#eee;border:none;padding:8px 10px;border-radius:8px;cursor:pointer;"> ‚¨ÖÔ∏è Left</button>
                    <button id="alignRightBtn"  class="fe-menu-item" style="display:block;width:100%;text-align:left;background:none;color:#eee;border:none;padding:8px 10px;border-radius:8px;cursor:pointer;"> ‚û°Ô∏è Right</button>
                    <button id="alignTopBtn"    class="fe-menu-item" style="display:block;width:100%;text-align:left;background:none;color:#eee;border:none;padding:8px 10px;border-radius:8px;cursor:pointer;"> ‚¨ÜÔ∏è Top</button>
                    <button id="alignBottomBtn" class="fe-menu-item" style="display:block;width:100%;text-align:left;background:none;color:#eee;border:none;padding:8px 10px;border-radius:8px;cursor:pointer;"> ‚¨áÔ∏è Bottom</button>
                    <button id="alignCenterBtn" class="fe-menu-item" style="display:block;width:100%;text-align:left;background:none;color:#eee;border:none;padding:8px 10px;border-radius:8px;cursor:pointer;"> üìç Center</button>
                    <button id="alignMiddleBtn" class="fe-menu-item" style="display:block;width:100%;text-align:left;background:none;color:#eee;border:none;padding:8px 10px;border-radius:8px;cursor:pointer;"> ‚ûñ Middle</button>    
                    <button id="snapToGridToggle" class="fe-menu-item" style="display:block;width:100%;text-align:left;background:none;color:#eee;border:none;padding:8px 10px;border-radius:8px;cursor:pointer;"> üî≤ Snap to Grid</button>
                    <button id="fitViewBtn" class="fe-menu-item" style="display:block;width:100%;text-align:left;background:none;color:#eee;border:none;padding:8px 10px;border-radius:8px;cursor:pointer;"> ü™ü Fit & Dock</button>
                    <button id="dockBtn" class="fe-menu-item" style="display:block;width:100%;text-align:left;background:none;color:#eee;border:none;padding:8px 10px;border-radius:8px;cursor:pointer;"> üìå Dock</button></div>
                </div>
            <div class="fe-menu-divider" style="height:1px;background:#394148;margin:6px 4px;"></div>
            <div style="position:relative;">
                <button id="feMenu-mainnodes" class="fe-menu-item" style="display:block;width:100%;text-align:left;background:none;color:#eee;border:none;
                    padding:8px 10px;border-radius:8px;cursor:pointer;"> üå≥ 
                    Main Nodes ‚ñ∂
                </button>
                <div id="feMenuMainNodes" role="menu"
                    style="display:none; position:absolute; top:2px; left:calc(100% + 6px); background:#232a2d;
                            border:1px solid #444; box-shadow:0 8px 18px #0009; border-radius:10px; padding:6px;
                            z-index:6000; min-width:220px;">
                    <button id="addDevice"    class="fe-menu-item" style="display:block;width:100%;text-align:left;background:none;color:#eee;border:none;padding:8px 10px;border-radius:8px;cursor:pointer;"> ‚ö° Action</button>
                    <button id="addCondition" class="fe-menu-item" style="display:block;width:100%;text-align:left;background:none;color:#eee;border:none;padding:8px 10px;border-radius:8px;cursor:pointer;"> ‚ùì Condition</button>
                    <button id="addTrigger"     class="fe-menu-item" style="display:block;width:100%;text-align:left;background:none;color:#eee;border:none;padding:8px 10px;border-radius:8px;cursor:pointer;"> ‚è∞ Event Trigger</button>
                    <button id="addSchedule"  class="fe-menu-item" style="display:block;width:100%;text-align:left;background:none;color:#eee;border:none;padding:8px 10px;border-radius:8px;cursor:pointer;"> üìÖ Schedule Trigger</button>
                </div>
            </div>
            <div style="position:relative;">
                <button id="feMenu-othernodes" class="fe-menu-item" style="display:block;width:100%;text-align:left;background:none;color:#eee;border:none;
                    padding:8px 10px;border-radius:8px;cursor:pointer;"> üîß 
                    Other Nodes ‚ñ∂
                </button>
                <div id="feMenuOtherNodes" role="menu" style="display:none; position:absolute; top:2px; left:calc(100% + 6px); background:#232a2d;
                    border:1px solid #444; box-shadow:0 8px 18px #0009; border-radius:10px; padding:6px;z-index:6000; min-width:260px;">
                <button id="addComment"    class="fe-menu-item" style="display:block;width:100%;text-align:left;background:none;color:#eee;border:none;padding:8px 10px;border-radius:8px;cursor:pointer;"> üí¨ Comment</button>
                <button id="addDelayMin"   class="fe-menu-item" style="display:block;width:100%;text-align:left;background:none;color:#eee;border:none;padding:8px 10px;border-radius:8px;cursor:pointer;"> ‚è±Ô∏è Delay Minutes</button>
                <button id="addDelay"      class="fe-menu-item" style="display:block;width:100%;text-align:left;background:none;color:#eee;border:none;padding:8px 10px;border-radius:8px;cursor:pointer;"> ‚åõ Delay MS</button>
                <button id="addDoNothing"  class="fe-menu-item" style="display:block;width:100%;text-align:left;background:none;color:#eee;border:none;padding:8px 10px;border-radius:8px;cursor:pointer;"> üôà Do Nothing</button>
                <button id="addNotify"     class="fe-menu-item" style="display:block;width:100%;text-align:left;background:none;color:#eee;border:none;padding:8px 10px;border-radius:8px;cursor:pointer;"> üîî Notification</button>
                <button id="addRepeat"     class="fe-menu-item" style="display:block;width:100%;text-align:left;background:none;color:#eee;border:none;padding:8px 10px;border-radius:8px;cursor:pointer;"> üîÅ Repeat</button>
                <button id="addRestoreDeviceState"    class="fe-menu-item" style="display:block;width:100%;text-align:left;background:none;color:#eee;border:none;padding:8px 10px;border-radius:8px;cursor:pointer;"> ‚ôªÔ∏è Restore Device State</button>
                <button id="addSaveDeviceState"       class="fe-menu-item" style="display:block;width:100%;text-align:left;background:none;color:#eee;border:none;padding:8px 10px;border-radius:8px;cursor:pointer;"> üíΩ Save Device State</button>
                <button id="addSetVariable"           class="fe-menu-item" style="display:block;width:100%;text-align:left;background:none;color:#eee;border:none;padding:8px 10px;border-radius:8px;cursor:pointer;"> üî£ Set Variable</button>
                </div>
            </div>
            <div style="position:relative;">
                <button id="feMenu-specialnodes" class="fe-menu-item" style="display:block;width:100%;text-align:left;background:none;color:#eee; 
                    border:none;padding:8px 10px;border-radius:8px;cursor:pointer;"> ‚≠ê 
                    Special Nodes ‚ñ∂
                </button>
                <div id="feMenuSpecialNodes" role="menu"
                    style="display:none; position:absolute; top:2px; left:calc(100% + 6px); background:#232a2d;
                            border:1px solid #444; box-shadow:0 8px 18px #0009; border-radius:10px; padding:6px;
                            z-index:6000; min-width:220px;">
                <button id="addCountdown" class="fe-menu-item" style="display:block;width:100%;text-align:left;background:none;color:#eee;border:none;padding:8px 10px;border-radius:8px;cursor:pointer;"> ‚è≥ Countdown</button>
                <button id="addMotionDirection"    class="fe-menu-item" style="display:block;width:100%;text-align:left;background:none;color:#eee;border:none;padding:8px 10px;border-radius:8px;cursor:pointer;"> üèÉ‚Äç‚ôÇÔ∏è Motion Direction</button>
                </div>
            </div>
        <div class="fe-menu-divider" style="height:1px;background:#394148;margin:6px 4px;"></div>
        <div style="padding:6px 8px; color:#ccc; font-size:13px;">
          <div style="margin-bottom:6px; font-weight:bold;">üîë Hubitat Connection</div>
          <input id="hubitatAppId" placeholder="App ID"
                style="font-size:13px; padding:6px 10px; border-radius:4px;
                        width:100px; background:#1c1f20; color:#eee; border:1px solid #555;">
          <br>
          <input id="hubitatToken" placeholder="Token"
                style="font-size:13px; padding:6px 10px; border-radius:4px;
                        width:140px; margin-bottom:6px; background:#1c1f20; color:#eee; border:1px solid #555;" type="password">
        </div>
      </div>
      </span>
        <div style="display:inline-block; font-weight:bold; font-size:14px; vertical-align:top;">
        <b>Flow Engine Editor</b><br><small>Ver. 1.0.065</small></div>
        <button id="feCollapseInline" title="Collapse/Expand sidebar" style="margin-left:10px; border:1px solid #444; background:#2f3639; color:#e7e7e7; padding:6px 10px; border-radius:10px; cursor:pointer; box-shadow:0 2px 8px #0007;">‚óÄ</button>
<select id="hubitatFileDropdown"
              style="width:400px; display:inline-block; margin-left:20px;"
              title="Pick a flow to load‚Ä¶">
              <option value="">Loading‚Ä¶</option>
        </select>
      <span id="flowName" style="display:inline-block; width:400px; font-weight:bold; font-size:14px; margin-left:6px; vertical-align:middle;"></span>

      <div class="inline-div">
        <button id="activateFlowButton"
          style="font-size:14px; padding:6px 12px; border-radius:7px; box-shadow:0 2px 8px #0004; cursor:pointer; background-color:#808080; margin-left:6px;">
          Deactivated
        </button>
        <button id="loggingButton"
          style="font-size:14px; padding:6px 12px; border-radius:7px; box-shadow:0 2px 8px #0004; cursor:pointer; background-color:#808080;">
          Log Disabled
        </button>
      </div>
    </div></div>
    <div id="main">
        <div id="editor"><div id="flowStatusBar" style="margin:0 0 10px 0; padding:6px 10px; background:#232a2d; border-radius:14px; box-shadow:0 2px 10px #0005; font-size:14px;">
          <div id="flowStatusName" style="font-weight:bold; font-size:24px; margin-bottom:4px;white-space:nowrap; overflow:hidden;white-space:nowrap; overflow:hidden;"></div>
          <div id="flowStatusFlags" style="font-size:11px; color:#ddd;"></div><div id="lastRunLine" style="font-size:11px; color:#e7e7e7; margin-top:3px;"></div>
        </div>
        <div id="nodeEditorPanel" style="background:#232a2d; border-radius:14px; box-shadow:0 2px 10px #0005; padding:10px 10px 6px 10px; margin-bottom:12px;">

        <div id="header" style="font-size:20px; display:flex; align-items:center; gap:12px;" title="Node Editor">
          <b>Node Editor</b>
        </div>
          <div id="nodeEditor">Right Click a node to edit</div>
          <div>
            <small id="multiSelectTip-mac" style="display:none;">Use 'cmd-click' to select multiple Devices</small>
            <small id="multiSelectTip-win" style="display:none;">Use 'ctrl-click' to select multiple Devices</small>
          </div>
          <div><hr></div>
          </div>
          <!-- Flow Tester (collapsible) -->
          <div id="flowTesterPanel" style="background:#232a2d; border-radius:14px; box-shadow:0 2px 10px #0005; margin-bottom:12px; padding:0;">
            <div id="flowTesterHeader"
                style="font-size:15px; font-weight:bold; cursor:pointer; display:flex; align-items:center; gap:6px; padding:12px 10px 8px 10px; user-select:none;">
              <span id="flowTesterArrow" style="transition:transform 0.2s; font-size:16px; color:#90cdf4;">‚ñº</span>
              Flow Tester
            </div>
            <div id="flowTesterContent" style="display:none; font-size:13px; padding:0 10px 12px 10px;">
              <!-- content is injected by checkIfFlowIsInUse(...) -->
            </div>
          </div>
          <div id="variableInspectorPanel" style="background:#232a2d; border-radius:14px; box-shadow:0 2px 10px #0005; margin-bottom:12px; padding:0;">
            <div id="variableInspectorHeader"
                style="font-size:15px; font-weight:bold; cursor:pointer; display:flex; align-items:center; gap:6px; padding:12px 10px 8px 10px; user-select:none;">
              <span id="variableInspectorArrow"
                    style="transition:transform 0.2s; font-size:16px; color:#90cdf4;">‚ñº</span>
              Variable Inspector
            </div>
            <div id="variableInspectorContent"
                style="display:block; font-size:13px; padding:0 10px 8px 10px; max-height:260px; overflow:auto;">
            </div>
          </div>
          <div id="variableManagerPanel" style="background:#232a2d; border-radius:14px; box-shadow:0 2px 10px #0005; margin-bottom:12px;">
            <div id="variableManagerHeader" style="font-size:15px; font-weight:bold; cursor:pointer; display:flex; align-items:center; gap:6px; padding:8px 8px 8px 8px; user-select:none;">
              <span id="variableManagerArrow" style="transition:transform 0.2s; font-size:16px; color:#90cdf4;">‚ñº</span>
              Add Variables
            </div>
            <div id="variableManager" style="display:none; padding:0 10px 8px 16px;"></div>
          </div>

          <div id="variableDeletePanel" style="background:#232a2d; border-radius:14px; box-shadow:0 2px 10px #0005; margin-bottom:12px;">
            <div id="variableDeleteHeader" style="font-size:15px; font-weight:bold; cursor:pointer; display:flex; align-items:center; gap:6px; padding:8px 8px 8px 8px; user-select:none;">
              <span id="variableDeleteArrow" style="transition:transform 0.2s; font-size:16px; color:#90cdf4;">‚ñº</span>
              Delete Variable
            </div>
            <div id="variableDeleteContent" style="display:none; padding:0 10px 8px 16px;"></div>
          </div>
          
          <div id="variableEditPanel" style="background:#232a2d; border-radius:14px; box-shadow:0 2px 10px #0005; margin-bottom:12px;">
            <div id="variableEditHeader" style="font-size:15px; font-weight:bold; cursor:pointer; display:flex; align-items:center; gap:6px; padding:8px 8px 8px 8px; user-select:none;">
              <span id="variableEditArrow" style="transition:transform 0.2s; font-size:16px; color:#90cdf4;">‚ñº</span>
              Edit Variable
            </div>
            <div id="variableEditContent" style="display:none; padding:0 10px 8px 16px;"></div>
          </div>

          <!-- Logs Panel (collapsible like other panels) -->
<div id="logPanel" style="background:#232a2d; border-radius:14px; box-shadow:0 2px 10px #0005; margin-bottom:12px; padding:0;">
  <div id="logHeader"
       style="font-size:15px; font-weight:bold; cursor:pointer; display:flex; align-items:center; gap:8px;
              padding:12px 10px 8px 10px; user-select:none;">
    <span id="logArrow" style="transition:transform 0.2s; font-size:16px; color:#90cdf4;">‚ñº</span>
    Logs
    <span style="flex:1 1 auto;"></span>
    <label for="logAutoscroll" style="font-size:11px; color:#bbb; display:flex; align-items:center; gap:6px;">
      <input id="logAutoscroll" type="checkbox" style="transform:scale(1.1);" checked>
      Autoscroll
    </label>
    <button id="clearLogBtn"
            style="margin-left:10px;font-size:11px;padding:5px 8px;border-radius:8px;cursor:pointer;
                   background:#808080;color:#fff;border:none;">
      Clear
    </button>
  </div>
  <div id="logContent"
       style="display:none; font-size:12px; padding:0 10px 10px 10px; max-height:240px;
              overflow:auto; font-family:ui-monospace,Consolas,monospace;">
    <div id="logLines"></div>
  </div>
</div>
</div>
          
          <div id="drawflow">
      </div>
  </div>
  <div id="minimap-container"
    style="position: fixed; bottom: 24px; right: 28px; width: 240px; height: 140px; background: #181d20cc; border-radius: 12px; z-index: 9999; box-shadow: 0 2px 10px #0008; border: 2px solid #444; overflow: hidden; cursor: grab; display: none; touch-action: none;">
    <canvas id="minimap-canvas" width="240" height="140"></canvas>
    <div style="position:absolute;bottom:5px;right:10px;font-size:11px;color:#aaa;">Mini-map</div>
  </div>
  <script src="FE_drawflow-js.min.js"></script>
  <script>
  // Force willReadFrequently on 2D contexts to silence getImageData warning (Canvas & OffscreenCanvas)
  (function(){
    try {
      const _orig = HTMLCanvasElement.prototype.getContext;
      if (_orig && !_orig.__fe_patched2) {
        const wrapped = function(type, opts){
          if (type === "2d") {
            const o = Object.assign({ willReadFrequently: true }, opts || {});
            return _orig.call(this, type, o);
          }
          return _orig.apply(this, arguments);
        };
        wrapped.__fe_patched2 = true;
        HTMLCanvasElement.prototype.getContext = wrapped;
      }
    } catch(_) {}
    try {
      if (typeof OffscreenCanvas !== "undefined") {
        const _o = OffscreenCanvas.prototype.getContext;
        if (_o && !_o.__fe_patched2) {
          const w2 = function(type, opts){
            if (type === "2d") {
              const o = Object.assign({ willReadFrequently: true }, opts || {});
              return _o.call(this, type, o);
            }
            return _o.apply(this, arguments);
          };
          w2.__fe_patched2 = true;
          OffscreenCanvas.prototype.getContext = w2;
        }
      }
    } catch(_) {}
  })();
  </script>
  <script src="FE_html2canvas.min.js"></script>
  <script>
(function(){
  function applyHeadHeight(){
    var h = (document.getElementById('headline')?.offsetHeight) || 0;
    document.documentElement.style.setProperty('--fe-head-h', h + 'px');
  }
  // initial + responsive updates
  window.addEventListener('load', applyHeadHeight, {once:true});
  window.addEventListener('resize', applyHeadHeight);
  // some UI toggles can change header height; update on DOM changes too
  const mo = new MutationObserver(applyHeadHeight);
  mo.observe(document.getElementById('headline') || document.body, {subtree:true, childList:true, attributes:true});
})();
</script>

  <script>
    (function(){
      const sel = document.getElementById('specialTilesDropdown');
      if (!sel) return;

      if (!sel.__specialHooked) {
        sel.__specialHooked = true;
        sel.addEventListener('change', function(){
          const id = this.value;
          if (!id) return;
          const btn = document.getElementById(id);
          if (btn && typeof btn.click === 'function') btn.click();
          this.value = ''; // reset to placeholder
        });
      }
    })();

    // 1) Fetch the list of flow-files from Hubitat
    async function fetchHubitatFiles() {
      const appId = (document.getElementById("hubitatAppId")?.value || localStorage.getItem('hubitatAppId') || '').trim();
      const token = (document.getElementById("hubitatToken")?.value || localStorage.getItem('hubitatToken') || '').trim();
      if (!appId || !token) {
        console.error("Missing App ID or Token");
        return [];
      }
      const res = await fetch(`/apps/api/${appId}/listFiles?access_token=${token}`);
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      const body = await res.json();
      return Array.isArray(body.files)
        ? body.files.map(f => f.replace(/\.json$/i, ""))
        : [];
    }

    // 2) Globally-available: repopulate the dropdown
    async function reloadFlowDropdown(selected){
      selected = (selected == null ? '' : String(selected));
      const dropdown = document.getElementById("hubitatFileDropdown");
      if (!dropdown) return;

      dropdown.style.display = "inline-block";
      dropdown.innerHTML = "<option value=''>Pick a Flow‚Ä¶</option>";
      let files = [];
      try {
        files = await fetchHubitatFiles();
      } catch (err) {
        console.error("Error fetching flow list:", err);
        return;
      }
      files.forEach(f => {
        const opt = document.createElement("option");
        opt.value       = f;
        opt.textContent = f;
        dropdown.appendChild(opt);
      });

      const focus = selected.replace(/\.json$/i, "");
      dropdown.value = focus;

      const token = document.getElementById("hubitatToken")?.value?.trim() || localStorage.getItem('hubitatToken') || "";
      const appId = document.getElementById("hubitatAppId")?.value?.trim() || localStorage.getItem('hubitatAppId') || "";

      if (focus) {
        checkIfFlowIsInUse(focus, appId, token);
      }
    }

    // 3) Unified flow selection loader
    async function onFlowSelected(file) {
      if (!file) return;

      // Save as last opened
      localStorage.setItem('lastFlow', file);

      // --- Set current flow file for variables ---
      if (window.flowVars?.setCurrentFlowVars) {
        await window.flowVars.setCurrentFlowVars(file);
      } else if (window.flowVars?.setCurrentFlowFile) {
        await window.flowVars.setCurrentFlowFile(file);
      } else if (window.flowVars) {
        window.flowVars._currentFlowFile = file;
      }

      const appId = (document.getElementById("hubitatAppId")?.value || localStorage.getItem('hubitatAppId') || '').trim();
      const token = (document.getElementById("hubitatToken")?.value || localStorage.getItem('hubitatToken') || '').trim();
      if (!appId || !token) {
        alert("Missing Hubitat App ID or Token.");
        return;
      }

      // --- Load flow JSON (with auto-fix fallback) ---
      const fullName = file.endsWith(".json") ? file : file + ".json";
      let jsonText = "";
      try {
        jsonText = await fetchHubitatFileContent(fullName);
      } catch (e) {
        alert("Failed to load flow: " + e.message);
        return;
      }

      let data;
      try {
        data = typeof jsonText === "string" ? JSON.parse(jsonText) : jsonText;
      } catch (err) {
        const fixed = String(jsonText)
          .replace(/^\uFEFF/, "")
          .replace(/\/\/.*$/gm, "")
          .replace(/\/\*[\s\S]*?\*\//g, "")
          .replace(/,\s*([}\]])/g, "$1")
          .replace(/(['"])?([a-zA-Z_$][\w$]*)\1\s*:/g, '"$2":')
          .replace(/'([^']*)'/g, '"$1"')
          .replace(/\bNaN\b/g, "null")
          .replace(/\bInfinity\b/g, "null");
        try {
          data = JSON.parse(fixed);
          logAction(`üîß Auto-fixed JSON on load for "${fullName}"`, "info");
        } catch (err2) {
          alert("‚ùå JSON load failed even after auto-fix:<br>" + err2.message);
          return;
        }
      }

      // --- Import into editor / refresh UI ---
      try {
        if (window.editor?.import) {
          editor.import(data);
          try { const __vp = __fe_extractViewport(data); if (__vp) __fe_applyViewport(__vp); } catch(_) {}

          if (Array.isArray(window.devices)) {
            patchFlowWithDeviceLabels(data, window.devices);
          }
          // make the inspector show this flow's vars right now
          try { await refreshVarsAndInspector(); } catch (_) {}
        } else {
          await restoreFlowFromJson(data); // this path already refreshes inside restoreFlowFromJson
        }

        document.getElementById("flowName").textContent = file;
        try { var tn=document.getElementById("flowStatusName"); if(tn){ tn.textContent = file.replace(/\.json$/i,""); fitFlowName(); } } catch(_){ }
        markFlowNeedsSave(false);
        logAction(`Loaded ‚Äú${file}‚Äù from Hubitat.`, "success");
      } catch (e) {
        alert("‚ùå Failed to render flow: " + e.message);
        logAction("Error importing flow: " + e, "error");
        return;
      }

      // --- Live status panel ---
      try { checkIfFlowIsInUse(file, appId, token); } catch (_) {}
    }

    // 4) Bind dropdown change to unified loader
    document.getElementById("hubitatFileDropdown").addEventListener("change", async function () {
      const file = this.value.trim();
      await onFlowSelected(file);
    });

    // 5) Auto-populate dropdown and optionally load last flow on page load (hardened)
    // --- Helpers: wait for editor & validate flow JSON ---
    async function waitForEditorReady(maxMs = 6000) {
      const start = Date.now();
      while (Date.now() - start < maxMs) {
        if (window.editor && typeof window.editor.import === 'function') return true;
        await new Promise(r => setTimeout(r, 60));
      }
      return false;
    }

    async function fetchFlowJsonChecked(fileBaseName) {
      const full = fileBaseName.endsWith('.json') ? fileBaseName : fileBaseName + '.json';
      let txt = await fetchHubitatFileContent(full); // existing fetcher
      if (typeof txt === 'string') {
        const cleaned = String(txt)
          .replace(/^\uFEFF/, '')
          .replace(/\/\/.*$/gm, '')
          .replace(/\/\*[\s\S]*?\*\//g, '')
          .replace(/,\s*([}\]])/g, '$1');
        txt = cleaned;
      }
      const data = typeof txt === 'string' ? JSON.parse(txt) : txt;
      const df = data?.drawflow;
      const hasHome = !!(df?.Home?.data || df?.drawflow?.Home?.data);
      return { data, hasHome };
    }

    async function loadLastFlowWithRetry(fileBaseName, maxAttempts = 6) {
      await waitForEditorReady(6000);
      let attempt = 0;
      while (attempt < maxAttempts) {
        attempt++;
        try {
          const { data, hasHome } = await fetchFlowJsonChecked(fileBaseName);
          if (!hasHome) {
            if (attempt === maxAttempts) {
              logAction(`‚ùå Flow "${fileBaseName}" is missing drawflow.Home after ${maxAttempts} attempts.`, 'error');
              return;
            }
          } else {
            if (window.editor && typeof window.editor.import === 'function') {
              window.editor.import(data);
              if (Array.isArray(window.devices)) {
                try { patchFlowWithDeviceLabels(data, window.devices); } catch (_) {}
              }
              document.getElementById('flowName').textContent = fileBaseName.replace(/\.json$/i, '');
              try { markFlowNeedsSave(false); } catch (_) {}
              logAction(`Loaded ‚Äú${fileBaseName}‚Äù from Hubitat.`, 'success');return;
            } else {
              try { await restoreFlowFromJson(data); } catch (e) { throw e; }
              document.getElementById('flowName').textContent = fileBaseName.replace(/\.json$/i, '');
              logAction(`Loaded ‚Äú${fileBaseName}‚Äù from Hubitat.`, 'success');return;
            }
          }
        } catch (e) {
          const msg = String(e && e.message || e);
          const transient = /Cannot read (properties|property) of undefined \(reading 'Home'\)/i.test(msg) ||
                           /drawflow/i.test(msg) ||
                           /Unexpected end of JSON input/i.test(msg);
          if (!transient && attempt >= maxAttempts) {
            logAction('‚ùå Error importing flow (no more retries): ' + msg, 'error');
            return;
          }
        }
        await new Promise(r => setTimeout(r, 150 * attempt));
      }
    }

    document.addEventListener('DOMContentLoaded', async () => {
      try {
        await new Promise(r => setTimeout(r, 120));
        const last = (localStorage.getItem('lastFlow') || '');
        await reloadFlowDropdown(String(last));
        if (last) {
          await loadLastFlowWithRetry(last);
        }
      } catch (e) {
        console.warn('Init auto-load failed:', e);
        try { logAction('Init auto-load failed: ' + (e?.message || e), 'warn'); } catch (_) {}
      }
    });

    function sanitizeFlowName(name) {
      return name
        .trim()
        .replace(/\s+/g, "_")
        .replace(/[^A-Za-z0-9_-]/g, "")
        .replace(/_{2,}/g, "_")
        .replace(/^_+|_+$/g, "");
    }

    async function fetchVarsFromApp() {
      const appId = (document.getElementById("hubitatAppId")?.value || "").trim();
      const token = (document.getElementById("hubitatToken")?.value || "").trim();
      if (!appId || !token) throw new Error("Missing Hubitat App ID/Token");

      const url = `/apps/api/${encodeURIComponent(appId)}/variables?access_token=${encodeURIComponent(token)}`;
      const res = await fetch(url, { method: "GET" });
      const text = await res.text();
      let data = JSON.parse(text);

      // ‚úÖ Store variables globally for inspector + editing
      window.FE_global_vars = data.globals || [];
      window.FE_flowvars    = data.flows   || {};
      return data;
    }

    // ‚îÄ‚îÄ global ‚ÄúShow Status‚Äù toggle button ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    (function setupStatusToggle() {
      const statusBtn = document.getElementById('statusButton');
      window.globalShowStatus = true;

      function updateStatusBtn() {
        if (!statusBtn) return;
        if (window.globalShowStatus) {
          statusBtn.textContent = 'Status';
          statusBtn.style.backgroundColor = '#4CAF50';
        } else {
          statusBtn.textContent = 'Status';
          statusBtn.style.backgroundColor = '#808080';
        }
      }

      function reRenderTiles() {
        const nodes = document.querySelectorAll('.drawflow-node[id^="node-"]');
        nodes.forEach(el => {
          const id = el.id.replace('node-', '');
          const node = (window.editor && typeof window.editor.getNodeFromId === 'function')
            ? window.editor.getNodeFromId(id)
            : null;
          if (node && window.editor && typeof window.editor.updateNodeHtmlFromId === 'function') {
            window.editor.updateNodeHtmlFromId(id, nodeTileHtml(node.name, node.data, id));
          }
        });
        try { markFlowNeedsSave(true); } catch (e) {}
      }

      if (statusBtn) {
        statusBtn.addEventListener('click', () => {
          window.globalShowStatus = !window.globalShowStatus;
          updateStatusBtn();
          reRenderTiles();
        });
        updateStatusBtn();
      }
    })();

    
(function setupMinimapToggle(){
  const btn = document.getElementById('minimapToggleButton');
  const box = document.getElementById('minimap-container');
  const cvs = document.getElementById('minimap-canvas');

  const KEY = 'fe_minimap_visible';
  const isOn  = () => localStorage.getItem(KEY) === '1';
  const setOn = v => localStorage.setItem(KEY, v ? '1' : '0');

  let inFlight = false;
  let pending  = false;
  let lastAt   = 0;
  const MIN_MS = 800;
  const MAX_MS = 3000;
  let timerId = 0;

  function updateBtn(){
    if (!btn) return;
    btn.style.backgroundColor = isOn() ? '#4CAF50' : '#808080';
    btn.textContent = 'Mini-map';
  }

  function queueRender(){
    if (!isOn()) return;
    const now = performance.now();
    const since = now - lastAt;
    if (inFlight) { pending = true; return; }
    if (since < MIN_MS) {
      if (timerId) clearTimeout(timerId);
      timerId = setTimeout(run, MIN_MS - since);
    } else {
      run();
    }
  }

  async function run(){
    if (inFlight || !isOn()) return;
    inFlight = true;
    try { await renderMinimapOnce(); }
    finally {
      inFlight = false;
      lastAt = performance.now();
      if (pending) { pending = false; queueRender(); }
      else {
        if (timerId) clearTimeout(timerId);
        timerId = setTimeout(() => queueRender(), MAX_MS);
      }
    }
  }

  function applyVisibility(){
    if (!box) return;
    const on = isOn();
    box.style.display = on ? 'block' : 'none';
    updateBtn();
    if (on) queueRender();
  }

  if (btn) {
    btn.addEventListener('click', () => { setOn(!isOn()); applyVisibility(); try{ markFlowNeedsSave(true);}catch(_){}; });
  }

  ['wheel','keydown','keyup','resize','pointerup','pointerdown','pointermove']
    .forEach(ev => window.addEventListener(ev, () => queueRender(), {passive:true}));

  document.addEventListener('visibilitychange', ()=>{
    if (document.hidden) { if (timerId) { clearTimeout(timerId); timerId = 0; } }
    else { queueRender(); }
  });
  window.addEventListener('blur', ()=>{ if (timerId) { clearTimeout(timerId); timerId = 0; } });
  window.addEventListener('focus', ()=>{ queueRender(); });

  applyVisibility();
})();


    function renderVariableInspector() {
      const container = document.getElementById("variableInspectorContent");
      if (!container) return;
      container.innerHTML = "";
      let html = "";

      // ---- GLOBAL VARIABLES ----
      let globals = Array.isArray(window.FE_global_vars) ? window.FE_global_vars : [];
      html += `<div style="color:#eee;margin-bottom:3px;">
        <b>Global Variables</b>
      </div>`;
      if (globals.length) {
        globals
          .slice()
          .sort((a, b) => (a.name || '').localeCompare(b.name || ''))
          .forEach(v => {
            if (!v || typeof v !== "object" || !v.name) return;
            html += `<div style="margin-left:8px;">
              <span style="color:#eec150;">${v.name}</span> = 
              <span style="color:#02c258;">${JSON.stringify(v.value)}</span>
            </div>`;
          });
      } else {
        html += `<div style="color:#888;margin-left:8px;">(No global vars)</div>`;
      }

      // ---- FLOW VARIABLES ----
      let flowFile = window.flowVars?.getCurrentFlowFile?.() || "";
      let base = String(flowFile).replace(/\.json$/i, "");

      // Normalize FE_flowvars if it's an array [{flow,name,type,value}, ...]
      (function normalizeFlowVarsOnce(){
        if (!window.FE_flowvars) { window.FE_flowvars = {}; return; }
        if (Array.isArray(window.FE_flowvars)) {
          const arr = window.FE_flowvars;
          const map = {};
          for (const r of arr) {
            if (!r || !r.flow || !r.name) continue;
            const b = String(r.flow).replace(/\.json$/i, "");
            (map[b] = map[b] || []).push({ name: r.name, type: r.type || "String", value: r.value });
            map[b + ".json"] = map[b]; // mirror key
          }
          window.FE_flowvars = map;
        } else if (typeof window.FE_flowvars === "object") {
          // ensure keys exist with & without ".json"
          for (const k of Object.keys(window.FE_flowvars)) {
            const b = k.replace(/\.json$/i, "");
            if (!window.FE_flowvars[b]) window.FE_flowvars[b] = window.FE_flowvars[k] || [];
            if (!window.FE_flowvars[b + ".json"]) window.FE_flowvars[b + ".json"] = window.FE_flowvars[b];
          }
        }
      })();

      let flowVarsArr = [];
      if (window.FE_flowvars) {
        flowVarsArr =
          window.FE_flowvars[flowFile] ||
          window.FE_flowvars[base] ||
          window.FE_flowvars[base + ".json"] ||
          [];
      }

      html += `<hr style="margin:8px 0;border-top:1px solid #333;">`;
      html += `<div style="color:#eee;margin-bottom:3px;">
        <b>Flow Variables</b>
        <span style="font-size:11px;color:#888;margin-left:12px;">${flowFile ? flowFile : "(none loaded)"}</span>
      </div>`;

      if (flowVarsArr && flowVarsArr.length) {
        flowVarsArr
          .slice()
          .sort((a, b) => (a.name || '').localeCompare(b.name || ''))
          .forEach(v => {
            if (!v || typeof v !== "object" || !v.name) return;
            html += `<div style="margin-left:8px;">
              <span style="color:#81e1ff;">${v.name}</span> = 
              <span style="color:#8be66a;">${JSON.stringify(v.value)}</span>
            </div>`;
          });
      } else {
        html += `<div style="color:#888;margin-left:8px;">(No flow vars for this flow)</div>`;
      }
      container.innerHTML = html;
    }

    function patchFlowWithDeviceLabels(flow, devices) {
      // Support both new and legacy JSON paths
      const dataNodes =
        (flow && (editor && editor.drawflow ? editor.drawflow : {}) && getHomeFrom(flow) && getHomeDataFrom(flow))
          ? getHomeDataFrom(flow)
          : (flow && (editor && editor.drawflow ? editor.drawflow : {}) && (editor && editor.drawflow ? editor.drawflow : {}).drawflow &&
            getHomeFrom(flow) && getHomeDataFrom(flow))
            ? getHomeDataFrom(flow)
            : {};

      // Ensure "notMatchingVar" nodes get a default outputVar label
      Object.values(dataNodes).forEach(node => {
        const name = (node.name || "").toLowerCase();
        if (name === "notmatchingvar") {
          if (!node.data.outputVar || node.data.outputVar === "undefined") {
            node.data.outputVar = "Devices to a Variable";
          }
        }
      });

      // Tag any device-based node with its human-readable label
      Object.values(dataNodes).forEach(node => {
        const type = (node.name || "").toLowerCase();
        if (["device", "condition", "eventtrigger"].includes(type) &&
            node.data && node.data.deviceId) {
          const dev = devices.find(d => d.id == node.data.deviceId);
          node.data.deviceLabel = dev
            ? (dev.label || dev.name)
            : node.data.deviceId;
        }
      });
    }
    
    async function restoreFlowFromJson(jsonStr) {
      try {
        if (typeof jsonStr !== "string") {
          jsonStr = JSON.stringify(jsonStr); // Convert to string if needed
        }
        if (!window.devices || !window.devices.length) {
          if (typeof fetchDevicesFromApp === "function") {
            window.devices = await fetchDevicesFromApp();
            window.devices.forEach(dev => {
              if (Array.isArray(dev.attributes)) {
                const attrMap = {};
                dev.attributes.forEach(a => {
                  if (a.name !== undefined) attrMap[a.name] = a.currentValue;
                });
                dev.attributes = attrMap;
              }
            });
            window.devices.push(TIME_DEVICE);
            window.devices.push(MODE_DEVICE);
          }
        }

        const flow = JSON.parse(jsonStr);
        if (editor && typeof editor.import === "function") {
          editor.import(flow);
          try { const __vp = __fe_extractViewport(flow); if (__vp) __fe_applyViewport(__vp); } catch(_) {}

          patchFlowWithDeviceLabels(flow, window.devices);

          const nodes =
            editor.drawflow?.Home?.data ||
            editor.drawflow?.drawflow?.Home?.data ||
            {};
          Object.values(nodes).forEach(n => {
            const el = document.getElementById(`node-${n.id}`);
            if (!el) return;
            el.setAttribute('data-node-type', n.name);
          });

          if (editor.drawflow && getHomeFrom(editor) && getHomeDataFrom(editor)) {
            Object.values(getHomeDataFrom(editor)).forEach(updateTileHtml);
          }

          setTimeout(() => {
            let selected = editor.selected_id;
            if (!selected) {
              const allIds = editor.drawflow && getHomeFrom(editor) && getHomeDataFrom(editor)
                ? Object.keys(getHomeDataFrom(editor))
                : [];
              if (allIds.length) {
                selected = allIds[0];
                editor.selected_id = selected;
              }
            }
            if (selected) {
              window.renderEditor(editor.getNodeFromId(selected));
            } else {
              document.getElementById("nodeEditor").innerHTML = "Click a node to edit";
            }
          }, 10);

          // ------- The only variable/inspector refresh you need -------
          await refreshVarsAndInspector();
        }
      } catch (e) {
        logAction("Failed to restore flow: " + e, "error");
      }
    }    

    // === Connection refresh helper (debounced) ===
    (function(){
      if (window.__fe_refreshConnectionsInstalled) return;
      window.__fe_refreshConnectionsInstalled = true;
      let rafId = 0, rafId2 = 0;
      window.refreshConnectionsSoon = function refreshConnectionsSoon(){
        try { if (rafId) cancelAnimationFrame(rafId); if (rafId2) cancelAnimationFrame(rafId2); } catch(_){}
        rafId = requestAnimationFrame(() => {
          rafId2 = requestAnimationFrame(() => {
            try {
              if (window.editor && typeof window.editor.updateConnectionNodesAll === 'function') {
                window.editor.updateConnectionNodesAll();
              } else if (window.editor && typeof window.editor.updateConnectionNodes === 'function') {
                // Fallback: touch every node
                const data = (window.editor.drawflow && getHomeDataFrom(window.editor)) || {};
                Object.keys(data).forEach(id => {
                  try { window.editor.updateConnectionNodes(id); } catch(_){}
                });
              }
            } catch(_){}
          });
        });
      };
    })();
    // === Viewport helpers: save/restore canvas pan into flow JSON (x,y only) ===
    function __fe_getViewport() {
      try {
        const ed = window.editor || {};
        const z = (typeof ed.zoom === "number") ? ed.zoom : 1;
        const x = (typeof ed.canvas_x !== "undefined") ? Number(ed.canvas_x||0) : 0;
        const y = (typeof ed.canvas_y !== "undefined") ? Number(ed.canvas_y||0) : 0;
        return { x, y, z };
      } catch (_){ return {x:0,y:0,z:1}; }
    }
    function __fe_applyViewport(vp) {
      if (!vp) return;
      try {
        if (window.editor && window.editor.precanvas) {
          // keep existing zoom; only restore pan
          const z = (typeof window.editor.zoom === "number") ? window.editor.zoom : 1;
          window.editor.canvas_x = Number(vp.x||0);
          window.editor.canvas_y = Number(vp.y||0);
          window.editor.precanvas.style.transform = 'translate(' + window.editor.canvas_x + 'px, ' + window.editor.canvas_y + 'px) scale(' + z + ')';
        } else {
          const el = document.querySelector('#drawflow');
          if (el){
            const m = (el.style.transform||'').match(/scale\(([-\d\.]+)\)/i);
            const z = m ? parseFloat(m[1]||'1') : 1;
            el.style.transform = 'translate(' + (vp.x||0) + 'px, ' + (vp.y||0) + 'px) scale(' + z + ')';
          }
        }
      } catch (_){}
    }
    function __fe_stampViewport(flowObj) {
      try {
        const vp = __fe_getViewport();
        if (!flowObj || typeof flowObj !== "object") return flowObj;
        // Store redundantly for compatibility
        flowObj.meta = flowObj.meta || {};
        flowObj.meta.viewport = { x: Number(vp.x||0), y: Number(vp.y||0), z: Number(vp.z||1) };
        flowObj.drawflow = flowObj.drawflow || {};
        flowObj.drawflow.Home = flowObj.drawflow.Home || {};
        flowObj.drawflow.Home.viewport = { x: Number(vp.x||0), y: Number(vp.y||0), z: Number(vp.z||1) };
      } catch(_){}
      return flowObj;
    }
    function __fe_extractViewport(flowObj) {
      try {
        const df = flowObj && flowObj.drawflow;
        return (df && df.Home && df.Home.viewport)
            || (df && df.drawflow && df.drawflow.Home && df.drawflow.Home.viewport)
            || (flowObj && flowObj.meta && flowObj.meta.viewport)
            || flowObj?.viewport
            || null;
      } catch(_){ return null; }
    }

    function markFlowNeedsSave(needed = true) {
      const btn = document.getElementById('sendFlow');
      if (btn) {
        if (needed) btn.classList.add('need-save');
        else btn.classList.remove('need-save');
      }

      const burger = document.getElementById('feHamburger');
      if (burger) {
        // toggle hamburger color
        burger.classList.toggle('fe-dirty', !!needed);
        burger.classList.toggle('fe-clean', !needed);
        burger.setAttribute('aria-label', needed ? 'Unsaved changes' : 'All changes saved');
        burger.title = needed ? 'Menu ‚Äî Unsaved changes' : 'Menu';
      }
    }

    function hubitatCredentialsAreValid(logIfMissing = false) {
      const appId = document.getElementById("hubitatAppId")?.value?.trim();
      const token = document.getElementById("hubitatToken")?.value?.trim();
      if (!appId || !token) {
        if (logIfMissing) logAction("Missing App ID or Token. Please enter both.", "warn");
        return false;
      }
      return true;
    }

    function showHubitatWarning(show) {
      let warn = document.getElementById("hubitatWarnBanner");
      if (!warn) {
        warn = document.createElement("div");
        warn.id = "hubitatWarnBanner";
        warn.style = "background: #ffc107; color: #111; padding: 9px 22px; font-weight: bold; text-align:center; font-size:16px; border-bottom: 2px solid #b8860b;";
        warn.innerHTML = "‚ö†Ô∏è Please enter both Hubitat App ID and Token to use Flow Engine Editor features.";
        document.body.insertBefore(warn, document.body.firstChild);
      }
      warn.style.display = show ? "block" : "none";
    }

    function updateHubitatButtonStates() {
      const valid = hubitatCredentialsAreValid();
      const buttonIds = ["loadDevices", "sendFlow", "renameFlow", "deleteFlowAppBtn", "saveAsFlow", "exportAnonFlow"];
      buttonIds.forEach(id => {
        const btn = document.getElementById(id);
        if (btn) btn.disabled = !valid;
      });
      showHubitatWarning(!valid);
    }
    document.getElementById("hubitatAppId").addEventListener("input", updateHubitatButtonStates);
    document.getElementById("hubitatToken").addEventListener("input", updateHubitatButtonStates);
    window.addEventListener("DOMContentLoaded", updateHubitatButtonStates);

    function clearUiIfCredentialsMissing() {
      if (!hubitatCredentialsAreValid()) {
        if (typeof window.devices !== "undefined") window.devices = [];
        if (editor && editor.clear) editor.clear();
      }
    }
    document.getElementById("hubitatAppId").addEventListener("input", clearUiIfCredentialsMissing);
    document.getElementById("hubitatToken").addEventListener("input", clearUiIfCredentialsMissing);

    function validateHubitatInputFormat() {
      const appId = document.getElementById("hubitatAppId")?.value?.trim();
      const token = document.getElementById("hubitatToken")?.value?.trim();
      if (appId && !/^[a-zA-Z0-9]+$/.test(appId)) {
        showHubitatWarning(true);
        document.getElementById("hubitatWarnBanner").innerText = "‚ö†Ô∏è Invalid App ID format. Only letters and numbers are allowed.";
      } else if (token && !/^[a-zA-Z0-9\-]+$/.test(token)) {
        showHubitatWarning(true);
        document.getElementById("hubitatWarnBanner").innerText = "‚ö†Ô∏è Invalid Token format.";
      } else {
        showHubitatWarning(!hubitatCredentialsAreValid());
        if (hubitatCredentialsAreValid()) document.getElementById("hubitatWarnBanner").innerText =
          "‚ö†Ô∏è Please enter both Hubitat App ID and Token to use Flow Engine Editor features.";
      }
    }
    document.getElementById("hubitatAppId").addEventListener("input", validateHubitatInputFormat);
    document.getElementById("hubitatToken").addEventListener("input", validateHubitatInputFormat);

    window.addEventListener("DOMContentLoaded", function() {
      setTimeout(updateHubitatButtonStates, 350);
    });
      
    function logAction(msg, type = "info") {
      const logBox = document.getElementById("logBox");
      if (logBox) {
        logBox.innerHTML += `<span class="log-${type}">${msg}</span><br>`;
        logBox.scrollTop = logBox.scrollHeight;
      }
    }
 
    const TIME_DEVICE = {
      id: "__time__",
      label: "Time",
      name: "Time",
      attributes: {
        currentTime: "",
        timeOfDay: ["sunrise", "sunset"],
        dayOfWeek: [
          "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"
        ]
      },
      commands: []
    };

    function buildTimeDevicePicker(pickerDiv, node) {
      // Only handle the special ‚ÄúTime‚Äù and ‚ÄúMode‚Äù devices
      const devs = node.data.deviceIds || [];
      if (
        devs.length !== 1 ||
        (node.data.deviceId !== "__time__" && node.data.deviceId !== "__mode__")
      ) {
        return false;
      }

      pickerDiv.innerHTML = "";

      // Initialize data on first render
      if (!node.data.attribute) {
        node.data.attribute  = "";
        node.data.comparator = "";
        node.data.value      = "";
      }

      // ‚îÄ‚îÄ MODE DEVICE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      if (node.data.deviceId === "__mode__") {
        node.data.attribute = "mode";
        editor.updateNodeDataFromId(node.id, node.data);

        const lbl = document.createElement("label");
        lbl.textContent = "Mode";
        lbl.style.display = "block";
        pickerDiv.appendChild(lbl);

        const sel = document.createElement("select");
        sel.style = "display:block;margin-bottom:12px";
        const modes = window.hubitatModes || [];
        sel.innerHTML =
          `<option value=""></option>` +
          modes
            .map(m => `<option value="${m.id}"${node.data.value === m.id ? " selected" : ""}>${m.name}</option>`)
            .join("");
        sel.onchange = () => {
          node.data.value = sel.value;
          editor.updateNodeDataFromId(node.id, node.data);
          markFlowNeedsSave(true);
        };
        pickerDiv.appendChild(sel);
        return true;
      }

      // ‚îÄ‚îÄ CONDITION LABEL ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      pickerDiv.appendChild(
        Object.assign(document.createElement("label"), {
          textContent: "Condition",
          style: "display:block;margin-bottom:4px",
        })
      );

      // ‚îÄ‚îÄ ATTRIBUTE SELECT ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      const attrSelect = document.createElement("select");
      attrSelect.style = "display:block;margin-bottom:12px";
      attrSelect.innerHTML =
        `<option value=""${!node.data.attribute ? " selected" : ""}>(select)</option>` +
        [
          { key: "timeOfDay",   label: "Time of Day"  },
          { key: "dayOfWeek",   label: "Day of Week"  },
          { key: "currentTime", label: "Current Time" }
        ]
          .map(def =>
            `<option value="${def.key}"${node.data.attribute===def.key ? " selected" : ""}>${def.label}</option>`
          )
          .join("");
      attrSelect.onchange = () => {
        node.data.attribute = attrSelect.value;
        node.data.comparator = "";
        node.data.value = "";
        editor.updateNodeDataFromId(node.id, node.data);
        buildTimeDevicePicker(pickerDiv, node);
        markFlowNeedsSave(true);
      };
      pickerDiv.appendChild(attrSelect);

      // ‚îÄ‚îÄ COMPARATOR LABEL ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      pickerDiv.appendChild(
        Object.assign(document.createElement("label"), {
          textContent: "Comparator",
          style: "display:block;margin-bottom:4px",
        })
      );

      // ‚îÄ‚îÄ COMPARATOR SELECT ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      const cmpSelect = document.createElement("select");
      cmpSelect.style = "display:block;margin-bottom:12px";
      cmpSelect.innerHTML =
        `<option value=""${!node.data.comparator ? " selected" : ""}>(select)</option>` +
        ["==","!=","<","<=" ,">",">=","between"]
          .map(cmp =>
            `<option value="${cmp}"${node.data.comparator===cmp ? " selected" : ""}>${cmp==="==" ? "equals" : cmp}</option>`
          )
          .join("");
      cmpSelect.onchange = () => {
        node.data.comparator = cmpSelect.value;
        node.data.value = "";
        editor.updateNodeDataFromId(node.id, node.data);
        buildTimeDevicePicker(pickerDiv, node);
        markFlowNeedsSave(true);
      };
      pickerDiv.appendChild(cmpSelect);

      // ‚îÄ‚îÄ VALUE PICKERS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      if (node.data.attribute === "dayOfWeek") {
        // Day‚Äëof‚ÄëWeek picker
        const days = ["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"];
        if (node.data.comparator === "between") {
          if (!Array.isArray(node.data.value)) node.data.value = ["",""];
          const [startVal, endVal] = node.data.value;

          // Start day dropdown
          const startSel = document.createElement("select");
          startSel.style = "display:block;margin-bottom:8px";
          startSel.innerHTML =
            `<option value=""></option>` +
            days.map(d =>
              `<option value="${d}"${startVal===d ? " selected" : ""}>${d}</option>`
            ).join("");
          startSel.onchange = () => {
            node.data.value[0] = startSel.value;
            editor.updateNodeDataFromId(node.id, node.data);
            markFlowNeedsSave(true);
          };
          pickerDiv.appendChild(startSel);

          // End day dropdown
          const endSel = document.createElement("select");
          endSel.style = "display:block;margin-bottom:12px";
          endSel.innerHTML =
            `<option value=""></option>` +
            days.map(d =>
              `<option value="${d}"${endVal===d ? " selected" : ""}>${d}</option>`
            ).join("");
          endSel.onchange = () => {
            node.data.value[1] = endSel.value;
            editor.updateNodeDataFromId(node.id, node.data);
            markFlowNeedsSave(true);
          };
          pickerDiv.appendChild(endSel);
        } else {
          // Multi‚Äëselect
          const sel = document.createElement("select");
          sel.multiple = true;
          sel.size     = days.length;
          sel.style    = "display:block;margin-bottom:12px";
          const chosen = Array.isArray(node.data.value) ? node.data.value : (node.data.value ? [node.data.value] : []);
          days.forEach(d => {
            const opt = document.createElement("option");
            opt.value = d;
            opt.textContent = d;
            if (chosen.includes(d)) opt.selected = true;
            sel.appendChild(opt);
          });
          sel.onchange = () => {
            node.data.value = Array.from(sel.selectedOptions).map(o => o.value);
            editor.updateNodeDataFromId(node.id, node.data);
            markFlowNeedsSave(true);
          };
          pickerDiv.appendChild(sel);
        }
      }
      else if (node.data.attribute === "timeOfDay") {
        // Time of Day (sunrise/sunset or custom)
        if (node.data.comparator === "between") {
          if (!Array.isArray(node.data.value)) node.data.value = ["",""];
          const [startVal, endVal] = node.data.value;

          // Sunrise/Sunset start selector
          const startSelect = document.createElement("select");
          startSelect.style = "display:block;margin-bottom:8px";
          startSelect.innerHTML =
            `<option value=""${!startVal ? " selected" : ""}>(select)</option>` +
            ["sunrise","sunset"].map(opt =>
              `<option value="${opt}"${startVal===opt ? " selected" : ""}>${opt.charAt(0).toUpperCase()+opt.slice(1)}</option>`
            ).join("");
          startSelect.onchange = () => {
            node.data.value[0] = startSelect.value;
            editor.updateNodeDataFromId(node.id, node.data);
            markFlowNeedsSave(true);
          };
          pickerDiv.appendChild(startSelect);

          // Sunrise/Sunset/Custom end selector
          const endSelect = document.createElement("select");
          endSelect.style = "display:block;margin-bottom:12px";
          endSelect.innerHTML =
            `<option value=""${!endVal ? " selected" : ""}>(select)</option>` +
            ["sunrise","sunset","custom"].map(opt =>
              `<option value="${opt}"${
                (opt!=="custom" ? endVal===opt : (endVal && !["sunrise","sunset"].includes(endVal)))
                  ? " selected" : ""
              }>${opt.charAt(0).toUpperCase()+opt.slice(1)}</option>`
            ).join("");
          endSelect.onchange = () => {
            if (endSelect.value === "custom") {
              node.data.value[1] = (endVal && !["sunrise","sunset"].includes(endVal)) ? endVal : "12:00";
            } else {
              node.data.value[1] = endSelect.value;
            }
            editor.updateNodeDataFromId(node.id, node.data);
            buildTimeDevicePicker(pickerDiv, node);
            markFlowNeedsSave(true);
          };
          pickerDiv.appendChild(endSelect);

         // Offset input for start and end
        const offsetLabel = document.createElement("label");
        offsetLabel.textContent = "Offset ¬± (minutes)";
        offsetLabel.style = "display:block;margin:8px 0 4px 0;";
        pickerDiv.appendChild(offsetLabel);

        const startOffset = document.createElement("input");
        startOffset.type = "number";
        startOffset.placeholder = "Start Offset";
        startOffset.value = Array.isArray(node.data.offset) ? node.data.offset[0] || 0 : 0;
        startOffset.style = "display:block;margin-bottom:6px;width:100%;";

        const endOffset = document.createElement("input");
        endOffset.type = "number";
        endOffset.placeholder = "End Offset";
        endOffset.value = Array.isArray(node.data.offset) ? node.data.offset[1] || 0 : 0;
        endOffset.style = "display:block;margin-bottom:12px;width:100%;";

        startOffset.onchange = endOffset.onchange = () => {
          node.data.offset = [
            parseInt(startOffset.value) || 0,
            parseInt(endOffset.value) || 0
          ];
          editor.updateNodeDataFromId(node.id, node.data);
          markFlowNeedsSave(true);
        };

        pickerDiv.appendChild(startOffset);
        pickerDiv.appendChild(endOffset);

          // Custom time input if needed
          if (
            node.data.value[1] === "custom" ||
            (node.data.value[1] && !["sunrise","sunset"].includes(node.data.value[1]))
          ) {
            const timeInput = document.createElement("input");
            timeInput.type  = "time";
            timeInput.value = node.data.value[1] || "";
            timeInput.style = "display:block;margin-bottom:12px";
            timeInput.onchange = () => {
              node.data.value[1] = timeInput.value;
              editor.updateNodeDataFromId(node.id, node.data);
              markFlowNeedsSave(true);
            };
            pickerDiv.appendChild(timeInput);
          }
        }
        else {
          // Single sunrise/sunset select
          const todSelect = document.createElement("select");
          todSelect.style = "display:block;margin-bottom:12px";
          todSelect.innerHTML =
            `<option value=""${!node.data.value ? " selected" : ""}>(select)</option>` +
            ["sunrise","sunset"].map(opt =>
              `<option value="${opt}"${node.data.value===opt ? " selected" : ""}>${opt.charAt(0).toUpperCase()+opt.slice(1)}</option>`
            ).join("");
          todSelect.onchange = () => {
            node.data.value = todSelect.value;
            editor.updateNodeDataFromId(node.id, node.data);
            markFlowNeedsSave(true);
          };
          pickerDiv.appendChild(todSelect);

          // Offset input for single sunrise/sunset
          const offsetLabel = document.createElement("label");
          offsetLabel.textContent = "Offset ¬± (minutes)";
          offsetLabel.style = "display:block;margin:8px 0 4px 0;";
          pickerDiv.appendChild(offsetLabel);

          const offsetInput = document.createElement("input");
          offsetInput.type = "number";
          offsetInput.placeholder = "Offset (min)";
          offsetInput.value = node.data.offset || 0;
          offsetInput.style = "display:block;margin-bottom:12px;width:100%;";
          offsetInput.onchange = () => {
            node.data.offset = parseInt(offsetInput.value) || 0;
            editor.updateNodeDataFromId(node.id, node.data);
            markFlowNeedsSave(true);
          };
          pickerDiv.appendChild(offsetInput);
        }
      }
      else if (node.data.attribute === "currentTime" && node.data.comparator === "between") {
        // Two <input type="time"> for ‚Äúbetween‚Äù currentTime
        if (!Array.isArray(node.data.value)) node.data.value = ["",""];
        const [cStart, cEnd] = node.data.value;

        const inStart = document.createElement("input");
        inStart.type  = "time";
        inStart.value = cStart || "";
        inStart.style = "display:block;margin-bottom:8px";
        inStart.onchange = () => {
          node.data.value[0] = inStart.value;
          editor.updateNodeDataFromId(node.id, node.data);
          markFlowNeedsSave(true);
        };
        pickerDiv.appendChild(inStart);

        const inEnd = document.createElement("input");
        inEnd.type  = "time";
        inEnd.value = cEnd || "";
        inEnd.style = "display:block;margin-bottom:12px";
        inEnd.onchange = () => {
          node.data.value[1] = inEnd.value;
          editor.updateNodeDataFromId(node.id, node.data);
          markFlowNeedsSave(true);
        };
        pickerDiv.appendChild(inEnd);
      }
      else {
        // Fallback single <input type="time">
        const timeInput = document.createElement("input");
        timeInput.type  = "time";
        timeInput.value = node.data.value || "";
        timeInput.style = "display:block;margin-bottom:12px";
        timeInput.onchange = () => {
          node.data.value = timeInput.value;
          editor.updateNodeDataFromId(node.id, node.data);
          markFlowNeedsSave(true);
        };
        pickerDiv.appendChild(timeInput);
      }

      return true;
    }

    const MODE_DEVICE = {
      id: "__mode__",
      label: "Home Location",
      name: "Mode",
      attributes: { mode: "" },
      commands: []
    };

    const VARIABLE_DEVICE = {
      id: "__variable__",
      label: "Variable",
      name: "Variable",
      attributes: { value: "" }
    };

    const devs = Array.isArray(window.devices) ? window.devices : [];
    let conditionDevices = [...devs];

    conditionDevices.unshift(VARIABLE_DEVICE);

    function isValidFlowName(flowName) {
      return /^[a-zA-Z0-9_-]+$/.test(flowName);
    }

    // ‚Äî HELPERS FOR ATTRIBUTE / COMPARATOR / VALUE ‚Äî
    // 1) Generic attribute picker
    function renderAttributePicker(el, node, dev, onChange) {
      const lbl = document.createElement("label");
      lbl.textContent = "Attribute";
      lbl.style.display = "block";
      el.appendChild(lbl);

      const sel = document.createElement("select");
      sel.style.display = "block";
      sel.style.marginBottom = "12px";
      sel.innerHTML =
        `<option value="" ${!node.data.attribute ? "selected" : ""}>(select)</option>` +
        Object.keys(dev.attributes)
          .map(attr =>
            `<option value="${attr}" ${node.data.attribute === attr ? "selected" : ""}>${attr}</option>`
          )
          .join("");
      sel.onchange = () => {
        node.data.attribute = sel.value;
        if (typeof onChange === "function") onChange();
        editor.updateNodeDataFromId(node.id, node.data);
        markFlowNeedsSave(true);
      };
      el.appendChild(sel);
    }

    // 2) Generic comparator picker
    function renderComparatorPicker(el, node, comparators, comparatorLabels, onChange) {
      const lbl = document.createElement("label");
      lbl.textContent = "Comparator";
      lbl.style.display = "block";
      el.appendChild(lbl);

      const sel = document.createElement("select");
      sel.style.display = "block";
      sel.style.marginBottom = "12px";
      sel.innerHTML =
        `<option value="" ${!node.data.comparator ? "selected" : ""}>(select)</option>` +
        comparators
          .map(cmp =>
            `<option value="${cmp}" ${node.data.comparator === cmp ? "selected" : ""}>${comparatorLabels[cmp] || cmp}</option>`
          )
          .join("");
      sel.onchange = () => {
        node.data.comparator = sel.value;
        if (typeof onChange === "function") onChange();
        editor.updateNodeDataFromId(node.id, node.data);
        markFlowNeedsSave(true);
      };
      el.appendChild(sel);
    }

    function renderValueField(el, node, knownValues, onChange, between = false) {
      // Prevent duplicate value fields
      if (el.querySelector('.value-field')) return;

      const lbl = document.createElement("label");
      lbl.textContent = "Value";
      lbl.style.display = "block";
      lbl.className = "value-field";
      el.appendChild(lbl);

      if (between) {
        // Two inputs for ‚Äúbetween‚Äù
        const [minVal = "", maxVal = ""] = Array.isArray(node.data.value) ? node.data.value : ["", ""];
        const minIn = Object.assign(document.createElement("input"), { type: "text", value: minVal, placeholder: "Min", style: "width:45%;margin-right:7px;" });
        const maxIn = Object.assign(document.createElement("input"), { type: "text", value: maxVal, placeholder: "Max", style: "width:45%;" });
        const upd = () => {
          node.data.value = [minIn.value, maxIn.value];
          if (typeof onChange === "function") onChange();
          editor.updateNodeDataFromId(node.id, node.data);
          markFlowNeedsSave(true);
        };
        minIn.onchange = maxIn.onchange = upd;
        minIn.className = maxIn.className = "value-field";
        el.appendChild(minIn);
        el.appendChild(maxIn);
      }
      else if (knownValues && knownValues.length) {
        // Use dropdown
        const sel = document.createElement("select");
        sel.style.display = "block";
        sel.style.marginBottom = "12px";
        sel.className = "value-field";
        sel.innerHTML =
          `<option value="" ${!node.data.value ? "selected" : ""}>(select)</option>` +
          knownValues
            .map(v => `<option value="${v}" ${node.data.value === v ? "selected" : ""}>${v}</option>`)
            .join("");
        sel.onchange = () => { 
          node.data.value = sel.value; 
          if (typeof onChange === "function") onChange(); 
          editor.updateNodeDataFromId(node.id, node.data);
          markFlowNeedsSave(true);
        };
        el.appendChild(sel);
      }
      else {
        // Fallback: free-text input
        const input = document.createElement("input");
        input.type = "text";
        input.value = node.data.value || "";
        input.placeholder = "Enter value";
        input.style = "display:block;margin-bottom:12px;width:100%;";
        input.className = "value-field";
        input.onchange = () => {
          node.data.value = input.value;
          if (typeof onChange === "function") onChange();
          editor.updateNodeDataFromId(node.id, node.data);
          markFlowNeedsSave(true);
        };
        el.appendChild(input);
      }
    }

    function nodeTileHtml(type, data, nodeId) {
      // === Countdown tile (MM-DD, rolls to next occurrence) ===
      if (String(type||"").toLowerCase() === "countdown") {
        const errorStyle = (typeof getErrorStyle === "function") ? getErrorStyle(type, data) : "";
        const vName = (data && data.varName) ? data.varName : "Variable";
        const dStr  = (data && data.targetDate) ? data.targetDate : "(enter MM-DD)";
        let days = "";
        try {
          if (data && data.targetDate && /^\d{2}-\d{2}$/.test(String(data.targetDate))) {
            const today  = new Date();
            const parts  = String(data.targetDate).split("-");
            const month  = Number(parts[0]);
            const day    = Number(parts[1]);
            const start  = new Date(today.getFullYear(), today.getMonth(), today.getDate());
            let target   = new Date(today.getFullYear(), month - 1, day);
            if (target < start) target = new Date(today.getFullYear() + 1, month - 1, day);
            const diff   = Math.ceil((target - start) / (24*60*60*1000));
            days = isFinite(diff) ? String(diff) : "";
          }
        } catch(_){}
        return `<div class="countdown-tile">
          <b>Countdown</b><br>
          <span style="font-size:11px">
            ${vName} ‚Üê days until ${dStr}
            <hr style="margin:4px 0;border-top:1px solid #888;">
            <span>Days Left: ${days || "-"}</span>
          </span>
          ${data && data.locked ? `<div style="position:absolute;top:6px;right:8px;font-size:18px;color:#fa2b2b;" title="Locked">&#128274;</div>` : ""}
        </div>`;
      }

      function getCurrentValue(deviceId, attr) {
        const devs = window.devices || [];
        const dev = devs.find(d => d.id == deviceId);
        if (dev && dev.attributes && attr && dev.attributes[attr] !== undefined) {
          return dev.attributes[attr];
        }
        return "";
      }

      const t = (type || "").toLowerCase();

      if (t === "donothing") {
        return `
          <div class="logic-node">
            <b>Do Nothing</b><br>
            ${data.locked ? `<div style="position:absolute;top:6px;right:8px;font-size:18px;color:#fa2b2b;" title="Locked">&#128274;</div>` : ""}
          </div>`;
      }
      if (t === "delay") {
        const errorStyle = getErrorStyle(type, data);
        let label = "Delay";
        if (typeof data.ms === "number" && !isNaN(data.ms)) {
          label = `Delay ${data.ms} ms`;
        } else if (data && data.ms) {
          label = `Delay ${data.ms} ms`;
        } else if (data && data.minutes) {
          label = `Delay ${data.minutes} min`;
        }
        return `<div class="delay-node"><b>${label}</b>${data.locked ? `<div style="position:absolute;top:6px;right:8px;font-size:18px;color:#fa2b2b;" title="Locked">&#128274;</div>` : ""}</div>`;
      }
      if (t === "delaymin") {
        const errorStyle = getErrorStyle(type, data);
        let label = data && data.delayMin ? `Delay ${data.delayMin} min` : "Delay (min)";
        return `<div class="delaymin-node"><b>${label}</b>${data.locked ? `<div style="position:absolute;top:6px;right:8px;font-size:18px;color:#fa2b2b;" title="Locked">&#128274;</div>` : ""}</div>`;
      }

      if (t === "countdown") {
        const errorStyle = getErrorStyle(type, data);
        const vName = data && data.varName ? data.varName : "Variable";
        const dStr  = data && data.targetDate ? data.targetDate : "(pick a date)";
        let days = "";
        try {
          if (data && data.targetDate) {
            const today = new Date();
            const target = new Date(String(data.targetDate).trim() + "T00:00:00");
            const msPerDay = 24 * 60 * 60 * 1000;
            const start = new Date(today.getFullYear(), today.getMonth(), today.getDate());
            const diff = Math.ceil((target - start) / msPerDay);
            days = isFinite(diff) ? (diff + " day" + (diff === 1 ? "" : "s")) : "";
          }
        } catch(_){}
        return `<div class="countdown-tile">
          <br>Countdown</b><br>
          <span style="font-size:11px">
            ${vName} ‚Üê days until ${dStr}
            <hr style="margin:4px 0;border-top:1px solid #888;">
            <span>Days Left: ${days || "-"}</span>
          </span>
          ${data && data.locked ? `<div style="position:absolute;top:6px;right:8px;font-size:18px;color:#fa2b2b;" title="Locked">&#128274;</div>` : ""}
        </div>`;
      }

      // Tile renderer: Motion Direction
      if (t === "motiondirection") {
        const devs = Array.isArray(window.devices) ? window.devices : [];

        const labelOf = (id) => {
          const d = devs.find(x => String(x.id) === String(id));
          return d ? (d.label || d.name || d.id) : "";
        };

        // Robust variable lookup (prefers flow vars, falls back to globals)
        const lookupVarValue = (name) => {
          if (!name) return "";
          try {
            const flowFile =
              (window.flowVars && typeof window.flowVars.getCurrentFlowFile === "function"
                ? window.flowVars.getCurrentFlowFile()
                : (window.currentFlowFile || window.lastOpenedFlowFile || "")) || "";
            const base = flowFile.replace(/\.json$/i, "");

            // Flow vars
            if (window.FE_flowvars) {
              if (Array.isArray(window.FE_flowvars)) {
                // shape: [{flow:"SomeFlow.json", name:"x", value:"..."}]
                const arr = window.FE_flowvars.filter(v =>
                  v && v.name === name && (
                    v.flow === flowFile || v.flow === base || v.flow === `${base}.json`
                  )
                );
                if (arr.length && "value" in arr[0]) return arr[0].value;
              } else if (typeof window.FE_flowvars === "object") {
                const arr =
                  window.FE_flowvars[base] ||
                  window.FE_flowvars[`${base}.json`] ||
                  window.FE_flowvars[flowFile] || [];
                const hit = Array.isArray(arr) ? arr.find(v => v && v.name === name) : null;
                if (hit && "value" in hit) return hit.value;
              }
            }
            // Global vars
            if (Array.isArray(window.FE_global_vars)) {
              const g = window.FE_global_vars.find(v => v && v.name === name);
              if (g && "value" in g) return g.value;
            }
          } catch (e) { /* noop */ }
          return "";
        };

        const aLabel = labelOf(data?.deviceAId) || "(pick A)";
        const bLabel = labelOf(data?.deviceBId) || "(pick B)";
        const gap    = (data && data.maxGapSec != null) ? Number(data.maxGapSec) : 5;
        const varNm  = (data && data.varName) ? data.varName : "(no variable)";

        const dirVarVal = data?.varName ? lookupVarValue(data.varName) : "";

        const statusLine = window.globalShowStatus
          ? `<hr style="margin:4px 0;border-top:1px solid #888;">
            <div>Last Direction: ${dirVarVal || "-"}</div>`
          : "";

        return `
          <div class="motiondirection-tile">
            <b>Motion Direction</b><br>
            <span style="font-size:11px;">
              A: ${aLabel}<br>
              B: ${bLabel}<br>
              Max: ${isFinite(gap) ? gap : 5}s<br>
              Variable: ${varNm}
              ${statusLine}
            </span>
            ${data && data.locked ? `<div style="position:absolute;top:6px;right:8px;font-size:18px;color:#fa2b2b;" title="Locked">&#128274;</div>` : ""}
          </div>`;
      }

            if (t === "savedevicestate") {
        const errorStyle = (typeof getErrorStyle === "function") ? getErrorStyle(type, data) : "";
        const labels = Array.isArray(data?.deviceLabels) ? data.deviceLabels.filter(Boolean)
              : (data?.deviceLabel ? [data.deviceLabel] : []);
        const ids = Array.isArray(data?.deviceIds) ? data.deviceIds.filter(Boolean)
              : (data?.deviceId ? [data.deviceId] : []);
        const displayList = labels.length ? labels : ids;
        const display = displayList.length ? displayList.join(", ") : "<i>Pick device‚Ä¶</i>";
        const lockedIcon = (data && data.locked)
          ? '<div style="position:absolute;top:6px;right:8px;font-size:18px;color:#fa2b2b;" title="Locked">&#128274;</div>'
          : '';
        return `<div class="savedevicestate-tile">
          <b>Save Device State</b><br>
          <span style="font-size:11px"${errorStyle ? " " + errorStyle : ""}>${display}</span>
          ${lockedIcon}
        </div>`;
      }
            if (t === "restoredevicestate") {
        const errorStyle = (typeof getErrorStyle === "function") ? getErrorStyle(type, data) : "";
        const labels = Array.isArray(data?.deviceLabels) ? data.deviceLabels.filter(Boolean)
              : (data?.deviceLabel ? [data.deviceLabel] : []);
        const ids = Array.isArray(data?.deviceIds) ? data.deviceIds.filter(Boolean)
              : (data?.deviceId ? [data.deviceId] : []);
        const displayList = labels.length ? labels : ids;
        const display = displayList.length ? displayList.join(", ") : "<i>Pick device‚Ä¶</i>";
        const lockedIcon = (data && data.locked)
          ? '<div style="position:absolute;top:6px;right:8px;font-size:18px;color:#fa2b2b;" title="Locked">&#128274;</div>'
          : '';
        return `<div class="restoredevicestate-tile">
          <b>Restore Device State</b><br>
          <span style="font-size:11px"${errorStyle ? " " + errorStyle : ""}>${display}</span>
          ${lockedIcon}
        </div>`;
      }

      if (t === "comment") {
        const errorStyle = getErrorStyle(type, data);
        let isSelected = false;
        if (editor && editor.selected_id && nodeId) {
          if (editor.selected_id == nodeId) isSelected = true;
        }
        let txt = data && data.text ? data.text : "(No comment)";
        return `<div class="comment-tile">
          <b>Comment</b><hr>
          <div>${txt}</div>
          ${data.locked ? `<div style="position:absolute;top:6px;right:8px;font-size:18px;color:#fa2b2b;" title="Locked">&#128274;</div>` : ""}
        </div>`;
      }

      if (t === "schedule") {
        const errorStyle = getErrorStyle(type, data);
        // Collect human summary (like other tiles)
        const dayMap = {SU:'Sun', MO:'Mon', TU:'Tue', WE:'Wed', TH:'Thu', FR:'Fri', SA:'Sat'};
        const repeatDaysArr = Array.isArray(data.repeatDays) ? data.repeatDays : [];
        const repeatDays = repeatDaysArr.map(d => dayMap[d] || d).join(", ");
        const timesArr = Array.isArray(data.times) ? data.times : (data.time ? [data.time] : []);
        const times = timesArr.join(", ");

        const subtitle = [repeatDays, times].filter(Boolean).join(" ‚Äî ");

        // Cron expression (if present)
        let cron = "";
        if (data && typeof data.cron === "string" && data.cron.trim()) cron = data.cron.trim();
        else if (data && data.scheduleSpec && data.scheduleSpec.advanced_cron && data.scheduleSpec.advanced_cron.expression) {
          cron = String(data.scheduleSpec.advanced_cron.expression);
        } else if (data && data.scheduleSpec && data.scheduleSpec.preview && Array.isArray(data.scheduleSpec.preview)) {
          // not a cron but keep last generated expression if present
          cron = data.scheduleSpec.preview[0] || "";
        }
        
        return `<div class="schedule-tile">
          <b>Schedule</b><br>
            <span style="font-size:11px">
              <span>Days: ${repeatDays}</span><br>
              <span>Time: ${times}</span><br>
              <hr style="margin:4px 0;border-top:1px solid #888;">
              <span>Cron: ${cron}</span>
            </span>
            ${data.locked ? `<div style="position:absolute;top:6px;right:8px;font-size:18px;color:#fa2b2b;" title="Locked">&#128274;</div>` : ""}
        </div>`;
      }
    
      if (t === "repeat") {
        const errorStyle = getErrorStyle(type, data);
        const lockedIcon = data.locked
          ? `<div style="position:absolute;top:6px;right:8px;font-size:18px;color:#fa2b2b;" title="Locked">&#128274;</div>`
          : "";

        let description;
        if (data.repeatMode === "until") {
          const deviceLabel = data.deviceLabel || "Device";
          const attr        = data.attribute   || "Attribute";
          const comp        = data.comparator  || "==";
          const val         = data.value       || "Value";
          description = `Until ${deviceLabel} ${attr} ${comp} ${val}`;
        } else {
          const max = data.repeatMax || 1;
          description = `Max ${max} time${max !== 1 ? "s" : ""}`;
        }

        return `<div class="repeat-tile"">
          <b>Repeat</b><br>
          <span style="font-size:11px">
            ${description}
          </span>
          ${data.locked ? `<div style="position:absolute;top:6px;right:8px;font-size:18px;color:#fa2b2b;" title="Locked">&#128274;</div>` : ""}
        </div>`;
      }

      if (t === "setvariable") {
        const errorStyle = getErrorStyle(type, data);
        let vName = data.varName || "Variable";
        let vValue = data.varValue || "Value";

        // --- Find variable type and current value ---
        let varScope = "";
        let currentValue = "";
        // Look for global or flow variable match
        let flowFile = window.flowVars?.getCurrentFlowFile?.();
        let flowVars = (flowFile && window.FE_all_flowvars && Array.isArray(window.FE_all_flowvars[flowFile]))
          ? window.FE_all_flowvars[flowFile]
          : [];
        let globalVars = Array.isArray(window.FE_global_vars) ? window.FE_global_vars : [];
        let found = flowVars.find(obj => obj.name === vName);
        if (found) {
          varScope = "Flow Variable";
          currentValue = found.value;
        } else {
          found = globalVars.find(obj => obj.name === vName);
          if (found) {
            varScope = "Global Variable";
            currentValue = found.value;
          } else {
            varScope = "Variable Not Found";
            currentValue = "";
          }
        }
        if (currentValue === undefined) currentValue = "";
        return `<div class="setVariable-tile">
          <b>Set Variable</b><br>
          <span style="font-size:11px">
            ${vName} = ${vValue}
            <hr style="margin:4px 0;border-top:1px solid #888;">
            <span>${varScope}</span><br>
            <span>Current: <span>${JSON.stringify(currentValue)}</span></span>
          </span>
          ${data.locked ? `<div style="position:absolute;top:6px;right:8px;font-size:18px;color:#fa2b2b;" title="Locked">&#128274;</div>` : ""}
        </div>`;
      }

      if (t === "notmatchingvar") {
        const errorStyle = getErrorStyle(type, data);
        const devLabel = "";
        const attribute = "";
        const value = "";
        const outputVar = (data.outputVar && data.outputVar.trim().toLowerCase() !== "undefined")
          ? data.outputVar
          : "Devices to a Variable";
        const scope = data.varScope === "global" ? "Global" : "Flow";
        const mode  = data.append ? "Append" : "Overwrite";

        return `<div class="setVariable-tile">
          <b>Devices to a Variable</b><br>
          <span style="font-size:11px">
            ${devLabel ? "Devices: " + devLabel + "<br>" : ""}
            ${attribute ? "Attr: " + attribute + "<br>" : ""}
            ${value     ? "Not:  " + value     + "<br>" : ""}
            <hr>
            <b>Output variable / file name:</b> ${outputVar}<br>
            <b>Attr Type:</b> ${scope}<br>
            <b>Save Mode:</b> ${mode}
          </span>
          ${data.locked ? `<div style="position:absolute;top:6px;right:8px;font-size:18px;color:#fa2b2b;" title="Locked">&#128274;</div>` : ""}
        </div>`;
      }

      if (t === "notification") {
        let devLabels = [];
        let ids = Array.isArray(data.targetDeviceId) ? data.targetDeviceId : [data.targetDeviceId];
        (ids || []).forEach(id => {
          let dev = (window.devices || []).find(d => d.id == id);
          if (dev) devLabels.push(dev.label || dev.name || dev.id);
        });
        let devLabelStr = devLabels.length ? devLabels.join(", ") : "<i>No device</i>";

        const lockedHtml = data.locked
          ? '<div style="position:absolute;top:6px;right:8px;font-size:18px;color:#fa2b2b;" title="Locked">&#128274;</div>'
          : "";
        const notifType = data.notificationType === "speech" ? "Speech" : "Push";
        const msg = data.message || "";

        let preview = msg;
        if (window.globalShowStatus && msg) {
          const df = editor.drawflow?.drawflow || editor.drawflow;
          const nodes = df?.Home?.data || {};

          // Find first eventTrigger node (device OR variable)
          let triggerNode = Object.values(nodes).find(n =>
            n.name === "eventTrigger" && n.data &&
            (
              (n.data.deviceId && n.data.deviceId !== "__variable__") ||
              (Array.isArray(n.data.deviceIds) && n.data.deviceIds[0] && n.data.deviceIds[0] !== "__variable__") ||
              n.data.deviceId === "__variable__" ||
              (Array.isArray(n.data.deviceIds) && n.data.deviceIds[0] === "__variable__")
            )
          );

          let deviceLabel = "";
          let deviceValue = "";

          if (triggerNode) {
            // --------- Variable Trigger ---------
            if (
              triggerNode.data.deviceId === "__variable__" ||
              (Array.isArray(triggerNode.data.deviceIds) && triggerNode.data.deviceIds[0] === "__variable__")
            ) {
              // Variable name
              deviceLabel = triggerNode.data.varName || triggerNode.data.variableName || "";
              // Look up value from flow vars, then global vars
              let flowFile = window.flowVars?.getCurrentFlowFile?.();
              let flowVars = (flowFile && window.FE_flowvars && window.FE_flowvars[flowFile]) ? window.FE_flowvars[flowFile] : [];
              let globalVars = Array.isArray(window.FE_global_vars) ? window.FE_global_vars : [];
              let flowVal = flowVars.find(obj => obj.name === deviceLabel)?.value;
              let globalVal = globalVars.find(obj => obj.name === deviceLabel)?.value;
              deviceValue = flowVal !== undefined ? flowVal : (globalVal !== undefined ? globalVal : "");
            } else {
              // --------- Standard Device Trigger ---------
              const dev = (window.devices || []).find(d => d.id == triggerNode.data.deviceId);
              deviceLabel = dev ? (dev.label || dev.name) : (triggerNode.data.deviceLabel || triggerNode.data.deviceId);

              const attr = triggerNode.data.attribute;
              if (attr) {
                if (typeof getCurrentValue === "function") {
                  deviceValue = getCurrentValue(triggerNode.data.deviceId, attr);
                } else if (dev && dev.attributes && dev.attributes[attr] !== undefined) {
                  deviceValue = dev.attributes[attr];
                }
              }
            }
          }

          // --- Start by getting the selected variable, if any ---
          let selectedVarName = (data.useMsgVar && data.msgVarName) ? data.msgVarName : "";
          let selectedVarValue = "";
          if (selectedVarName) {
            let flowFile = window.flowVars?.getCurrentFlowFile?.();
            let flowVars = (flowFile && window.FE_flowvars && window.FE_flowvars[flowFile]) ? window.FE_flowvars[flowFile] : [];
            let globalVars = Array.isArray(window.FE_global_vars) ? window.FE_global_vars : [];
            let flowVal = flowVars.find(obj => obj.name === selectedVarName)?.value;
            let globalVal = globalVars.find(obj => obj.name === selectedVarName)?.value;
            selectedVarValue = flowVal !== undefined ? flowVal : (globalVal !== undefined ? globalVal : "");
          }

          // --- Pre-expand time/date wildcards so the generic catcher doesn't mark them as [not found] ---
          const now = new Date();
          const pad2 = n => String(n).padStart(2, '0');
          const time24 = `${pad2(now.getHours())}:${pad2(now.getMinutes())}`;
          const h12 = (now.getHours() % 12) || 12;
          const ampm = now.getHours() < 12 ? 'am' : 'pm';
          const time12 = `${h12}:${pad2(now.getMinutes())} ${ampm}`;
          const dateStr = `${pad2(now.getMonth()+1)}-${pad2(now.getDate())}-${now.getFullYear()}`;

          preview = (preview || "")
            .replace(/\{time24\}/g, time24)
            .replace(/\{time12\}/g, time12)
            .replace(/\{date\}/g,   dateStr)
            .replace(/\{device\}/g, deviceLabel)
            .replace(/\{value\}/g, deviceValue)
            .replace(/\{variableName\}/g, selectedVarName ? selectedVarName : "[not found]")
            .replace(/\{variableValue\}/g, (selectedVarValue !== undefined && selectedVarValue !== "") ? selectedVarValue : "[not found]")
            .replace(/\{([a-zA-Z0-9_]+)\}/g, (m, v) => {
              if (["device","value","variableName","variableValue","time24","time12","date","now"].includes(v)) return m;
              let flowFile = window.flowVars?.getCurrentFlowFile?.();
              let flowVars = (flowFile && window.FE_flowvars && window.FE_flowvars[flowFile]) ? window.FE_flowvars[flowFile] : [];
              let globalVars = Array.isArray(window.FE_global_vars) ? window.FE_global_vars : [];
              let flowVal = flowVars.find(obj => obj.name === v)?.value;
              let globalVal = globalVars.find(obj => obj.name === v)?.value;
              return flowVal !== undefined ? flowVal : (globalVal !== undefined ? globalVal : "[not found]");
            });
        }

        return `
          <div class="notification-tile">
            <b>${notifType} Notifications</b><br>
            <span style="font-size:11px">
              Device: ${devLabelStr}<br>
              ${msg ? `Message: "${msg}"<br>` : ""}
              <hr>
              ${window.globalShowStatus && msg ? `<b>Preview:</b> "${preview}"<br>` : ""}
            </span>
            ${data.locked ? `<div style="position:absolute;top:6px;right:8px;font-size:18px;color:#fa2b2b;" title="Locked">&#128274;</div>` : ""}
          </div>
        `;
      }

      // ---- Combined rendering for Event Trigger & Condition ----
      if (type === "eventTrigger" || type === "condition") {
        const isCondition = type === "condition";
        const errorStyle  = getErrorStyle(type, data);
        const tileClass   = (isCondition ? "condition-tile" : "trigger-tile") +
          (editor.selected_id == nodeId ? " selected" : "");

        // Comparator and value text
        const comp = data.comparator || "==";
        let valText = "";
        if (comp === "between" && Array.isArray(data.value)) {
          valText = ` (${data.value[0]} to ${data.value[1]})`;
        } else if (data.value !== undefined && data.value !== "") {
          valText = ` ${data.value}`;
        }

        // Logic value
        const logicHtml = data.logic
          ? `<div class="logic-value" style="font-size:11px;margin:4px 0;"><b>Logic:</b> ${data.logic.toUpperCase()}</div>`
          : "";

        // Main label: variable vs. real device
        let mainText;
        if (data.deviceId === "__variable__") {
          mainText = `${data.variableName || "<no var>"} ${comp}${valText}`;
        } else {
          const dev = (window.devices || []).find(d => d.id == data.deviceId);
          const devLabel = dev ? (dev.label || dev.name) : (data.deviceLabel || data.deviceId);
          mainText = `${devLabel} ${data.attribute || ""} ${comp}${valText}`;
        }

        // Current-status line (handles single + multi-device)
        let statusHtml = "";
        if (window.globalShowStatus && data.attribute) {
          const ids = (Array.isArray(data.deviceIds) && data.deviceIds.length)
            ? data.deviceIds
            : [data.deviceId];
          statusHtml = ids.map(id => {
            const curr  = getCurrentValue(id, data.attribute);
            const d     = (window.devices || []).find(dev => dev.id == id);
            const label = d ? (d.label || d.name) : (data.deviceLabel || id);
            return `<div class="status-line" style="font-size:10px;color:#000000;">Current ${label}: ${curr}</div>`;
          }).join("");
        }

        // Click-pattern indicator
        const clickHtml = !isCondition && data.clickPattern
          ? `<div class="click-pattern"></div>`
          : "";

        // Locked padlock
        const lockedHtml = data.locked
          ? '<div style="position:absolute;top:6px;right:6px;font-size:18px;color:#fa2b2b;" title="Locked">&#128274;</div>'
          : "";

        return `
          <div class="${tileClass}" ${errorStyle}>
            ${isCondition ? "<b>Condition</b>" : "<b>Event Trigger</b>"}<br>
            <span style="font-size:11px">
              ${mainText}<br>
              ${logicHtml}
              <hr>
            </span>
            ${statusHtml}
            ${clickHtml}
            ${data.locked ? `<div style="position:absolute;top:6px;right:8px;font-size:18px;color:#fa2b2b;" title="Locked">&#128274;</div>` : ""}
          </div>`;
      }

      // Action tile (device) with per-device status including device names
      if (t === "device") {
        const isSelected = editor && editor.selected_id === nodeId;
        const errorStyle = getErrorStyle(type, data);
        const tileClass  = "device-tile" + (isSelected ? " selected" : "");

        // Label, command, and optional value
        const label = data.deviceLabel
          || (Array.isArray(data.deviceIds) ? data.deviceIds.join(", ") : data.deviceId)
          || "<i>Pick device(s)‚Ä¶</i>";
        const cmd = data.command || "";
        const val = data.value ? `(${data.value})` : "";

        // Status: show current value per selected device
        let statusHtml = "";
        if (window.globalShowStatus && cmd) {
          const cmdAttrMap = {
            on: ["switch"], off: ["switch"], toggle: ["switch"],
            setLevel: ["level"], startLevelChange: ["level"], stopLevelChange: ["level"],
            setColor: ["color"], lock: ["lock"], unlock: ["lock"]
          };
          const attrsToShow = cmdAttrMap[cmd] || [];
          const devs = window.devices || [];
          const ids = Array.isArray(data.deviceIds) && data.deviceIds.length
            ? data.deviceIds
            : [data.deviceId];

          statusHtml = ids.map(id => {
            const dev = devs.find(d => d.id == id);
            if (!dev?.attributes) return "";
            return attrsToShow.map(attr => {
              const v = dev.attributes[attr];
              if (v == null) return "";
              const name = dev.label || dev.name || id;
              return `<div class="current-value">Current ${name}: ${v}</div>`;
            }).join("");
          }).join("");
        }

        // Color preview
        let colorPreview = "";
        if (cmd.toLowerCase() === "setcolor" && data.color) {
          colorPreview = `<div style="
            margin-top:4px;
            width:30px; height:14px;
            border-radius:5px;
            background:${data.color};
            border:1px solid #555;
            display:inline-block;
          "></div>`;
        }

        // Locked icon
        const lockedHtml = data.locked
          ? '<div style="position:absolute;top:6px;right:8px;font-size:18px;color:#fa2b2b;" title="Locked">&#128274;</div>'
          : "";

        return `
          <div class="${tileClass}" ${errorStyle}>
            <b>Action</b><br>
            <span style="font-size:11px">
              ${label} ${cmd || ''} ${val || ''}<br><hr>
            </span>
            ${statusHtml}
            ${colorPreview}
            ${data.locked ? `<div style="position:absolute;top:6px;right:8px;font-size:18px;color:#fa2b2b;" title="Locked">&#128274;</div>` : ""}
          </div>`;
      }
    }

    function updateTileHtml(node) {
      if (editor && typeof editor.updateNodeHtmlFromId === "function") {
        editor.updateNodeHtmlFromId(node.id, nodeTileHtml(node.name, node.data, node.id));
      }
    }

    function updateMultiSelectUI() {
      document.querySelectorAll('.drawflow-node').forEach(el => {
        const nodeId = el.id.replace(/^node-/, "");
        if (window._multiSelectedNodes && window._multiSelectedNodes.has(nodeId)) {
          el.classList.add('multi-selected');
        } else {
          el.classList.remove('multi-selected');
        }
      });
    }

    document.addEventListener("DOMContentLoaded", function () {
      // --- Wait for credentials autofill, then auto-load globals ---
      function tryAutoLoadGlobalsWhenReady(retries = 30) {
        const appIdEl = document.getElementById("hubitatAppId");
        const tokenEl = document.getElementById("hubitatToken");
        if (appIdEl && tokenEl && appIdEl.value && tokenEl.value) {
          autoLoadGlobalVarsFromHubitat();
        } else if (retries > 0) {
          setTimeout(() => tryAutoLoadGlobalsWhenReady(retries - 1), 200);
        }
      }
      tryAutoLoadGlobalsWhenReady();

      function rememberInput(inputId, storageKey) {
        const el = document.getElementById(inputId);
        if (localStorage.getItem(storageKey)) {
          el.value = localStorage.getItem(storageKey);
        }
        el.addEventListener("input", function() {
          localStorage.setItem(storageKey, el.value.trim());
        });
      }
      rememberInput("hubitatAppId", "hubitatAppId");
      rememberInput("hubitatToken", "hubitatToken");

      

      // Auto-load devices if credentials are filled (with delayed check for browser autofill)
      setTimeout(() => {
        const appIdEl = document.getElementById("hubitatAppId");
        const tokenEl = document.getElementById("hubitatToken");
        if (appIdEl.value && tokenEl.value) {
          (async () => {
        if (!hubitatCredentialsAreValid(true)) return;
        logAction("loadDevices button clicked.");
        await fetchModesFromAppFile();
        devices = await fetchDevicesFromApp();
        devices.forEach(dev => {
          if (Array.isArray(dev.attributes)) {
            const attrMap = {};
            dev.attributes.forEach(a => {
              if (a.name !== undefined) attrMap[a.name] = a.currentValue;
            });
            dev.attributes = attrMap;
          }
        });
        devices.push(TIME_DEVICE);
        devices.push(MODE_DEVICE);
        devices.push(VARIABLE_DEVICE);
        window.devices = devices;

        // Set current mode on Home Location device
        const currentModeObj = (window.hubitatModes || []).find(m => m.id === "current");
        const currentMode = currentModeObj ? currentModeObj.name : "";
        const modeDev = window.devices.find(d => d.id === "__mode__");
        if (modeDev) {
          modeDev.attributes.mode = currentMode;
        }

        // --- PATCH: force field sync after import ---
        setTimeout(() => {
          // 1. Always pick a node to edit
          let selected = editor.selected_id;
          if (!selected) {
            // If nothing selected, pick the first node in the flow (if any)
            const allIds = editor.drawflow && getHomeFrom(editor) && getHomeDataFrom(editor)
              ? Object.keys(getHomeDataFrom(editor))
              : [];
            if (allIds.length) {
              selected = allIds[0];
              editor.selected_id = selected;
            }
          }
          if (selected) {
            // Always refresh the editor panel to match current node data
            window.renderEditor(editor.getNodeFromId(selected));
          } else {
            document.getElementById("nodeEditor").innerHTML = "Click a node to edit";
          }
        }, 10);
        logAction("Devices loaded: " + devices.length);
      
          })();
        }
      
      try{ window.__autoRefresh = false; }catch(_){}
      }, 350);

      window.ATTRIBUTE_KNOWN_VALUES = {
        "contact":        ["open", "closed"],
        "switch":         ["on", "off"],
        "door":           ["open", "closed", "unknown"],
        "lock":           ["locked", "unlocked", "unknown"],
        "motion":         ["active", "inactive"],
        "presence":       ["present", "not present"],
        "water":          ["wet", "dry"],
        "smoke":          ["clear", "detected", "tested"],
        "carbonMonoxide": ["clear", "detected", "tested"],
        "acceleration":   ["active", "inactive"],
        "tamper":         ["clear", "detected"],
        "shade":          ["open", "closed", "partially open", "unknown"],
        "windowShade":    ["open", "closed", "partially open", "unknown"],
        "thermostatMode": [
          "off", "heat", "emergency heat", "cool", "auto", "fan only", "dry", "eco"
        ],
        "thermostatOperatingState": [
          "heating", "cooling", "idle", "pending heat", "pending cool", "fan only", "vent economizer"
        ],
        "thermostatFanMode": [
          "auto", "on", "circulate"
        ],
        "alarm":          ["off", "strobe", "siren", "both"],
        "valve":          ["open", "closed"],
        "button":         ["pushed", "held", "doubleTapped", "released"],
        "temperature":    [],
        "humidity":       [],
        "illuminance":    [],
        "energy":         [],
        "power":          [],
        "level":          []
      };

      function getSortedDevicesWithSpecials(devices) {
        const modeDevice = devices.find(d => d.id === "__mode__");
        const timeDevice = devices.find(d => d.id === "__time__");
        const variableDevice = devices.find(d => d.id === "__variable__");
        const realDevices = devices
          .filter(d => d.id !== "__mode__" && d.id !== "__time__" && d.id !== "__variable__")
          .slice()
          .sort((a, b) => {
            const aLabel = (a.label || a.name || a.id || "").toLowerCase();
            const bLabel = (b.label || b.name || b.id || "").toLowerCase();
            if (aLabel < bLabel) return -1;
            if (aLabel > bLabel) return 1;
            return 0;
          });
        const arr = [];
        if (modeDevice) arr.push(modeDevice);
        if (timeDevice) arr.push(timeDevice);
        if (variableDevice) arr.push(variableDevice);
        if (realDevices.length) arr.push({ id: "__divider__", label: "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ" });
        arr.push(...realDevices);
        return arr;
      }

      /**
       * Renders a device search/filter + (single/multi) select picker.
       * @param {HTMLElement} el - Where to append the picker.
       * @param {Array} devices - List of all devices.
       * @param {Array} selectedIds - Array of currently selected device IDs.
       * @param {Function} onChange - Called with (newSelectedIds, newDeviceLabels) when selection changes.
       * @param {boolean} multi - true for multi-select, false for single-select
       */
      function renderDevicePicker(el, devices, selectedIds, onChange, multi = true) {
        // Remove old content if called multiple times
        const existing = el.querySelector('.device-picker-block');
        if (existing) existing.remove();

        // Picker wrapper
        const pickerWrap = document.createElement("div");
        pickerWrap.className = "device-picker-block";
        pickerWrap.style = "margin-bottom:8px";

        // Search input
        const devFilterInput = document.createElement("input");
        devFilterInput.type = "text";
        devFilterInput.placeholder = "Search devices‚Ä¶";
        devFilterInput.style = "width:98%;margin-bottom:3px;padding:3px 7px;border-radius:7px;border:1px solid #333;font-size:13px;";
        pickerWrap.appendChild(devFilterInput);

        // Select dropdown
        const devSelect = document.createElement("select");
        devSelect.multiple = multi;
        devSelect.size = Math.min(10, devices.length);
        devSelect.style.width = "98%";
        devSelect.style.display = "block";
        devSelect.style.marginBottom = "12px";
        pickerWrap.appendChild(devSelect);

        function populate(filtered) {
          // Remember current scroll position and selected items
          const prevScroll   = devSelect.scrollTop;
          const prevSelected = Array.from(devSelect.selectedOptions).map(o => o.value);

          // Clear out old options and rebuild from `filtered`
          devSelect.innerHTML = "";
          getSortedDevicesWithSpecials(filtered).forEach((d) => {
            if (d.id === "__divider__") {
              const divider = document.createElement("option");
              divider.disabled    = true;
              divider.textContent = d.label;
              divider.style.background = "#444";
              devSelect.appendChild(divider);
            } else {
              const opt = document.createElement("option");
              opt.value       = d.id;
              opt.textContent = d.label || d.name || d.id;
              if (selectedIds.includes(d.id)) opt.selected = true;
              devSelect.appendChild(opt);
            }
          });

          // Restore scroll position
          devSelect.scrollTop = prevScroll;
        }

        // Filter handler
        devFilterInput.oninput = function() {
          const filter = devFilterInput.value.trim().toLowerCase();
          if (!filter) { populate(devices); return; }
          const filtered = devices.filter(d =>
            (d.label || d.name || d.id || "").toLowerCase().includes(filter) ||
            d.id === "__time__" || d.id === "__mode__"
          );
          populate(filtered);
        };

        // Initial population
        populate(devices);

        // This is the CRITICAL PART for ctrl-click multi-select:
        devSelect.onchange = () => {
          let newSelected = Array.from(devSelect.selectedOptions).map(opt => opt.value);
          onChange(newSelected, newSelected.map(
            id => (devices.find(d => d.id == id) || {}).label || id
          ));
        };

        el.appendChild(pickerWrap);
      }

      function renderConditionDeviceFields(el, node, devices, editor, nodeTileHtml) {
        // clear the container
        el.innerHTML = "";

        // ensure deviceIds array
        const devIds = Array.isArray(node.data.deviceIds)
          ? node.data.deviceIds
          : node.data.deviceId
            ? [node.data.deviceId]
            : [];
        // Special case: Variable pseudo-device
        if (devIds.length === 1 && devIds[0] === "__variable__") {
          // Ensure single-select semantics for variable conditions
          node.data.deviceId = "__variable__";
          // Render the dedicated Variable UI (name dropdown, comparator, value)
          if (typeof buildVariableTriggerEditor === "function") {
            buildVariableTriggerEditor(el, node, false);
            return;
          }
        }


        // collect shared attribute names across selected devices
        const sharedAttrs = Array.from(new Set(
          devIds.flatMap(id => {
            const dev = devices.find(d => d.id === id);
            return dev && dev.attributes
              ? Object.keys(dev.attributes)
              : [];
          })
        )).sort();

        // ‚îÄ‚îÄ ATTRIBUTE LABEL ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        const attrLabel = document.createElement("label");
        attrLabel.textContent = "Attribute";
        attrLabel.style.display = "block";
        el.appendChild(attrLabel);

        // ‚îÄ‚îÄ ATTRIBUTE SELECT ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        const attrSel = document.createElement("select");
        attrSel.style = "display:block;margin-bottom:12px";
        attrSel.innerHTML =
          `<option value="" ${!node.data.attribute ? "selected" : ""}>(select)</option>` +
          sharedAttrs
            .map(a => `<option value="${a}" ${node.data.attribute === a ? "selected" : ""}>${a}</option>`)
            .join("");
        attrSel.onchange = () => {
          node.data.attribute  = attrSel.value;
          node.data.logic      = "";
          node.data.comparator = "";
          node.data.value      = "";
          editor.updateNodeDataFromId(node.id, node.data);
          renderConditionDeviceFields(el, node, devices, editor, nodeTileHtml);
          markFlowNeedsSave(true);
        };
        el.appendChild(attrSel);

        // ‚îÄ‚îÄ LOGIC LABEL ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        const logicLabel = document.createElement("label");
        logicLabel.textContent = "Logic";
        logicLabel.style.display = "block";
        el.appendChild(logicLabel);

        // ‚îÄ‚îÄ LOGIC SELECT ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        const logicSel = document.createElement("select");
        logicSel.style = "display:block;margin-bottom:12px";
        logicSel.innerHTML =
          `<option value="" ${!node.data.logic ? "selected" : ""}>(select)</option>` +
          ["and", "or"]
            .map(l => `<option value="${l}" ${node.data.logic === l ? "selected" : ""}>${l.toUpperCase()}</option>`)
            .join("");
        logicSel.onchange = () => {
          node.data.logic = logicSel.value;
          editor.updateNodeDataFromId(node.id, node.data);
          renderConditionDeviceFields(el, node, devices, editor, nodeTileHtml);
          markFlowNeedsSave(true);
        };
        el.appendChild(logicSel);

        // ‚îÄ‚îÄ COMPARATOR LABEL ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        const cmpLabel = document.createElement("label");
        cmpLabel.textContent = "Comparator";
        cmpLabel.style.display = "block";
        el.appendChild(cmpLabel);

        // ‚îÄ‚îÄ COMPARATOR SELECT ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        const cmpSel = document.createElement("select");
        cmpSel.style = "display:block;margin-bottom:12px";
        cmpSel.innerHTML =
          `<option value="" ${!node.data.comparator ? "selected" : ""}>(select)</option>` +
          ["==","!=","<","<=",">",">=","between","changes"]
            .map(c => {
              const label = c === "==" ? "equals" : c;
              return `<option value="${c}" ${node.data.comparator === c ? "selected" : ""}>${label}</option>`;
            })
            .join("");
        cmpSel.onchange = () => {
          node.data.comparator = cmpSel.value;
          node.data.value      = "";
          editor.updateNodeDataFromId(node.id, node.data);
          renderConditionDeviceFields(el, node, devices, editor, nodeTileHtml);
          markFlowNeedsSave(true);
        };
        el.appendChild(cmpSel);

        // ‚îÄ‚îÄ VALUE INPUT(S) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        if (node.data.comparator === "between") {
          // two inputs for range
          const [start = "", end = ""] = Array.isArray(node.data.value) ? node.data.value : ["",""];
          // start value
          const startInput = document.createElement("input");
          startInput.type  = "text";
          startInput.placeholder = "Start value";
          startInput.value = start;
          startInput.style = "display:block;margin-bottom:8px";
          startInput.onchange = () => {
            node.data.value = [startInput.value, end];
            editor.updateNodeDataFromId(node.id, node.data);
            markFlowNeedsSave(true);
          };
          el.appendChild(startInput);
          // end value
          const endInput = document.createElement("input");
          endInput.type  = "text";
          endInput.placeholder = "End value";
          endInput.value = end;
          endInput.style = "display:block;margin-bottom:12px";
          endInput.onchange = () => {
            node.data.value = [startInput.value, endInput.value];
            editor.updateNodeDataFromId(node.id, node.data);
            markFlowNeedsSave(true);
          };
          el.appendChild(endInput);
        }
        
        const known = ATTRIBUTE_KNOWN_VALUES[node.data.attribute] || [];
        if (known.length) {
          const valSel = document.createElement("select");
          valSel.style = "display:block;margin-bottom:12px";
          valSel.innerHTML =
            `<option value="">(select)</option>` +
            known
              .map(v =>
                `<option value="${v}"${node.data.value === v ? " selected" : ""}>${v}</option>`
              )
              .join("");
          valSel.onchange = () => {
            node.data.value = valSel.value;
            editor.updateNodeDataFromId(node.id, node.data);
            markFlowNeedsSave(true);
          };
          el.appendChild(valSel);
        }
        else if (node.data.comparator === "between") {
          renderValueField(el, node, knownValues, onChange, true);
        }
        else if (node.data.comparator && node.data.comparator !== "changes") {
          const valInput = document.createElement("input");
          valInput.type = "text";
          valInput.placeholder = "Value";
          valInput.value = node.data.value || "";
          valInput.style = "display:block;margin-bottom:12px";
          valInput.onchange = () => {
            node.data.value = valInput.value;
            editor.updateNodeDataFromId(node.id, node.data);
            markFlowNeedsSave(true);
          };
          el.appendChild(valInput);
        }

        // finally, update the node's HTML preview
        const tileHtml = nodeTileHtml(node.name, node.data, node.id);
        editor.updateNodeHtmlFromId(node.id, tileHtml);
      }

      window.renderEditor = function renderEditor(node) {
        // Countdown editor (MM-DD fields; no date picker). Label on own line; inputs next line.
        if (node && node.name === "countdown") {
          const el = document.getElementById("nodeEditor");
          if (el) el.innerHTML = "";
          const container = el || document.createElement("div");

          const h = document.createElement("div");
          h.innerHTML = "Countdown";
          h.style.marginBottom = "8px";
          container.appendChild(h);

          // Variable Name
          const lbl1 = document.createElement("label");
          lbl1.textContent = "New Variable Name";
          lbl1.style.display = "block";
          container.appendChild(lbl1);

          const nameInput = document.createElement("input");
          nameInput.type = "text";
          nameInput.placeholder = "e.g., VacationDaysLeft";
          nameInput.value = (node.data && node.data.varName) || "";
          nameInput.style = "display:block;margin-bottom:12px";
          nameInput.oninput = () => {
            node.data = node.data || {};
            node.data.varName = nameInput.value;
            if (window.editor && typeof window.editor.updateNodeDataFromId === 'function') {
              editor.updateNodeDataFromId(node.id, node.data);
            }
            try { markFlowNeedsSave(true); } catch(_){}
            try { editor.updateNodeHtmlFromId(node.id, nodeTileHtml(node.name, node.data, node.id)); } catch(_){}
          };
          container.appendChild(nameInput);

          // Label on its own line
          const lbl2 = document.createElement("label");
          lbl2.textContent = "Target Date (MM-DD)";
          lbl2.style.display = "block";
          lbl2.style.margin = "6px 0 6px 0";
          container.appendChild(lbl2);

          // Inputs on the next line
          const row = document.createElement("div");
          row.style = "display:flex; gap:8px; align-items:center; margin: 0 0 12px 0;";

          const mm = document.createElement("input");
          mm.type = "text";
          mm.placeholder = "MM";
          mm.maxLength = 2;
          mm.style = "width:46px;text-align:center";

          const dd = document.createElement("input");
          dd.type = "text";
          dd.placeholder = "DD";
          dd.maxLength = 2;
          dd.style = "width:46px;text-align:center";

          // Init values
          (function(){
            const v = (node.data && node.data.targetDate) || "";
            if (/^[0-1]\d-\d\d$/.test(v)) {
              mm.value = v.slice(0,2);
              dd.value = v.slice(3,5);
            }
          })();

          function digits2(el) {
            // keep only digits, up to 2 chars
            const s = String(el.value || "").replace(/\D/g, "").slice(0,2);
            el.value = s;
            return s;
          }
          function maxDayFor(month){
            const m = parseInt(month||"0",10);
            if ([4,6,9,11].includes(m)) return 30;
            if (m === 2) return 29;
            return 31;
          }
          function pad2(n) { n = parseInt(n||"0",10)||0; return String(n).padStart(2,"0").slice(-2); }

          function saveMD(padOnSave){
            let M = digits2(mm);
            let D = digits2(dd);
            if (padOnSave) {
              if (M.length === 1) M = pad2(M);
              if (D.length === 1) D = pad2(D);
            }
            // validate ranges if both present
            if (M.length === 2) {
              let mInt = parseInt(M,10);
              if (mInt < 1) M = "01";
              if (mInt > 12) M = "12";
            }
            if (M.length === 2 && D.length === 2) {
              const max = maxDayFor(parseInt(M,10));
              let dInt = parseInt(D,10);
              if (dInt < 1) D = "01";
              if (dInt > max) D = pad2(max);
            }
            // only save when we have both 2 digits
            if (M.length === 2 && D.length === 2) {
              node.data = node.data || {};
              node.data.targetDate = M + "-" + D;
              if (window.editor && typeof window.editor.updateNodeDataFromId === 'function') {
                editor.updateNodeDataFromId(node.id, node.data);
              }
              try { markFlowNeedsSave(true); } catch(_){}
              try { editor.updateNodeHtmlFromId(node.id, nodeTileHtml(node.name, node.data, node.id)); } catch(_){}
            }
          }

          // While typing: accept digits only; no padding until blur
          mm.addEventListener("input", () => { digits2(mm); /* don't pad */ });
          dd.addEventListener("input", () => { digits2(dd); /* don't pad */ });

          // On blur: pad & clamp, then save
          mm.addEventListener("blur", () => { saveMD(true); });
          dd.addEventListener("blur", () => { saveMD(true); });

          row.appendChild(mm);
          row.appendChild(document.createTextNode("-"));
          row.appendChild(dd);
          container.appendChild(row);

          try { editor.updateNodeHtmlFromId(node.id, nodeTileHtml(node.name, node.data, node.id)); } catch(_){}
          return;
        }

        if (node && node.name === "countdown") {
          const el = document.getElementById("nodeEditor");
          if (el) el.innerHTML = "";
          const container = el || document.createElement("div");

          const h = document.createElement("div");
          h.innerHTML = `<b>Countdown</b>`;
          h.style.marginBottom = "8px";
          container.appendChild(h);

          const lbl1 = document.createElement("label");
          lbl1.textContent = "New Variable Name";
          lbl1.style.display = "block";
          container.appendChild(lbl1);

          const nameInput = document.createElement("input");
          nameInput.type = "text";
          nameInput.placeholder = "e.g., VacationDaysLeft";
          nameInput.value = (node.data && node.data.varName) || "";
          nameInput.style = "display:block;margin-bottom:12px";
          nameInput.onchange = () => {
            node.data = node.data || {};
            node.data.varName = nameInput.value;
            if (window.editor && typeof window.editor.updateNodeDataFromId === 'function') {
              editor.updateNodeDataFromId(node.id, node.data);
            }
            try { markFlowNeedsSave(true); } catch(_){}
            try { editor.updateNodeHtmlFromId(node.id, nodeTileHtml(node.name, node.data, node.id)); } catch(_){}
          };
          container.appendChild(nameInput);

          const lbl2 = document.createElement("label");
          lbl2.textContent = "Target Date";
          lbl2.style.display = "block";
          container.appendChild(lbl2);

          const dateInput = document.createElement("input");
          dateInput.type = "date";
          dateInput.value = (node.data && node.data.targetDate) || "";
          dateInput.style = "display:block;margin-bottom:12px";
          dateInput.onchange = () => {
            node.data = node.data || {};
            node.data.targetDate = dateInput.value;
            if (window.editor && typeof window.editor.updateNodeDataFromId === 'function') {
              editor.updateNodeDataFromId(node.id, node.data);
            }
            try { markFlowNeedsSave(true); } catch(_){}
            try { editor.updateNodeHtmlFromId(node.id, nodeTileHtml(node.name, node.data, node.id)); } catch(_){}
          };
          container.appendChild(dateInput);

          try { editor.updateNodeHtmlFromId(node.id, nodeTileHtml(node.name, node.data, node.id)); } catch(_){}
          return;
        }

        // If this is a Schedule node, show a message in the Node Editor instead of opening any popup
        if (node && (node.type === 'schedule' || node.name === 'schedule' || node.title === 'Schedule Trigger' || node.label === 'Schedule')) {
          const msg = `<div style="margin:12px 8px;padding:10px;border:1px dashed #888;border-radius:8px;font-size:14px;line-height:1.4;">
            <b>Double-click Tile to open Schedule Editor</b>
          </div>`;
          // ensure header exists, then append message
          nodeEditor.innerHTML += msg;
          return;
        }

        const panel = document.getElementById("nodeEditor");
        if (panel) panel.style.display = '';
        if (!node) {
          document.getElementById("nodeEditor").innerHTML = "Click a node to edit";
          return;
        }
        const el = document.getElementById("nodeEditor");
        el.innerHTML = "";

        const pickerDevices = getSortedDevicesWithSpecials(window.devices || []);
        if (
          ["device", "condition", "eventTrigger", "notMatchingVar"].includes(node.name)
        ) {
          if (!Array.isArray(node.data.deviceIds)) node.data.deviceIds = [];
          if (node.data.deviceId && node.data.deviceIds.length === 0) {
            node.data.deviceIds = [node.data.deviceId];
          }
          if (node.data.deviceIds.length === 1) {
            node.data.deviceId = node.data.deviceIds[0];
          }
        }

        if (node.name === "eventTrigger") {
          // Device picker always rendered first!
          renderDevicePickerSection(
            el,
            node,
            pickerDevices,
            (ids, labels) => {
              node.data.deviceIds = ids;
              node.data.deviceId = ids[0] || "";
              node.data.attribute = "";
              node.data.comparator = "";
              node.data.value = "";
              editor.updateNodeDataFromId(node.id, node.data);
              markFlowNeedsSave(true);
              
            },
            true // multi-select ENABLED
          );

          // If Variable is selected, add variable picker BELOW device picker
          if (node.data.deviceId === "__variable__") {
            buildVariableTriggerEditor(el, node, true); // append variable picker
            return;
          }
        }

        if (node.name === "condition") {
          // Device picker always rendered first!
          renderDevicePickerSection(
            el,
            node,
            getSortedDevicesWithSpecials(window.devices || []),
            (ids, labels) => {
              node.data.deviceIds = ids;
              node.data.deviceId = ids[0] || "";
              node.data.attribute = "";
              node.data.comparator = "";
              node.data.value = "";
              editor.updateNodeDataFromId(node.id, node.data);
              markFlowNeedsSave(true);
              
            },
            true // multi-select ENABLED
          );

          // If Variable is selected, add variable picker BELOW device picker
          if (node.data.deviceId === "__variable__") {
            buildVariableTriggerEditor(el, node, true);
            return;
          }
        }

        // ************************************
        // --- SHARED HELPERS ---
        // ***********************************
        function getPickerDevices(devices) {
          const homeLoc = devices.find(d => d.id === "__mode__");
          const timeDev = devices.find(d => d.id === "__time__");
          const varDev = { id: "__variable__", label: "Variable", name: "Variable" };
          const rest = devices.filter(d => !["__mode__", "__time__"].includes(d.id));
          let pickerDevices = [];
          if (homeLoc) pickerDevices.push(homeLoc);
          if (timeDev) pickerDevices.push(timeDev);
          pickerDevices.push(varDev);
          if (rest.length) pickerDevices.push({ id: "__divider__", label: "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ" });
          pickerDevices = pickerDevices.concat(rest.sort((a, b) => {
            const la = (a.label || a.name || a.id).toLowerCase();
            const lb = (b.label || b.name || b.id).toLowerCase();
            return la.localeCompare(lb);
          }));
          return pickerDevices;
        }

        function renderDevicePickerSection(el, node, devices, onChange, multiSelect=true) {
          const devLabel = document.createElement("label");
          devLabel.textContent = "Device(s)";
          devLabel.style.display = "block";
          el.appendChild(devLabel);
          renderDevicePicker(
            el,
            devices,
            Array.isArray(node.data.deviceIds)
              ? node.data.deviceIds
              : node.data.deviceId ? [node.data.deviceId] : [],
            onChange,
            multiSelect
          );
        }

        // ************************************
        // DEVICE NODE (Action)
        // ************************************
        if (node.name === "device") {
          // 2) Normalize deviceIds / deviceId
          if (!Array.isArray(node.data.deviceIds)) node.data.deviceIds = [];
          node.data.deviceId = node.data.deviceIds.length === 1
            ? node.data.deviceIds[0]
            : "";

          // 3) Prepare full device list for the picker
          const allDevices    = Array.isArray(window.devices) ? window.devices : [];
          const pickerDevices = getPickerDevices(allDevices);

          // 4) Helper to build Command ‚Üí Value fields
          function buildDeviceActionFields(container) {
            // Compute shared commands
            const selected = node.data.deviceIds
              .map(id => allDevices.find(d => d.id == id))
              .filter(Boolean);
            let shared = Array.isArray(selected[0]?.commands)
              ? selected[0].commands.slice()
              : [];
            for (let i = 1; i < selected.length; i++) {
              if (Array.isArray(selected[i].commands)) {
                shared = shared.filter(cmd =>
                  selected[i].commands.includes(cmd)
                );
              } else {
                shared = [];
              }
            }
            if (shared.includes("on") && shared.includes("off") && !shared.includes("toggle")) {
              shared.push("toggle");
            }

            // Command picker
            const cmdLbl = document.createElement("label");
            cmdLbl.textContent = "Command";
            cmdLbl.style.display = "block";
            container.appendChild(cmdLbl);

            const cmdSel = document.createElement("select");
            cmdSel.style = "display:block;margin-bottom:12px";
            cmdSel.innerHTML =
              `<option value="">Pick a command‚Ä¶</option>` +
              shared.map(c => `<option value="${c}">${c}</option>`).join("");
            cmdSel.value = node.data.command;
            cmdSel.onchange = () => {
              node.data.command = cmdSel.value;
              node.data.value   = "";
              editor.updateNodeDataFromId(node.id, node.data);
              editor.updateNodeHtmlFromId(node.id, nodeTileHtml(node.name, node.data, node.id));
              // rebuild just the Value UI
              container.innerHTML = "";
              buildDeviceActionFields(container);
              markFlowNeedsSave(true);
            };
            container.appendChild(cmdSel);

            // Value label
            if (node.data.command) {
              const valLbl = document.createElement("label");
              valLbl.textContent = "Value";
              valLbl.style.display = "block";
              container.appendChild(valLbl);

              // Value input/picker
              const numericCmds = [
                "setLevel","setTemperature","setVolume",
                "setPosition","setHue","setSaturation","setSpeed"
              ];
              if (numericCmds.includes(node.data.command)) {
                const inp = document.createElement("input");
                inp.type  = "number";
                inp.value = node.data.value || "";
                inp.style = "display:block;margin-bottom:12px";
                inp.oninput = () => {
                  node.data.value = inp.value;
                  editor.updateNodeDataFromId(node.id, node.data);
                  editor.updateNodeHtmlFromId(node.id, nodeTileHtml(node.name, node.data, node.id));
                  markFlowNeedsSave(true);
                };
                container.appendChild(inp);
              }
              else if (node.data.command === "setColor") {
                const inp = document.createElement("input");
                inp.type  = "color";
                inp.value = node.data.value || "#ffffff";
                inp.style = "display:block;margin-bottom:12px";
                inp.oninput = () => {
                  node.data.value = inp.value;
                  node.data.color = inp.value;
                  editor.updateNodeDataFromId(node.id, node.data);
                  editor.updateNodeHtmlFromId(node.id, nodeTileHtml(node.name, node.data, node.id));
                  markFlowNeedsSave(true);
                };
                container.appendChild(inp);
              }
              else {
                const inp = document.createElement("input");
                inp.type  = "text";
                inp.value = node.data.value || "";
                inp.style = "display:block;margin-bottom:12px";
                inp.oninput = () => {
                  node.data.value = inp.value;
                  editor.updateNodeDataFromId(node.id, node.data);
                  editor.updateNodeHtmlFromId(node.id, nodeTileHtml(node.name, node.data, node.id));
                  markFlowNeedsSave(true);
                };
                container.appendChild(inp);
              }
            }
          }

          // 5) Render the Device(s) picker
          renderDevicePickerSection(
            el,
            node,
            pickerDevices,
            (newIds, newLabels) => {
              node.data.deviceIds   = newIds;
              node.data.deviceId    = newIds.length === 1 ? newIds[0] : "";
              node.data.deviceLabel = newLabels.join(", ");
              node.data.command     = "";
              node.data.value       = "";
              editor.updateNodeDataFromId(node.id, node.data);
              editor.updateNodeHtmlFromId(node.id, nodeTileHtml(node.name, node.data, node.id));
              // rebuild Command ‚Üí Value fields in place
              const div = document.getElementById("device-pickers-" + node.id);
              div.innerHTML = "";
              buildDeviceActionFields(div);
              markFlowNeedsSave(true);
            },
            true // multi-select
          );

          // 6) Container for Command ‚Üí Value
          const pickerDiv = document.createElement("div");
          pickerDiv.id    = "device-pickers-" + node.id;
          pickerDiv.style.marginTop = "8px";
          el.appendChild(pickerDiv);

          // 7) Initial build of Command ‚Üí Value
          buildDeviceActionFields(pickerDiv);

          return;
        }

        // ************************************
        // EVENT TRIGGER NODE
        // ************************************
        if (node.name === "eventTrigger") {
          // 2) Normalize device data
          if (!Array.isArray(node.data.deviceIds)) node.data.deviceIds = [];
          node.data.deviceId = node.data.deviceIds.length === 1
            ? node.data.deviceIds[0]
            : "";

          // 3) Full list for the picker
          const allDevices    = Array.isArray(window.devices) ? window.devices : [];
          const pickerDevices = getPickerDevices(allDevices);

          // ‚îÄ‚îÄ DEVICE(S) PICKER ‚îÄ‚îÄ
          renderDevicePickerSection(
            el,
            node,
            pickerDevices,
            (newIds, newLabels) => {
              node.data.deviceIds   = newIds;
              node.data.deviceId    = newIds.length === 1 ? newIds[0] : "";
              node.data.deviceLabel = newLabels.join(", ");
              // clear old condition fields
              node.data.attribute   = "";
              node.data.comparator  = "";
              node.data.value       = "";

              editor.updateNodeDataFromId(node.id, node.data);
              editor.updateNodeHtmlFromId(
                node.id,
                nodeTileHtml(node.name, node.data, node.id)
              );

              // rebuild only the pickers in that container
              const pickerDiv = document.getElementById("trigger-pickers-" + node.id);
              pickerDiv.innerHTML = "";
              if (!buildTimeDevicePicker(pickerDiv, node)) {
                renderConditionDeviceFields(
                  pickerDiv,
                  node,
                  pickerDevices,
                  editor,
                  nodeTileHtml
                );
              }
              markFlowNeedsSave(true);
              
            },
            true // multi-select
          );

          // ‚îÄ‚îÄ PICKER CONTAINER ‚îÄ‚îÄ
          const pickerDiv = document.createElement("div");
          pickerDiv.id    = "trigger-pickers-" + node.id;
          pickerDiv.style.marginTop = "8px";
          el.appendChild(pickerDiv);

          // 4) Initial build of time-or-condition fields
          if (buildTimeDevicePicker(pickerDiv, node)) {
            return;
          }
          renderConditionDeviceFields(
            pickerDiv,
            node,
            pickerDevices,
            editor,
            nodeTileHtml
          );
          return;
        }

        // ************************************
        // CONDITION NODE
        // ************************************
        if (node.name === "condition") {
          // 1) Normalize data array
          if (!Array.isArray(node.data.deviceIds)) node.data.deviceIds = [];
          node.data.deviceId = node.data.deviceIds.length === 1
            ? node.data.deviceIds[0]
            : "";

          // 2) Prepare full device list
          const allDevices    = Array.isArray(window.devices) ? window.devices : [];
          const pickerDevices = getPickerDevices(allDevices);

          // ‚îÄ‚îÄ DEVICE(S) PICKER ‚îÄ‚îÄ
          renderDevicePickerSection(
            el,
            node,
            pickerDevices,
            (newIds, newLabels) => {
              // update selection
              node.data.deviceIds   = newIds;
              node.data.deviceId    = newIds.length === 1 ? newIds[0] : "";
              node.data.deviceLabel = newLabels.join(", ");
              // clear previous fields
              node.data.attribute   = "";
              node.data.comparator  = "";
              node.data.value       = "";

              editor.updateNodeDataFromId(node.id, node.data);
              editor.updateNodeHtmlFromId(
                node.id,
                nodeTileHtml(node.name, node.data, node.id)
              );

              // 3) Rebuild only the condition pickers in place
              const pickerDiv = document.getElementById("condition-pickers-" + node.id);
              pickerDiv.innerHTML = "";
              if (node.data.deviceId === "__variable__") {
                buildVariableTriggerEditor(pickerDiv, node, true);
              } else if (!buildTimeDevicePicker(pickerDiv, node)) {
                renderConditionDeviceFields(
                  pickerDiv,
                  node,
                  pickerDevices,
                  editor,
                  nodeTileHtml
                );
              }
              markFlowNeedsSave(true);
            },
            true // multi-select
          );

          // ‚îÄ‚îÄ PICKER CONTAINER ‚îÄ‚îÄ
          const pickerDiv = document.createElement("div");
          pickerDiv.id    = "condition-pickers-" + node.id;
          pickerDiv.style.marginTop = "8px";
          el.appendChild(pickerDiv);

          // 4) Initial build of time-or-condition fields
          if (node.data.deviceId === "__variable__") {
            buildVariableTriggerEditor(pickerDiv, node, true);
            return;
          }
          if (buildTimeDevicePicker(pickerDiv, node)) {
            return;
          }
          renderConditionDeviceFields(
            pickerDiv,
            node,
            pickerDevices,
            editor,
            nodeTileHtml
          );
          return;
        }

        if (node.name === "delay") {
          el.innerHTML = ""; // Clear sidebar panel

          const msLabel = document.createElement("label");
          msLabel.textContent = "Milliseconds";
          msLabel.style.display = "block";
          el.appendChild(msLabel);

          const msInput = document.createElement("input");
          msInput.type = "number";
          msInput.min = 0;
          msInput.step = 1;
          msInput.value = typeof node.data.ms === "number" ? node.data.ms : (parseInt(node.data.ms) || 1000);
          msInput.style.display = "block";
          msInput.style.marginBottom = "12px";
          msInput.oninput = () => {
            node.data.ms = parseInt(msInput.value) || 0;
            editor.updateNodeDataFromId(node.id, node.data);
            editor.updateNodeHtmlFromId(node.id, nodeTileHtml(node.name, node.data, node.id));
            markFlowNeedsSave(true);
          };
          el.appendChild(msInput);
        }

        if (node.name === "delayMin") {
          const el = document.getElementById("nodeEditor");
          el.innerHTML = "<b>Delay (Minutes)</b><br><br>";

          const minLabel = document.createElement("label");
          minLabel.textContent = "Delay (minutes): ";
          el.appendChild(minLabel);

          const minInput = document.createElement("input");
          minInput.type = "number";
          minInput.min = 1;
          minInput.value = node.data.delayMin || 1;
          minInput.style.width = "60px";
          minInput.oninput = () => {
            node.data.delayMin = Number(minInput.value) || 1;
            editor.updateNodeDataFromId(node.id, node.data);
            editor.updateNodeHtmlFromId(node.id, nodeTileHtml(node.name, node.data, node.id));
            markFlowNeedsSave(true);
          };
          el.appendChild(minInput);

          return;
        }

        if (node.name === "repeat") {
          el.innerHTML = "<b>Repeat Node</b><hr>";

          // ‚îÄ‚îÄ MODE SELECTOR ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
          const modeLabel = document.createElement("label");
          modeLabel.textContent = "Repeat mode:";
          modeLabel.style.display = "block";
          el.appendChild(modeLabel);

          const countRadio = document.createElement("input");
          countRadio.type = "radio";
          countRadio.name = "repeatMode";
          countRadio.value = "count";
          countRadio.id = `repeatModeCount-${node.id}`;
          el.appendChild(countRadio);
          const countLabel = document.createElement("label");
          countLabel.htmlFor = countRadio.id;
          countLabel.textContent = "Max repeats";
          countLabel.style.margin = "0 12px 0 4px";
          el.appendChild(countLabel);

          const untilRadio = document.createElement("input");
          untilRadio.type = "radio";
          untilRadio.name = "repeatMode";
          untilRadio.value = "until";
          untilRadio.id = `repeatModeUntil-${node.id}`;
          el.appendChild(untilRadio);
          const untilLabel = document.createElement("label");
          untilLabel.htmlFor = untilRadio.id;
          untilLabel.textContent = "Until this happens";
          el.appendChild(untilLabel);

          // ‚îÄ‚îÄ Container for mode-specific UI ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
          const modeDiv = document.createElement("div");
          modeDiv.style.marginTop = "8px";
          el.appendChild(modeDiv);

          // ‚îÄ‚îÄ RENDER COUNT MODE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
          function renderCount() {
            modeDiv.innerHTML = "";
            const lbl = document.createElement("label");
            lbl.textContent = "Max repeats:";
            lbl.style.display = "block";
            modeDiv.appendChild(lbl);

            const inp = document.createElement("input");
            inp.type = "number";
            inp.min = 1;
            inp.max = 100;
            inp.value = node.data.repeatMax || 1;
            inp.style.width = "60px";
            inp.onchange = () => {
              node.data.repeatMax = parseInt(inp.value, 10) || 1;
              editor.updateNodeDataFromId(node.id, node.data);
              editor.updateNodeHtmlFromId(node.id, nodeTileHtml(node.name, node.data, node.id));
              markFlowNeedsSave(true);
            };
            modeDiv.appendChild(inp);
          }

          // ‚îÄ‚îÄ RENDER UNTIL MODE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
          function renderUntil() {
            modeDiv.innerHTML = "";

            // Device(s) picker
            const allDevices    = Array.isArray(window.devices) ? window.devices : [];
            const pickerDevices = getPickerDevices(allDevices);

            // ‚îÄ‚îÄ DEVICE(S) PICKER ‚îÄ‚îÄ
            renderDevicePickerSection(
              el,
              node,
              pickerDevices,
              (newIds, newLabels) => {
                // update selection
                node.data.deviceIds   = newIds;
                node.data.deviceId    = newIds.length === 1 ? newIds[0] : "";
                node.data.deviceLabel = newLabels.join(", ");
                // clear previous fields
                node.data.attribute   = "";
                node.data.comparator  = "";
                node.data.value       = "";

                editor.updateNodeDataFromId(node.id, node.data);
                editor.updateNodeHtmlFromId(
                  node.id,
                  nodeTileHtml(node.name, node.data, node.id)
                );

                // 3) Rebuild only the condition pickers in place
                const pickerDiv = document.getElementById("condition-pickers-" + node.id);
                pickerDiv.innerHTML = "";
                if (!buildTimeDevicePicker(pickerDiv, node)) {
                  renderConditionDeviceFields(
                    pickerDiv,
                    node,
                    pickerDevices,
                    editor,
                    nodeTileHtml
                  );
                }
                markFlowNeedsSave(true);
              },
              true // multi-select
            );

            // ‚îÄ‚îÄ PICKER CONTAINER ‚îÄ‚îÄ
            const pickerDiv = document.createElement("div");
            pickerDiv.id    = "condition-pickers-" + node.id;
            pickerDiv.style.marginTop = "8px";
            el.appendChild(pickerDiv);

            // 4) Initial build of time-or-condition fields
            if (buildTimeDevicePicker(pickerDiv, node)) {
              return;
            }
            renderConditionDeviceFields(
              pickerDiv,
              node,
              pickerDevices,
              editor,
              nodeTileHtml
            );
            return;
          }

          // ‚îÄ‚îÄ INITIALIZE & HOOK EVENTS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
          const initialMode = node.data.repeatMode === "until" ? "until" : "count";
          countRadio.checked = initialMode === "count";
          untilRadio.checked = initialMode === "until";
          node.data.repeatMode = initialMode;

          countRadio.onchange = () => {
            node.data.repeatMode = "count";
            editor.updateNodeDataFromId(node.id, node.data);
            renderCount();
            markFlowNeedsSave(true);
          };

          untilRadio.onchange = () => {
            node.data.repeatMode = "until";
            editor.updateNodeDataFromId(node.id, node.data);
            renderUntil();
            markFlowNeedsSave(true);
          };

          // Render the chosen panel
          if (initialMode === "until") {
            renderUntil();
          } else {
            renderCount();
          }

          return;
        }

        if (node.name === "setVariable") {
          el.innerHTML = "<b>Set Variable</b><br><br>";

          // Variable Name
          const varLabel = document.createElement("label");
          varLabel.textContent = "Variable Name";
          el.appendChild(varLabel);

          // dropdown of existing variables
          const varSelect = document.createElement("select");
          varSelect.style.width = "98%";

          // gather flow, global & hub var names
          const flowVars   = (window.flowVars?.getVars?.("flow")   || []);
          const globalVars = (window.flowVars?.getVars?.("global") || []);
          const varSourceMap = {}; // name -> "flow" or "global" or "hub"
          flowVars.forEach(v => varSourceMap[v.name] = "flow");
          globalVars.forEach(v => { if (!varSourceMap[v.name]) varSourceMap[v.name] = "global"; });
          const allVarNames = Array.from(new Set([...flowVars.map(v=>v.name), ...globalVars.map(v=>v.name)]))
            .filter(Boolean)
            .sort((a, b) => a.localeCompare(b, undefined, { sensitivity: 'base' }));

          // build options
          const noneOpt = document.createElement("option");
          noneOpt.value = "";
          noneOpt.textContent = "(select)";
          if (!node.data.varName) noneOpt.selected = true;
          varSelect.appendChild(noneOpt);

          allVarNames.forEach(name => {
            const opt = document.createElement("option");
            opt.value       = name;
            opt.textContent = (varSourceMap[name] === 'hub') ? `${name} (hub)` : name;
            if (node.data.varName === name) opt.selected = true;
            varSelect.appendChild(opt);
          });
          el.appendChild(varSelect);

          // --- THIS ENSURES IT SAVES EVERY TIME ---
          function saveVarNameChange() {
            node.data.varName = varSelect.value;
            editor.updateNodeDataFromId(node.id, node.data);
            editor.updateNodeHtmlFromId(node.id, nodeTileHtml(node.name, node.data, node.id));
            markFlowNeedsSave(true);
          }
          varSelect.onchange = saveVarNameChange;
          varSelect.onblur   = saveVarNameChange;

          // Value
          const valLabel = document.createElement("label");
          valLabel.textContent = "Value";
          el.appendChild(valLabel);

          const valInput = document.createElement("input");
          valInput.type = "text";
          valInput.placeholder = "Value to set";
          valInput.value = node.data.varValue || "";
          valInput.style.width = "98%";
          // CLEAN/SANITIZE ON INPUT: ONLY REMOVE QUOTES
          function stripQuotes(str) {
            return String(str).replace(/['"]/g, "");
          }
          valInput.oninput = () => {
            const sanitized = stripQuotes(valInput.value);
            if (valInput.value !== sanitized) valInput.value = sanitized; // auto-remove quotes as you type
            node.data.varValue = sanitized;
            editor.updateNodeDataFromId(node.id, node.data);
            editor.updateNodeHtmlFromId(node.id, nodeTileHtml(node.name, node.data, node.id));
            markFlowNeedsSave(true);
            updatePreview(); // update with sanitized value
          };
          el.appendChild(valInput);

          // Preview of result
          const previewChip = document.createElement("div");
          previewChip.className = "current-value";
          previewChip.style.marginLeft = "2px";
          previewChip.style.fontSize = "13px";
          previewChip.style.fontWeight = "bold";
          previewChip.style.cursor = "pointer";
          previewChip.title = "Preview of value/expression";
          el.appendChild(previewChip);

          function updatePreview() {
            if (window.flowVars && window.flowVars.evaluate) {
              try {
                const v = stripQuotes(valInput.value);
                if (!v.trim()) { previewChip.textContent = ""; previewChip.title = ""; return; }
                const result = window.flowVars.evaluate(v);
                let color = "#b7ffac";
                if (typeof result === "number") color = "#3af";
                else if (typeof result === "boolean") color = "#0c0";
                else if (typeof result === "string" && result.startsWith("ERR:")) color = "#f33";
                previewChip.textContent = "= " + result;
                previewChip.style.color = color;
                previewChip.title = (typeof result) + ": " + result;
              } catch(e) {
                previewChip.textContent = "ERR: " + e.message;
                previewChip.style.color = "#f33";
                previewChip.title = e.message;
              }
            }
          }
          valInput.addEventListener("input", updatePreview);
          updatePreview();

          return;
        }

        if (node.name === "comment") {
          el.innerHTML = `<label>Comment</label>`;
          let textarea = document.createElement("textarea");
          textarea.style = "width:98%;min-height:60px;font-size:13px;background:#fffbe6;color:#7d6103;border-radius:7px;margin-top:6px;";
          textarea.value = node.data.text || "";
          textarea.oninput = function () {
            node.data.text = textarea.value;
            editor.updateNodeDataFromId(node.id, node.data);
            editor.updateNodeHtmlFromId(node.id, nodeTileHtml(node.name, node.data, node.id));
            markFlowNeedsSave(true);
          };
          el.appendChild(textarea);
          return;
        }

        if (node.name === "notMatchingVar") {
          // 1) Normalize deviceIds
          if (!Array.isArray(node.data.deviceIds)) node.data.deviceIds = [];
          node.data.deviceId = node.data.deviceIds.length === 1
            ? node.data.deviceIds[0]
            : "";

          // 2) Device picker section (unchanged) ‚Ä¶
          const allDevices    = Array.isArray(window.devices) ? window.devices : [];
          const pickerDevices = getPickerDevices(allDevices);
          renderDevicePickerSection(
            el,
            node,
            pickerDevices,
            (newIds, newLabels) => {
              node.data.deviceIds   = newIds;
              node.data.deviceId    = newIds.length === 1 ? newIds[0] : "";
              node.data.deviceLabel = newLabels.join(", ");
              node.data.attribute   =
              node.data.comparator  =
              node.data.value       = "";
              editor.updateNodeDataFromId(node.id, node.data);
              editor.updateNodeHtmlFromId(node.id, nodeTileHtml(node.name, node.data, node.id));
              const pickDiv = document.getElementById("notmatchingvar-pickers-" + node.id);
              pickDiv.innerHTML = "";
              if (!buildTimeDevicePicker(pickDiv, node)) {
                renderConditionDeviceFields(pickDiv, node, pickerDevices, editor, nodeTileHtml);
              }
              markFlowNeedsSave(true);
            },
            true
          );

          // 3) Picker container (unchanged) ‚Ä¶
          const pickerDiv = document.createElement("div");
          pickerDiv.id    = "notmatchingvar-pickers-" + node.id;
          pickerDiv.style.marginTop = "8px";
          el.appendChild(pickerDiv);
          if (!buildTimeDevicePicker(pickerDiv, node)) {
            renderConditionDeviceFields(pickerDiv, node, pickerDevices, editor, nodeTileHtml);
          }

          // 4) Variable Name dropdown
          el.insertAdjacentHTML("beforeend", `
            <label>Variable Name</label>
            <select id="varName_${node.id}" style="width:98%; margin-bottom:12px;">
              ${(Array.from(new Set([
                  ...(window.FE_flowvars   || []).map(v => v.name),
                  ...(window.FE_global_var_names || [])
                ])).map(n => `
                  <option value="${n}" ${node.data.varName === n ? "selected" : ""}>${n}</option>
                `).join(""))}
            </select>
          `);
          document.getElementById(`varName_${node.id}`).onchange = e => {
            node.data.varName = e.target.value;
            editor.updateNodeDataFromId(node.id, node.data);
            editor.updateNodeHtmlFromId(node.id, nodeTileHtml(node.name, node.data, node.id));
            markFlowNeedsSave(true);
          };

          // 5) Save Mode dropdown
          el.insertAdjacentHTML("beforeend", `
            <label>Save Mode</label>
            <select id="saveMode_${node.id}" style="width:98%; margin-bottom:12px;">
              <option value="overwrite" ${!node.data.append ? "selected" : ""}>Overwrite</option>
              <option value="append"    ${ node.data.append ? "selected" : ""}>Append</option>
            </select>
          `);
          document.getElementById(`saveMode_${node.id}`).onchange = e => {
            node.data.append = e.target.value === "append";
            editor.updateNodeDataFromId(node.id, node.data);
            editor.updateNodeHtmlFromId(node.id, nodeTileHtml(node.name, node.data, node.id));
            markFlowNeedsSave(true);
          };

          return;
        }

        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        // Motion Direction (Editor UI only; app handles all logic)
        // Fields: Motion A (single device), Motion B (single device), Max Time Between (sec)
        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        if (node.name === "motionDirection") {
          const el = document.getElementById("nodeEditor");
          el.innerHTML = "";

          // Filter to motion-capable real devices
          const allDevices = Array.isArray(window.devices) ? window.devices : [];
          function isMotionDev(dev) {
            if (!dev) return false;
            const attrs = dev.attributes || {};
            if (Array.isArray(attrs)) {
              // some shapes: [{name:"motion", currentValue:"inactive"}, ...]
              return attrs.some(a => (a && (a.name || "").toLowerCase() === "motion"));
            }
            // key->object shape: { motion: { currentValue: "inactive", ... }, ... }
            return Object.prototype.hasOwnProperty.call(attrs, "motion");
          }
          const motionOnly = allDevices.filter(isMotionDev).slice().sort((a,b)=>{
            const la = (a.label || a.name || a.id || "").toLowerCase();
            const lb = (b.label || b.name || b.id || "").toLowerCase();
            return la.localeCompare(lb);
          });

          // Header
          const h = document.createElement("div");
          h.innerHTML = "<b>Motion Direction</b>";
          h.style.marginBottom = "8px";
          el.appendChild(h);

          // helper to build a single-select device dropdown
          function buildDeviceDropdown(labelText, currentId, onPicked) {
            const lab = document.createElement("label");
            lab.textContent = labelText;
            lab.style.display = "block";
            el.appendChild(lab);

            const sel = document.createElement("select");
            sel.style = "display:block;margin-bottom:12px;width:100%";
            sel.innerHTML =
              `<option value="" ${!currentId ? "selected" : ""}></option>` +
              motionOnly.map(d => {
                const id = String(d.id);
                const label = (d.label || d.name || id);
                const selAttr = (String(currentId || "") === id) ? " selected" : "";
                return `<option value="${id}"${selAttr}>${label}</option>`;
              }).join("");

            sel.onchange = () => onPicked(sel.value || "");
            el.appendChild(sel);
          }

          // --- Motion A dropdown (single-select) ---
          buildDeviceDropdown("Motion A", node.data.deviceAId, (val) => {
            node.data.deviceAId = val;
            editor.updateNodeDataFromId(node.id, node.data);
            editor.updateNodeHtmlFromId(node.id, nodeTileHtml(node.name, node.data, node.id));
            markFlowNeedsSave(true);
          });

          // --- Motion B dropdown (single-select) ---
          buildDeviceDropdown("Motion B", node.data.deviceBId, (val) => {
            node.data.deviceBId = val;
            editor.updateNodeDataFromId(node.id, node.data);
            editor.updateNodeHtmlFromId(node.id, nodeTileHtml(node.name, node.data, node.id));
            markFlowNeedsSave(true);
          });

          // --- Max Time Between (sec) ---
          {
            const lab = document.createElement("label");
            lab.textContent = "Max Time Between (sec)";
            lab.style.display = "block";
            el.appendChild(lab);

            const num = document.createElement("input");
            num.type = "number";
            num.min = "1";
            num.step = "1";
            num.value = (node.data && node.data.maxGapSec != null) ? Number(node.data.maxGapSec) : 5;
            num.style = "display:block;margin-bottom:12px;width:120px";
            num.oninput = function () {
              let v = parseInt(num.value || "5", 10);
              if (!(v > 0)) v = 1;
              node.data.maxGapSec = v;
              editor.updateNodeDataFromId(node.id, node.data);
              editor.updateNodeHtmlFromId(node.id, nodeTileHtml(node.name, node.data, node.id));
              markFlowNeedsSave(true);
            };
            el.appendChild(num);
          }

          // --- Variable (store direction) ---
          {
            const lab = document.createElement("label");
            lab.textContent = "Variable";
            lab.style.display = "block";
            el.appendChild(lab);

            // Collect flow + global vars (normalized like Variable Inspector)
            const flowFile = (window.flowVars?.getCurrentFlowFile?.() || "").replace(/\.json$/i, "");
            // Ensure FE_flowvars map is normalized (same technique as inspector)
            (function normalizeFlowVarsOnce(){
              if (!window.FE_flowvars) { window.FE_flowvars = {}; return; }
              if (Array.isArray(window.FE_flowvars)) {
                const arr = window.FE_flowvars;
                const map = {};
                for (const r of arr) {
                  if (!r || !r.flow || !r.name) continue;
                  const b = String(r.flow).replace(/\.json$/i, "");
                  (map[b] = map[b] || []).push({ name: r.name, type: r.type || "String", value: r.value });
                  map[b + ".json"] = map[b]; // mirror key
                }
                window.FE_flowvars = map;
              } else if (typeof window.FE_flowvars === "object") {
                for (const k of Object.keys(window.FE_flowvars)) {
                  const b = k.replace(/\.json$/i, "");
                  if (!window.FE_flowvars[b]) window.FE_flowvars[b] = window.FE_flowvars[k] || [];
                  if (!window.FE_flowvars[b + ".json"]) window.FE_flowvars[b + ".json"] = window.FE_flowvars[b];
                }
              }
            })();

            const flowVarsArr =
              (window.FE_flowvars?.[flowFile] ||
              window.FE_flowvars?.[flowFile + ".json"] ||
              window.FE_flowvars?.[flowFile?.replace(/\.json$/i,"")] ||
              []);

            const globalVarsArr = Array.isArray(window.FE_global_vars) ? window.FE_global_vars : [];

            // Build a unique, sorted list of names
            const names = new Set();
            flowVarsArr.forEach(v => v?.name && names.add(v.name));
            globalVarsArr.forEach(v => v?.name && names.add(v.name));
            const varNames = Array.from(names).sort((a,b)=>a.localeCompare(b));

            // Real dropdown (single-select)
            const sel = document.createElement("select");
            sel.style = "display:block;margin-bottom:12px;width:100%";
            sel.innerHTML =
              `<option value="" ${!node.data.varName ? "selected" : ""}></option>` +
              varNames.map(n => `<option value="${n}" ${node.data.varName===n ? "selected" : ""}>${n}</option>`).join("");

            sel.onchange = () => {
              node.data.varName = sel.value || "";
              editor.updateNodeDataFromId(node.id, node.data);
              editor.updateNodeHtmlFromId(node.id, nodeTileHtml(node.name, node.data, node.id));
              markFlowNeedsSave(true);
            };

            el.appendChild(sel);
          }

          // Done handling this node
          return;
        }

        
        if (node.name === "saveDeviceState") {
          el.innerHTML = `Save Device State<br><br>`;

          const devLabel = document.createElement("label");
          devLabel.textContent = "Device(s)";
          devLabel.style.display = "block";
          el.appendChild(devLabel);

          const selected = Array.isArray(node.data.deviceIds)
            ? node.data.deviceIds
            : (node.data.deviceId ? [node.data.deviceId] : []);

          renderDevicePicker(
            el,
            devices,
            selected,
            (newSelectedIds, newDeviceLabels) => {
              node.data.deviceIds = Array.isArray(newSelectedIds) ? newSelectedIds : [];
              node.data.deviceLabels = Array.isArray(newDeviceLabels) ? newDeviceLabels : [];
              // legacy mirrors for backward compatibility
              node.data.deviceId = node.data.deviceIds[0] || "";
              node.data.deviceLabel = node.data.deviceLabels[0] || "";
              editor.updateNodeDataFromId(node.id, node.data);
              editor.updateNodeHtmlFromId(node.id, nodeTileHtml(node.name, node.data, node.id));
              markFlowNeedsSave(true);
            }
          );

          return;
        }


        
        if (node.name === "restoreDeviceState") {
          el.innerHTML = `Restore Device State<br><br>`;

          const devLabel = document.createElement("label");
          devLabel.textContent = "Device(s)";
          devLabel.style.display = "block";
          el.appendChild(devLabel);

          const selected = Array.isArray(node.data.deviceIds)
            ? node.data.deviceIds
            : (node.data.deviceId ? [node.data.deviceId] : []);

          renderDevicePicker(
            el,
            devices,
            selected,
            (newSelectedIds, newDeviceLabels) => {
              node.data.deviceIds = Array.isArray(newSelectedIds) ? newSelectedIds : [];
              node.data.deviceLabels = Array.isArray(newDeviceLabels) ? newDeviceLabels : [];
              node.data.deviceId = node.data.deviceIds[0] || "";
              node.data.deviceLabel = node.data.deviceLabels[0] || "";
              editor.updateNodeDataFromId(node.id, node.data);
              editor.updateNodeHtmlFromId(node.id, nodeTileHtml(node.name, node.data, node.id));
              markFlowNeedsSave(true);
            }
          );

          return;
        }

        if (node.name === "notification") {
          const el = document.getElementById("nodeEditor");
          el.innerHTML = "<b>Notification Node</b><br><br>";

          // Type selector
          const typeLabel = document.createElement("label");
          typeLabel.textContent = "Type";
          el.appendChild(typeLabel);

          const typeSelect = document.createElement("select");
          ["push", "speech"].forEach(type => {
            const opt = document.createElement("option");
            opt.value = type;
            opt.textContent = type.charAt(0).toUpperCase() + type.slice(1);
            if (node.data.notificationType === type) opt.selected = true;
            typeSelect.appendChild(opt);
          });
          typeSelect.value = node.data.notificationType || "push";
          typeSelect.onchange = () => {
            node.data.notificationType = typeSelect.value;
            editor.updateNodeDataFromId(node.id, node.data);
            editor.updateNodeHtmlFromId(node.id, nodeTileHtml(node.name, node.data, node.id));
            renderEditor(node); // rerender to update device dropdown label
            markFlowNeedsSave(true);
          };
          el.appendChild(typeSelect);

          // --- Device dropdown (filtered by capability) ---
          const type = typeSelect.value || node.data.notificationType || "push";
          const deviceLabel = document.createElement("label");
          deviceLabel.textContent = (type === "speech") ? "Speaker Device" : "Notification Device";
          deviceLabel.style.display = "block";
          el.appendChild(deviceLabel);

          // Filter device list for Notification (push) or Speech
          let filteredDevices = [];
          if (type === "speech") {
            // Find devices with Speech capability
            filteredDevices = devices.filter(d =>
              (d.commands && d.commands.includes("speak")) ||
              (d.capabilities && d.capabilities.includes("SpeechSynthesis"))
            );
          } else {
            // Find devices with Notification capability
            filteredDevices = devices.filter(d =>
              (d.commands && d.commands.includes("deviceNotification")) ||
              (d.capabilities && d.capabilities.includes("Notification"))
            );
          }
          if (filteredDevices.length === 0) filteredDevices = devices;
          filteredDevices.sort((a, b) => (a.label || "").localeCompare(b.label || ""));
          const devSelect = document.createElement("select");
          devSelect.multiple = true;
          devSelect.size = Math.min(8, filteredDevices.length);

          const selectedIds = Array.isArray(node.data.targetDeviceId)
            ? node.data.targetDeviceId
            : node.data.targetDeviceId
              ? [node.data.targetDeviceId]
              : [];

          filteredDevices.forEach(d => {
            const opt = document.createElement("option");
            opt.value = d.id;
            opt.textContent = d.label;
            if (selectedIds.includes(d.id)) opt.selected = true;
            devSelect.appendChild(opt);
          });

          devSelect.onchange = () => {
            node.data.targetDeviceId = Array.from(devSelect.selectedOptions).map(opt => opt.value);
            editor.updateNodeDataFromId(node.id, node.data);
            editor.updateNodeHtmlFromId(node.id, nodeTileHtml(node.name, node.data, node.id));
            markFlowNeedsSave(true);
          };
          el.appendChild(devSelect);

          // --- Message label & input ---
          const msgLabel = document.createElement("label");
          msgLabel.textContent = "Message";
          msgLabel.style.display = "block";
          el.appendChild(msgLabel);

          const msgInput = document.createElement("input");
          msgInput.type = "text";
          msgInput.style.width = "100%";
          msgInput.style.marginBottom = "8px";
          msgInput.placeholder = "";
          msgInput.value = node.data.message || "";
          msgInput.oninput = () => {
            node.data.message = msgInput.value;
            editor.updateNodeDataFromId(node.id, node.data);
            markFlowNeedsSave(true);
          };
          el.appendChild(msgInput);

          // --- Wildcard/Variable info ---
          const wildcardMsg = document.createElement("div");
          wildcardMsg.style.fontSize = "13px";
          wildcardMsg.style.marginTop = "7px";
          wildcardMsg.style.color = "#b7cdfd";
          wildcardMsg.innerHTML = '<b><u>Wildcards:</u></b><br>' +
            '<b>{device}</b> ‚Äì Event device name/label<br>' +
            '<b>{value}</b> ‚Äì Event value<br>' +
            '<b>{text}</b> ‚Äì Event description or text<br>' +
            '<b>{time24}</b> ‚Äì Event time (24-hour, e.g. 14:32)<br>' +
            '<b>{time12}</b> ‚Äì Event time (12-hour, e.g. 3:00 pm)<br>' +
            '<b>{date}</b> ‚Äì Event date (MM-DD-YYYY, e.g. 06-19-2025)<br>' +
            '<b>{now}</b> ‚Äì Current system date & time<br>' +
            '<b>{varName_<i>AnyVar</i>}</b> ‚Äì literal variable name<br>' +
            '<b>{varValue_<i>AnyVar</i>}</b> ‚Äì value of the named variable<br>' +
            '<span style="color:#eee;">Example: {device} has become {value} at {time12} on {date}</span>';
          el.appendChild(wildcardMsg);
        }
  
        const previewChip = document.createElement("div");
        previewChip.className = "current-value";
        previewChip.style.marginLeft = "2px";
        previewChip.style.fontSize = "13px";
        previewChip.style.fontWeight = "bold";
        previewChip.style.cursor = "pointer";
        previewChip.title = "Preview of value/expression";
        el.appendChild(previewChip);
        function updatePreview() {
          if (window.flowVars && window.flowVars.evaluate) {
            try {
              const v = msgInput.value;
              if (!v.trim()) { previewChip.textContent = ""; previewChip.title = ""; return; }
              const result = window.flowVars.evaluate(v);
              let color = "#b7ffac";
              if (typeof result === "number") color = "#3af";
              else if (typeof result === "boolean") color = "#0c0";
              else if (typeof result === "string" && result.startsWith("ERR:")) color = "#f33";
              previewChip.textContent = "= " + result;
              previewChip.style.color = color;
              previewChip.title = (typeof result) + ": " + result;
            } catch(e) {
              previewChip.textContent = "ERR: " + e.message;
              previewChip.style.color = "#f33";
              previewChip.title = e.message;
            }
          }
        }
        if (typeof renderMinimap === 'function') {
          renderMinimap();
        }
        return;
      }
      
      window.editor = new Drawflow(document.getElementById("drawflow"));
      // ‚îÄ‚îÄ MONKEY‚ÄëPATCH editor.addNode TO WIPE ALL BUILT‚ÄëIN DEFAULTS ‚îÄ‚îÄ
      (function(){
        const origAddNode = editor.addNode.bind(editor);
        editor.addNode = function(...args) {
          const data = args[6];
          if (data && typeof data === 'object') {
            Object.keys(data).forEach(key => {
              if (typeof data[key] === 'string') {
                data[key] = "";
              } else if (Array.isArray(data[key])) {
                data[key] = data[key].map(_ => "");
              }
            });
          }
          return origAddNode(...args);
        };
      })();

      if (editor && editor.on) {
        editor.on('all', function(event, ...args) {
          //console.log("DRAWFLOW EVENT:", event, args);
        });

        // --- SNAP TO GRID: add this below ---
        editor.on('nodeMoved', function(id) {
          // Only snap if toggle is checked
          var snapActive = document.getElementById("snapToGridToggle")?.checked;
          if (!snapActive) return;

          const nodeEl = document.getElementById("node-" + id);
          if (!nodeEl) {
            console.log("Node element not found by id: node-" + id);
            return;
          }

          let left = parseInt(nodeEl.style.left, 10) || 0;
          let top = parseInt(nodeEl.style.top, 10) || 0;
          let snappedLeft = Math.round(left / 20) * 20;
          let snappedTop = Math.round(top / 20) * 20;

          if (left !== snappedLeft || top !== snappedTop) {
            nodeEl.style.left = snappedLeft + "px";
            nodeEl.style.top = snappedTop + "px";
            if (editor.drawflow && getHomeFrom(editor) && getHomeDataFrom(editor)[id]) {
              getHomeDataFrom(editor)[id].pos_x = snappedLeft;
              getHomeDataFrom(editor)[id].pos_y = snappedTop;
            }
            //console.log("SNAPPED NODE " + id + " to (" + snappedLeft + ", " + snappedTop + ")");
          }
        });
      }

      /* removed legacy drawflow mousedown DnD/multi-select handler */
// Add moveNodeTo to Drawflow (polyfill for versions that lack it)
      if (!editor.moveNodeTo) {
        editor.moveNodeTo = function(nodeId, x, y) {
          // Robustly find the Home flow data without relying on undefined globals
          var home = null;
          try {
            if (typeof getHomeFrom === 'function') {
              home = getHomeFrom(this.drawflow || this);
            } else if (this && this.drawflow) {
              home = (this.drawflow.Home) ? this.drawflow.Home
                    : (this.drawflow.drawflow && this.drawflow.drawflow.Home) ? this.drawflow.drawflow.Home
                    : null;
            }
          } catch(_){ home = null; }
          if (!home || !home.data) return;

          var node = home.data[nodeId];
          if (!node) return;
          node.pos_x = x;
          node.pos_y = y;

          // Move the actual HTML node in the DOM
          var htmlNode = document.getElementById("node-" + nodeId);
          if (htmlNode) {
            htmlNode.style.left = x + "px";
            htmlNode.style.top = y + "px";
          }

          // Also rerender lines
          if (typeof this.updateConnectionNodes === "function") {
            try { this.updateConnectionNodes("node-" + nodeId); } catch(_){}
          }
        }
      }
      editor.reroute = true;
      editor.start();

      editor.on('nodeMoved', function(id) {
        markFlowNeedsSave(true);
      });
      editor.on('connectionRemoved', function(connection) {
        markFlowNeedsSave(true);
      });
      editor.on('connectionCreated', function(connection) {
        markFlowNeedsSave(true);
      });
      editor.on('nodeRemoved', function(id) {
        markFlowNeedsSave(true);
      });

      if (typeof Drawflow !== "undefined" && !Drawflow.prototype.updateNodeHtmlFromId) {
        Drawflow.prototype.updateNodeHtmlFromId = function(id, html) {
          let selector = "#node-" + id;
          if (typeof id === "string" && id.startsWith("node-")) {
           selector = "#" + id;
          }
          const nodeDiv = this.container.querySelector(selector + " .drawflow_content_node");
          if (nodeDiv) nodeDiv.innerHTML = html;
        }
      }

      editor.on("nodeSelected", function (id) {
        editor.selected_id = id;
        renderEditor(editor.getNodeFromId(id));
      });

      document.getElementById("addRepeat").onclick = function() {
        logAction("addRepeat button clicked.");
        const { x, y } = getTopLeftOnScreenCoords();
        editor.addNode("repeat", 1, 0, x, y, "repeat",
          {}, nodeTileHtml("repeat", {}),
        );
        markFlowNeedsSave(true);
        // Increment offset for next node
        window.newNodeOffsetX += window.newNodeOffsetStep;
        window.newNodeOffsetY += window.newNodeOffsetStep;
        window.newNodeCounter++;
      };

      // --- Motion Direction ---
      document.getElementById("addMotionDirection").onclick = () => {
        logAction("addMotionDirection button clicked.");

        // 1) Compute the next X/Y (same function your file uses)
        const { x, y } = getTopLeftOnScreenCoords();

        // 2) Add the node exactly like the others: name, inputs, outputs, x, y, class, data, html
        //    Keep name/class consistent with your patterns (both strings usually identical)
        const initialData = { deviceAId: "", deviceBId: "", maxGapSec: 5, varName: "" };

        editor.addNode(
          "motionDirection",   // name
          1,                   // inputs
          1,                   // outputs
          x, y,                // coords
          "motionDirection",   // class
          initialData,         // data (app will handle all logic)
          nodeTileHtml("motionDirection", initialData) // tile HTML
        );

        // 3) Apply the same cascading offset pattern as the rest
        window.newNodeOffsetX += window.newNodeOffsetStep;
        window.newNodeOffsetY += window.newNodeOffsetStep;
        window.newNodeCounter++;

        // --- RESET after 10 nodes --- (same as your other handlers)
        if (window.newNodeCounter >= window.newNodeOffsetLimit) {
          window.newNodeOffsetX = 0;
          window.newNodeOffsetY = 0;
          window.newNodeCounter = 0;
        }

        // 4) Standard post-add updates
        markFlowNeedsSave(true);
        updateNodeSelectionUI();
        logAction("addMotionDirection finished.");
      };
      
      // --- Save Device State ---
      document.getElementById("addSaveDeviceState").onclick = function() {
        logAction("addSaveDeviceState button clicked.");
        const { x, y } = getTopLeftOnScreenCoords();
        editor.addNode("saveDeviceState", 1, 1, x, y, "saveDeviceState", { deviceIds: [], deviceLabels: [], deviceId:"", deviceLabel:"" }, nodeTileHtml("saveDeviceState", { deviceId: "", deviceLabel: "" }, ));
        markFlowNeedsSave(true);
        window.newNodeOffsetX += window.newNodeOffsetStep;
        window.newNodeOffsetY += window.newNodeOffsetStep;
        window.newNodeCounter++;

        // --- RESET after 10 nodes ---
        if (window.newNodeCounter >= window.newNodeOffsetLimit) {
          window.newNodeOffsetX = 0;
          window.newNodeOffsetY = 0;
          window.newNodeCounter = 0;
        }
      };

      // --- Restore Device State ---
      document.getElementById("addRestoreDeviceState").onclick = function() {
        logAction("addRestoreDeviceState button clicked.");
        const { x, y } = getTopLeftOnScreenCoords();
        editor.addNode("restoreDeviceState", 1, 1, x, y, "restoreDeviceState", { deviceIds: [], deviceLabels: [], deviceId:"", deviceLabel:"" }, nodeTileHtml("restoreDeviceState", { deviceId: "", deviceLabel: "" }, ));
        markFlowNeedsSave(true);
        window.newNodeOffsetX += window.newNodeOffsetStep;
        window.newNodeOffsetY += window.newNodeOffsetStep;
        window.newNodeCounter++;

        // --- RESET after 10 nodes ---
        if (window.newNodeCounter >= window.newNodeOffsetLimit) {
          window.newNodeOffsetX = 0;
          window.newNodeOffsetY = 0;
          window.newNodeCounter = 0;
        }
      };

      document.getElementById("addSchedule").onclick = function() {
        try {
          if (window.FE_Scheduler && typeof window.FE_Scheduler.open === "function") {
            window.FE_Scheduler.open();
          } else {
            console.warn("FE_Scheduler not ready");
          }
        } catch (e) { console.warn("schedule popup open error", e); }
      };

      document.getElementById("addDevice").onclick = () => {
        logAction("addDevice button clicked.");

        // 1) Compute the next X/Y (with your existing offset variables)
        const { x, y } = getTopLeftOnScreenCoords();

        // 2) Add the Device-Action node at that spot
        editor.addNode("device", 1, 1, x, y, "device",
          {deviceId: "", attribute: "", command: "", value: ""},
          nodeTileHtml("device",
            { deviceId: "", attribute: "", command: "", value: "" }
          )
        );

        // 3) Increment your per-click offsets exactly like the others
        window.newNodeOffsetX += window.newNodeOffsetStep;
        window.newNodeOffsetY += window.newNodeOffsetStep;
        window.newNodeCounter++;
        if (window.newNodeCounter >= window.newNodeOffsetLimit) {
          window.newNodeOffsetX = 0;
          window.newNodeOffsetY = 0;
          window.newNodeCounter = 0;
        }

        // 4) Re-apply your data-node-type attribute after draw
        setTimeout(() => {
          document.querySelectorAll('.drawflow-node').forEach(el => {
            const id = el.id.replace('node-', '');
            const node = editor.getNodeFromId(id);
            if (node && node.name === "device") {
              el.setAttribute('data-node-type', 'device');
            }
          });
        
        try{ window.__autoRefresh = false; }catch(_){}
        }, 100);

        // 5) Final bookkeeping
        markFlowNeedsSave(true);
        updateNodeSelectionUI();
        logAction("addDevice finished.");
      };

      document.getElementById("addCondition").onclick = () => {
        logAction("addCondition button clicked.");
        const { x, y } = getTopLeftOnScreenCoords();
        editor.addNode("condition", 1, 2, x, y, "condition", {
          deviceId: "", attribute: "", value: "", comparator: ""
        }, nodeTileHtml("condition", { deviceId: "", attribute: "", comparator: "", value: "" }), undefined, { outputs: ["true", "false"] });
        setTimeout(() => {
          const nodeEls = document.querySelectorAll('.drawflow-node');
          nodeEls.forEach(el => {
            const id = el.id.replace('node-', '');
            if (editor.getNodeFromId && editor.getNodeFromId(id)) {
              const node = editor.getNodeFromId(id);
              if (node && node.name === "device") {
                el.setAttribute('data-node-type', 'device');
              }
              if (node && node.name === "condition") {
                el.setAttribute('data-node-type', 'condition');
              }
              if (node && node.name === "eventTrigger") {
                el.setAttribute('data-node-type', 'eventTrigger');
              }
            }
          });
        
        try{ window.__autoRefresh = false; }catch(_){}
        }, 100);
        window.newNodeOffsetX += window.newNodeOffsetStep;
        window.newNodeOffsetY += window.newNodeOffsetStep;
        window.newNodeCounter++;

        // --- RESET after 10 nodes ---
        if (window.newNodeCounter >= window.newNodeOffsetLimit) {
          window.newNodeOffsetX = 0;
          window.newNodeOffsetY = 0;
          window.newNodeCounter = 0;
        }
        markFlowNeedsSave(true);
        updateNodeSelectionUI();
        logAction("addCondition finished.");
      };

      document.getElementById("addTrigger").onclick = () => {
        logAction("addTrigger button clicked.");
        const { x, y } = getTopLeftOnScreenCoords();
        editor.addNode("eventTrigger", 0, 1, x, y, "eventTrigger", {
          deviceId: "", attribute: "", value: "", comparator: ""
        }, nodeTileHtml("eventTrigger", { deviceId: "", attribute: "", comparator: "", value: "" }));
        setTimeout(() => {
          const nodeEls = document.querySelectorAll('.drawflow-node');
          nodeEls.forEach(el => {
            const id = el.id.replace('node-', '');
            if (editor.getNodeFromId && editor.getNodeFromId(id)) {
              const node = editor.getNodeFromId(id);
              if (node && node.name === "device") {
                el.setAttribute('data-node-type', 'device');
              }
              if (node && node.name === "condition") {
                el.setAttribute('data-node-type', 'condition');
              }
              if (node && node.name === "eventTrigger") {
                el.setAttribute('data-node-type', 'eventTrigger');
              }
            }
          });
        
        try{ window.__autoRefresh = false; }catch(_){}
        }, 100);
        window.newNodeOffsetX += window.newNodeOffsetStep;
        window.newNodeOffsetY += window.newNodeOffsetStep;
        window.newNodeCounter++;

        // --- RESET after 10 nodes ---
        if (window.newNodeCounter >= window.newNodeOffsetLimit) {
          window.newNodeOffsetX = 0;
          window.newNodeOffsetY = 0;
          window.newNodeCounter = 0;
        }
        markFlowNeedsSave(true);
        updateNodeSelectionUI();
        logAction("addTrigger finished.");
      };

      document.getElementById("addComment").onclick = function () {
        logAction("addComment button clicked.");
        const { x, y } = getTopLeftOnScreenCoords();
        editor.addNode("comment", 0, 0, x, y, "comment", { 
          text: "comment..." }
        );
        window.newNodeOffsetX += window.newNodeOffsetStep;
        window.newNodeOffsetY += window.newNodeOffsetStep;
        window.newNodeCounter++;

        // --- RESET after 10 nodes ---
        if (window.newNodeCounter >= window.newNodeOffsetLimit) {
          window.newNodeOffsetX = 0;
          window.newNodeOffsetY = 0;
          window.newNodeCounter = 0;
        }
        markFlowNeedsSave(true);
        updateNodeSelectionUI();
        logAction("addComment finished.");
      };

      document.getElementById("addSetVariable").onclick = () => {
        logAction("addSetVariable button clicked.");
        const { x, y } = getTopLeftOnScreenCoords();
        editor.addNode("setVariable", 1, 1, x, y, "setVariable", {
          varName: "", varValue: ""
        }, nodeTileHtml("setVariable", { varName: "", varValue: "" }));
        window.newNodeOffsetX += window.newNodeOffsetStep;
        window.newNodeOffsetY += window.newNodeOffsetStep;
        window.newNodeCounter++;

        // --- RESET after 10 nodes ---
        if (window.newNodeCounter >= window.newNodeOffsetLimit) {
          window.newNodeOffsetX = 0;
          window.newNodeOffsetY = 0;
          window.newNodeCounter = 0;
        }
        markFlowNeedsSave(true);
        updateNodeSelectionUI();
        logAction("addSetVariable finished.");
      };

      document.getElementById("addCountdown").onclick = () => {
        logAction("addCountdown button clicked.");
        const { x, y } = getTopLeftOnScreenCoords();
        editor.addNode("countdown", 1, 1, x, y, "countdown", { varName: "", targetDate: "" }, nodeTileHtml("countdown", { varName: "", targetDate: "" }));
        window.newNodeOffsetX += window.newNodeOffsetStep;
        window.newNodeOffsetY += window.newNodeOffsetStep;
        window.newNodeCounter++;

        // --- RESET after 10 nodes ---
        if (window.newNodeCounter >= window.newNodeOffsetLimit) {
          window.newNodeOffsetX = 0;
          window.newNodeOffsetY = 0;
          window.newNodeCounter = 0;
        }
        markFlowNeedsSave(true);
        updateNodeSelectionUI();
        logAction("addCountdown finished.");
      };

      document.getElementById("addNotify").onclick = () => {
        logAction("addNotification button clicked.");
        const { x, y } = getTopLeftOnScreenCoords();
        editor.addNode("notification", 1, 1, x, y, "notification", {
          notificationType: "push", // default
          targetDeviceId: "",
          message: ""
        }, nodeTileHtml("notification", { notificationType: "push", message: "" }));
        markFlowNeedsSave(true);
        window.newNodeOffsetX += window.newNodeOffsetStep;
        window.newNodeOffsetY += window.newNodeOffsetStep;
        window.newNodeCounter++;

        // --- RESET after 10 nodes ---
        if (window.newNodeCounter >= window.newNodeOffsetLimit) {
          window.newNodeOffsetX = 0;
          window.newNodeOffsetY = 0;
          window.newNodeCounter = 0;
        }
        updateNodeSelectionUI();
        logAction("addNotification finished.");
      };

      document.getElementById("addDoNothing").onclick = () => {
        logAction("addDoNothing button clicked.");
        const { x, y } = getTopLeftOnScreenCoords();
        markFlowNeedsSave(true);
        editor.addNode("doNothing", 1, 0, x, y, "doNothing", 
          {}, 
          '<div class="logic-node">Do Nothing</div>'
        );
        window.newNodeOffsetX += window.newNodeOffsetStep;
        window.newNodeOffsetY += window.newNodeOffsetStep;
        window.newNodeCounter++;

        // --- RESET after 10 nodes ---
        if (window.newNodeCounter >= window.newNodeOffsetLimit) {
          window.newNodeOffsetX = 0;
          window.newNodeOffsetY = 0;
          window.newNodeCounter = 0;
        }
        markFlowNeedsSave(true);
        updateNodeSelectionUI();
        logAction("addDoNothing finished.");
      };

      document.getElementById("addDelay").onclick = () => {
        logAction("addDelay button clicked.");
        const { x, y } = getTopLeftOnScreenCoords();
        editor.addNode("delay", 1, 1, x, y, "delay", {
          delayMs: 1000
        }, nodeTileHtml("delay", { delayMs: 1000 }));
        window.newNodeOffsetX += window.newNodeOffsetStep;
        window.newNodeOffsetY += window.newNodeOffsetStep;
        window.newNodeCounter++;

        // --- RESET after 10 nodes ---
        if (window.newNodeCounter >= window.newNodeOffsetLimit) {
          window.newNodeOffsetX = 0;
          window.newNodeOffsetY = 0;
          window.newNodeCounter = 0;
        }
        markFlowNeedsSave(true);
        updateNodeSelectionUI();
        logAction("addDelay finished.");
      };

      document.getElementById("addDelayMin").onclick = () => {
        logAction("addDelayMin button clicked.");
        const { x, y } = getTopLeftOnScreenCoords();
        editor.addNode("delayMin", 1, 1, x, y, "delayMin", {
          delayMin: 1
        }, nodeTileHtml("delayMin", { delayMin: 1 }));
        window.newNodeOffsetX += window.newNodeOffsetStep;
        window.newNodeOffsetY += window.newNodeOffsetStep;
        window.newNodeCounter++;

        // --- RESET after 10 nodes ---
        if (window.newNodeCounter >= window.newNodeOffsetLimit) {
          window.newNodeOffsetX = 0;
          window.newNodeOffsetY = 0;
          window.newNodeCounter = 0;
        }
        markFlowNeedsSave(true);
        updateNodeSelectionUI();
        logAction("addDelayMin finished.");
      };

      document.getElementById("newFlow").onclick  = async function() {
        if (confirm("Clear all nodes and start a new flow? This cannot be undone.")) {
          editor.clear();
          document.getElementById("flowName").textContent = "";      // clear name
          document.getElementById("nodeEditor").innerHTML = "Click a node to edit";
          markFlowNeedsSave(false);
          logAction("Started a new flow (all nodes cleared).");

          // ‚îÄ‚îÄ‚îÄ CLEAR DROPDOWN SELECTION ‚îÄ‚îÄ‚îÄ
          const dd = document.getElementById("hubitatFileDropdown");
          dd.value = "";   // resets to your ‚ÄúPick a Flow‚Ä¶‚Äù placeholder
          // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

          const appId = document.getElementById("hubitatAppId").value.trim();
          const token = document.getElementById("hubitatToken").value.trim();
          checkIfFlowIsInUse("new", appId, token);
        }
        await autoLoadGlobalVarsFromHubitat();
      };

      window.addEventListener("DOMContentLoaded", async () => {
        // ‚îÄ‚îÄ NODE CLICK SELECTION HANDLER ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        document.addEventListener('click', e => {
          // look for the nearest .drawflow-node element
          const nodeEl = e.target.closest('.drawflow-node');
          if (!nodeEl || !editor) return;

          // strip off the "node-" prefix to get the ID
          const nodeId = nodeEl.id.replace(/^node-/, '');
          if (!nodeId) return;

          // set the selected_id so Test will pick it up
          editor.selected_id = nodeId;

          // optional: log your selection so you know it worked
          //logAction(`üñ±Ô∏è Selected node ${nodeId}`, 'info');
        });
      });

      async function fetchDevicesFromApp() {
        const appId = document.getElementById("hubitatAppId").value.trim();
        const token = document.getElementById("hubitatToken").value.trim();
        if (!appId || !token) {
          logAction("Enter App ID and Access Token!", "error");
          return [];
        }
        try {
          const url = `/apps/api/${appId}/devices?access_token=${token}`;
          const res = await fetch(url);
          if (!res.ok) throw new Error("HTTP " + res.status);
          const data = await res.json();
          return data;
        } catch (e) {
          logAction("Failed to fetch devices: " + e.message, "error");
          return [];
        }
      }

      var loadBtn = document.getElementById("loadDevices");
        if (loadBtn) {
          loadBtn.onclick = async () => {
            logAction("loadDevices button clicked.");
            await fetchModesFromAppFile();
            devices = await fetchDevicesFromApp();
            devices.forEach(dev => {
              if (Array.isArray(dev.attributes)) {
                const attrMap = {};
                dev.attributes.forEach(a => {
                  if (a.name !== undefined) attrMap[a.name] = a.currentValue;
                });
                dev.attributes = attrMap;
              }
            });
            devices.push(TIME_DEVICE);
            devices.push(MODE_DEVICE);
            devices.push(VARIABLE_DEVICE);
            window.devices = devices;

            // Set current mode on Home Location device
            const currentModeObj = (window.hubitatModes || []).find(m => m.id === "current");
            const currentMode = currentModeObj ? currentModeObj.name : "";
            const modeDev = window.devices.find(d => d.id === "__mode__");
            if (modeDev) {
              modeDev.attributes.mode = currentMode;
            }

            // --- PATCH: force field sync after import ---
            setTimeout(() => {
              // 1. Always pick a node to edit
              let selected = editor.selected_id;
              if (!selected) {
                // If nothing selected, pick the first node in the flow (if any)
                const allIds = editor.drawflow && getHomeFrom(editor) && getHomeDataFrom(editor)
                  ? Object.keys(getHomeDataFrom(editor))
                  : [];
                if (allIds.length) {
                  selected = allIds[0];
                  editor.selected_id = selected;
                }
              }
              if (selected) {
                // Always refresh the editor panel to match current node data
                window.renderEditor(editor.getNodeFromId(selected));
              } else {
                document.getElementById("nodeEditor").innerHTML = "Click a node to edit";
              }
            }, 10);
            logAction("Devices loaded: " + devices.length);
          };
        }

      document.getElementById("sendFlow").onclick = async () => {
        // 1) Validate credentials & editor
        if (!hubitatCredentialsAreValid(true) || !editor) return;

        // 2) Determine filename (if empty, prompt for one like Save¬†As)
        const dd     = document.getElementById("hubitatFileDropdown");
        const fl     = dd.value.trim();
        let flowName = fl.endsWith(".json") ? fl.slice(0, -5) : fl;
        if (!flowName) {
          // Prompt for new name
          let name = prompt("Save flow as:", "");
          if (!name) return;  // user cancelled

          // Sanitize and validate
          name = sanitizeFlowName(name);
          if (!isValidFlowName(name)) {
            alert("Invalid flow name. Only letters, numbers, underscores, and dashes allowed.");
            return;
          }

          // Update display & use that name
          flowName = name;
          document.getElementById("flowName").textContent = flowName;
        }

        // 3) Export & prepare payload
        let flowObj;
        try {
          flowObj = editor.export();
          __fe_stampViewport(flowObj);
          if (window.flowVars?.getLocalVars) flowObj.variables = window.flowVars.getLocalVars();
        } catch (e) {
          alert("üõë Failed to export flow:<br>" + e);
          return;
        }

        // 4) Serialize to JSON
        let payloadText;
        try {
          payloadText = JSON.stringify({ flowName, ...flowObj }, null, 2);
        } catch (e) {
          alert("üõë Flow data could not be serialized to JSON:<br>" + e);
          return;
        }

        // 5) Pre‚Äëupload validation + extended auto‚Äëfix
        try {
          JSON.parse(payloadText);
        } catch (e) {
          logAction(`‚ö†Ô∏è JSON serialization error for "${flowName}.json": ${e.message}. Applying auto‚Äëfix‚Ä¶`, "warn");
          payloadText = payloadText
            .replace(/^\uFEFF/, "")                    // strip BOM
            .replace(/\/\/.*$/gm, "")                  // remove single‚Äëline comments
            .replace(/\/\*[\s\S]*?\*\//g, "")          // remove multi‚Äëline comments
            .replace(/,\s*([}\]])/g, "$1")             // remove trailing commas
            .replace(/(['"])?([a-zA-Z_$][\w$]*)\1\s*:/g, '"$2":') // quote unquoted keys
            .replace(/'([^']*)'/g, '"$1"')             // single ‚Üí double quotes
            .replace(/\bNaN\b/g, "null")               // NaN ‚Üí null
            .replace(/\bInfinity\b/g, "null");         // Infinity ‚Üí null

          try {
            JSON.parse(payloadText);
            logAction(`üîß Auto‚Äëfixed JSON before upload`, "info");
          } catch (e2) {
            alert("üõë Could not auto‚Äëfix JSON:<br>" + e2.message);
            return;
          }
        }

        // 6) Upload to Hubitat
        await uploadToHubitatFile(`${flowName}.json`, payloadText);

        // 7) Refresh dropdown and select just‚Äësaved file
        await reloadFlowDropdown(`${flowName}.json`);

        // 8) Post‚Äësave fetch & verify + extended auto‚Äëfix if needed
        try {
          let savedText = await fetchHubitatFileContent(`${flowName}.json`);
          if (typeof savedText !== "string") {
            savedText = JSON.stringify(savedText, null, 2);
          }

          try {
            JSON.parse(savedText);
            logAction(`‚úÖ Verified valid JSON for "${flowName}.json"`, "info");
          } catch {
            logAction(`‚ö†Ô∏è Saved JSON malformed for "${flowName}.json". Applying auto‚Äëfix‚Ä¶`, "warn");
            const fixedSaved = savedText
              .replace(/^\uFEFF/, "")
              .replace(/\/\/.*$/gm, "")
              .replace(/\/\*[\s\S]*?\*\//g, "")
              .replace(/,\s*([}\]])/g, "$1")
              .replace(/(['"])?([a-zA-Z_$][\w$]*)\1\s*:/g, '"$2":')
              .replace(/'([^']*)'/g, '"$1"')
              .replace(/\bNaN\b/g, "null")
              .replace(/\bInfinity\b/g, "null");

            // re‚Äëparse (will throw if still bad)
            JSON.parse(fixedSaved);

            logAction(`üîß Auto‚Äëfixed saved JSON for "${flowName}.json"`, "info");
            await uploadToHubitatFile(`${flowName}.json`, fixedSaved);
            logAction(`üîÅ Re‚Äëuploaded fixed JSON`, "info");
          }
        } catch (e) {
          alert("‚ö†Ô∏è Could not validate saved JSON:<br>" + e);
        }

        // 9) Clear dirty flag & log success
        markFlowNeedsSave(false);
        logAction(`Sent flow "${flowName}" to Hubitat File Manager.`, "success");
      

// Ensure Save button returns to green even if suppression was active
try { markFlowNeedsSave(false); } catch(_){}
try { setTimeout(function(){ markFlowNeedsSave(false); }, 1200); } catch(_){}
};

      // --- Auto device and tile refresh every 5 seconds ---
      setInterval(async () => {
        
      try{ window.__autoRefresh = true; if (typeof window.beginDirtySuppression==='function') window.beginDirtySuppression(1500, 'interval'); }catch(_){ }
      // Only run if credentials are filled and devices are loaded
        const appIdEl = document.getElementById("hubitatAppId");
        const tokenEl = document.getElementById("hubitatToken");
        if (!(appIdEl && appIdEl.value && tokenEl && tokenEl.value)) return;
        const devices = await fetchDevicesFromApp();
        devices.forEach(dev => {
          if (Array.isArray(dev.attributes)) {
            const attrMap = {};
            dev.attributes.forEach(a => {
              if (a.name !== undefined) attrMap[a.name] = a.currentValue;
            });
            dev.attributes = attrMap;
          }
        });
        devices.push(TIME_DEVICE);
        devices.push(MODE_DEVICE);
        devices.push(VARIABLE_DEVICE);
        window.devices = devices;

        // Set current mode on Home Location device
        const currentModeObj = (window.hubitatModes || []).find(m => m.id === "current");
        const currentMode = currentModeObj ? currentModeObj.name : "";
        const modeDev = window.devices.find(d => d.id === "__mode__");
        if (modeDev) {
          modeDev.attributes.mode = currentMode;
        }

        // Update all node tiles
        const data = (editor?.drawflow?.Home?.data) || (editor?.drawflow?.drawflow?.Home?.data);
        if (data && Object.keys(data).length > 0) {
          Object.values(data).forEach(node => {
            if (["device", "condition", "eventTrigger"].includes(node.name) && node.data && node.data.deviceId) {
              let dev = devices.find(d => d.id == node.data.deviceId);
              node.data.deviceLabel = dev ? (dev.label || dev.name || node.data.deviceId) : node.data.deviceId;
            }
            if (editor && typeof editor.updateNodeHtmlFromId === "function") {
              editor.updateNodeHtmlFromId(node.id, nodeTileHtml(node.name, node.data, node.id));
            }
          });
          // Redraw node lines (optional nudge)
          Object.values(data).forEach(node => {
            editor.moveNodeTo(node.id, node.pos_x + 1, node.pos_y);
          });
          setTimeout(() => {
            Object.values(data).forEach(node => {
              editor.moveNodeTo(node.id, node.pos_x - 1, node.pos_y);
            });
          }, 30);
          //logAction("Tiles auto-refreshed.");
        }
      
        try{ window.__autoRefresh = false; }catch(_){}
        }, 5000); // every 5 seconds
    });

    document.addEventListener("DOMContentLoaded", function() {
      if (window.flowVars && window.flowVars.renderManager) {
        flowVars.renderManager(document.getElementById('variableManager'), { globalVars: true });
      }
    });

    async function uploadToHubitatFile(filename, contents, opts = {}) {
      const appId = document.getElementById("hubitatAppId")?.value.trim();
      const token = document.getElementById("hubitatToken")?.value.trim();
      if (!appId || !token) { alert("Missing Hubitat appId/token"); throw new Error("Missing Hubitat appId/token"); }
      const url = `/apps/api/${appId}/uploadFile?access_token=${token}&name=${encodeURIComponent(filename)}`;
      let body = contents;
      if (typeof contents !== "string") body = JSON.stringify(contents, null, 2);

      const res = await fetch(url, {
          method: "POST",
          body: body,
          headers: { "Content-Type": opts.mimeType || "application/json" }
      });
      if (!res.ok) {
          alert("Failed to upload file to Hubitat: " + (await res.text()));
          throw new Error("Failed to upload file");
      } else {
        await reloadHubitatApp();
      }
      return await res.json().catch(() => true); // works for both JSON and blank responses
    }

    async function fetchModesFromAppFile() {
      if (typeof fetchHubitatVarFileContent !== "function") return [];
      try {
        const txt = await fetchHubitatVarFileContent("FE_flowModes.json");
        if (!txt) { window.hubitatModes = []; return []; }
        let obj = JSON.parse(txt);
        // Fix: allow file to be either an array, or an object with .modes
        let modes = Array.isArray(obj) ? obj : (obj.modes || []);
        window.hubitatModes = modes;
        logAction("Loaded modes: " + window.hubitatModes.map(m => m.name).join(", "));
        return window.hubitatModes;
      } catch (e) {
        logAction("Failed to load FE_flowModes.json: " + e, "error");
        window.hubitatModes = [];
        return [];
      }
    }

    // === Helper: Get and save Hubitat IP ===
    function getHubitatIP() {
      let ip = localStorage.getItem("hubitat_ip");
      if (!ip && window.location.hostname.match(/^\d+\.\d+\.\d+\.\d+$/)) ip = window.location.hostname;
      if (!ip) ip = prompt("Enter Hubitat IP address:", "192.168.1.XX") || "";
      if (ip) localStorage.setItem("hubitat_ip", ip);
      return ip;
    }

      function markExportNeeded(needed = true) {
        const btn = document.getElementById('exportVarsBtn');
        if (!btn) return;
        if (needed) {
          btn.classList.add('need-export');
        } else {
          btn.classList.remove('need-export');
        }
      }

      window.addEventListener("beforeunload", function (e) {
        const saveBtn = document.getElementById('sendFlow');
        if (saveBtn && saveBtn.classList.contains('need-save')) {
          // Chrome requires returnValue to be set.
          e.preventDefault();
          e.returnValue = "You have unsaved changes to your Flow. Are you sure you want to leave?";
          // Most browsers will show a generic message, but this ensures a dialog is triggered.
          return e.returnValue;
        }
      });
      document.addEventListener("DOMContentLoaded", function() {
        const header = document.getElementById("variableManagerHeader");
        const content = document.getElementById("variableManager");
        const arrow = document.getElementById("variableManagerArrow");
        let open = false; // Start hidden

        if (header && content && arrow) {
          content.style.display = "none";
          arrow.style.transform = "rotate(-90deg)";
          header.onclick = function() {
            open = !open;
            content.style.display = open ? "" : "none";
            arrow.style.transform = open ? "rotate(0deg)" : "rotate(-90deg)";
          };
        }

        // Variable Inspector toggle
        const invHeader  = document.getElementById("variableInspectorHeader");
        const invContent = document.getElementById("variableInspectorContent");
        const invArrow   = document.getElementById("variableInspectorArrow");
        let invOpen = false;

        if (invHeader && invContent && invArrow) {
          invContent.style.display = "none";
          invArrow.style.transform = "rotate(-90deg)";
          invHeader.onclick = function() {
            invOpen = !invOpen;
            invContent.style.display = invOpen ? "" : "none";
            invArrow.style.transform = invOpen ? "rotate(0deg)" : "rotate(-90deg)";
          };
        }
      });

      setInterval(() => {
        document.querySelectorAll('.drawflow-node').forEach(nodeEl => {
          if (nodeEl._hasCtxMenu) return;
          nodeEl._hasCtxMenu = true;

          nodeEl.addEventListener('contextmenu', function(ev) {
            ev.preventDefault();
            ev.stopPropagation();

            const nodeId = nodeEl.id.replace("node-", "");

            // If the clicked node isn't in the current selection, bail out
            if (!window._multiSelectedNodes.has(nodeId)) {
              window._multiSelectedNodes.clear();
              window._multiSelectedNodes.add(nodeId);
              updateMultiSelectUI();
            }

            // Remove existing menu
            document.getElementById('df-ctx-menu')?.remove();

            // Create new menu
            const menuDiv = document.createElement('div');
            menuDiv.id = 'df-ctx-menu';
            Object.assign(menuDiv.style, {
              position: 'fixed',
              left:   `${ev.clientX}px`,
              top:    `${ev.clientY}px`,
              zIndex: 9999,
              background:   '#333',
              color:        '#fff',
              borderRadius: '8px',
              padding:      '10px',
              boxShadow:    '0 4px 10px #0008',
              fontFamily:   'sans-serif',
              minWidth:     '140px'
            });

            // Single-node menu
            if (window._multiSelectedNodes.size === 1) {
              // --- Edit Node ---
              const editBtn = document.createElement('div');
              editBtn.textContent = "Edit Node";
              editBtn.style.cssText = 'cursor:pointer;padding:6px 12px';
              editBtn.onmouseenter = () => editBtn.style.background = "#555";
              editBtn.onmouseleave = () => editBtn.style.background = "transparent";
              editBtn.onclick = () => {
                editor.selected_id = nodeId;
                const node = editor.getNodeFromId(nodeId);
                if (node) renderEditor(node);
                menuDiv.remove();
              };
              menuDiv.appendChild(editBtn);

              // --- Delete Node ---
              const delBtn = document.createElement('div');
              delBtn.textContent = "Delete Node";
              delBtn.style.cssText = 'cursor:pointer;padding:6px 12px';
              delBtn.onmouseenter = () => delBtn.style.background = "#555";
              delBtn.onmouseleave = () => delBtn.style.background = "transparent";
              delBtn.onclick = () => {
                editor.removeNodeId("node-" + nodeId);
                menuDiv.remove();
              };
              menuDiv.appendChild(delBtn);

              // --- Duplicate Node ---
              const dupBtn = document.createElement('div');
              dupBtn.textContent = "Duplicate Node";
              dupBtn.style.cssText = 'cursor:pointer;padding:6px 12px';
              dupBtn.onmouseenter = () => dupBtn.style.background = "#555";
              dupBtn.onmouseleave = () => dupBtn.style.background = "transparent";
              dupBtn.onclick = () => {
                const node = editor.getNodeFromId(nodeId);
                if (!node) return;
                const newNode = JSON.parse(JSON.stringify(node));
                delete newNode.id;
                newNode.pos_x += 60;
                newNode.pos_y += 60;
                newNode.outputs = {};
                newNode.inputs  = {};
                editor.addNode(
                  newNode.name,
                  newNode.inputs_count,
                  newNode.outputs_count,
                  newNode.pos_x,
                  newNode.pos_y,
                  newNode.class,
                  newNode.data,
                  newNode.html
                );
                menuDiv.remove();
                setTimeout(forceFixPortsOnAllNodes, 5);
              };
              menuDiv.appendChild(dupBtn);
            }

            // Multi-node menu
            if (window._multiSelectedNodes.size > 1) {
              // --- Delete Selected Nodes ---
              const multiDelBtn = document.createElement('div');
              multiDelBtn.textContent = "Delete Selected Nodes";
              multiDelBtn.style.cssText = 'cursor:pointer;padding:6px 12px';
              multiDelBtn.onmouseenter = () => multiDelBtn.style.background = "#555";
              multiDelBtn.onmouseleave = () => multiDelBtn.style.background = "transparent";
              multiDelBtn.onclick = () => {
                deleteSelectedNodes();
                menuDiv.remove();
              };
              menuDiv.appendChild(multiDelBtn);

              // --- Duplicate Selected Nodes ---
              const multiDupBtn = document.createElement('div');
              multiDupBtn.textContent = "Duplicate Selected Nodes";
              multiDupBtn.style.cssText = 'cursor:pointer;padding:6px 12px';
              multiDupBtn.onmouseenter = () => multiDupBtn.style.background = "#555";
              multiDupBtn.onmouseleave = () => multiDupBtn.style.background = "transparent";
              multiDupBtn.onclick = () => {
                duplicateSelectedNodes();
                menuDiv.remove();
              };
              menuDiv.appendChild(multiDupBtn);

              // --- Lock Selected Nodes ---
              const lockBtn = document.createElement('div');
              lockBtn.textContent = "Lock Selected Nodes";
              lockBtn.style.cssText = 'cursor:pointer;padding:6px 12px';
              lockBtn.onmouseenter = () => lockBtn.style.background = "#555";
              lockBtn.onmouseleave = () => lockBtn.style.background = "transparent";
              lockBtn.onclick = () => {
                lockSelectedNodes(true);
                menuDiv.remove();
              };
              menuDiv.appendChild(lockBtn);

              // --- Unlock Selected Nodes ---
              const unlockBtn = document.createElement('div');
              unlockBtn.textContent = "Unlock Selected Nodes";
              unlockBtn.style.cssText = 'cursor:pointer;padding:6px 12px';
              unlockBtn.onmouseenter = () => unlockBtn.style.background = "#555";
              unlockBtn.onmouseleave = () => unlockBtn.style.background = "transparent";
              unlockBtn.onclick = () => {
                lockSelectedNodes(false);
                menuDiv.remove();
              };
              menuDiv.appendChild(unlockBtn);
            }
            document.body.appendChild(menuDiv);

            // Auto-remove menu on outside click
            setTimeout(() => {
              document.addEventListener("click", function handler() {
                menuDiv.remove();
                document.removeEventListener("click", handler);
              });
            }, 10);
          });
        });
      
      try{ window.__autoRefresh = false; }catch(_){}
      }, 1000);

      // ---- SNAP TO GRID ----
      const SNAP_GRID_SIZE = 20;
      function snapToGrid(val, grid = SNAP_GRID_SIZE) {
        return Math.round(val / grid) * grid;
      }

      function zoomDrawflowToFit(margin = 20) {
      // Shrink-to-fit, then dock the flow to the top-left (with clamping so nothing goes off-screen).
      const canvas = document.getElementById('drawflow');
      if (!canvas) return;
      const precanvas = (window.editor && window.editor.precanvas) ? window.editor.precanvas : canvas;

      const nodes = canvas.querySelectorAll('.drawflow-node');
      if (!nodes.length) return;

      // 1) Compute bounding box of all nodes (in canvas coordinates, unscaled)
      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
      nodes.forEach(node => {
        const x = parseFloat(node.style.left) || 0;
        const y = parseFloat(node.style.top)  || 0;
        const w = node.offsetWidth;
        const h = node.offsetHeight;
        if (!isFinite(x) || !isFinite(y) || !isFinite(w) || !isFinite(h)) return;
        minX = Math.min(minX, x);
        minY = Math.min(minY, y);
        maxX = Math.max(maxX, x + w);
        maxY = Math.max(maxY, y + h);
      });

      if (!isFinite(minX) || !isFinite(minY) || !isFinite(maxX) || !isFinite(maxY)) return;

      // 2) Container size
      const cW = canvas.clientWidth;
      const cH = canvas.clientHeight;

      // 3) Desired inner area (leave margin inside viewport), and shrink-only scale
      const flowW = Math.max(1, maxX - minX);
      const flowH = Math.max(1, maxY - minY);
      const innerW = Math.max(1, cW - margin);
      const innerH = Math.max(1, cH - margin);
      let zoom = Math.min(innerW / flowW, innerH / flowH);
      if (!isFinite(zoom) || zoom <= 0) zoom = 1;
      if (zoom > 1) zoom = 1; // never upscale

      // Extra breathing room: a tad more zoom-out so it "goes a little more"
      zoom *= 0.92; // 8% extra shrink so nothing hugs the edges
      if (zoom <= 0) zoom = 0.1;

      // 4) Target padding at top/left (dock); clamp to stay fully visible
      const padX = Math.min(Math.max(0, margin), cW); // clamp margin into viewport
      const padY = Math.min(Math.max(0, margin), cH);

      // naive offsets that place top-left of flow at (padX, padY)
      let offsetX = padX - (minX * zoom);
      let offsetY = padY - (minY * zoom);

      // Clamp offsets so the right/bottom edges don't exceed the viewport
      // and the left/top edges never go negative.
      const minOffsetX = -(minX * zoom);          // ensures left edge >= 0
      const minOffsetY = -(minY * zoom);          // ensures top edge >= 0
      const maxOffsetX = cW - (maxX * zoom);      // ensures right edge <= canvas width
      const maxOffsetY = cH - (maxY * zoom);      // ensures bottom edge <= canvas height

      // Prefer docking (padX/padY), but clamp both ends
      offsetX = Math.max(minOffsetX, Math.min(offsetX, Math.max(maxOffsetX, padX)));
      offsetY = Math.max(minOffsetY, Math.min(offsetY, Math.max(maxOffsetY, padY)));

      // 5) Apply transform (use origin at top-left to make math intuitive)
      precanvas.style.transformOrigin = '0 0';
      precanvas.style.transform = `translate(${offsetX}px, ${offsetY}px) scale(${zoom})`;
      if (window.editor) window.editor.zoom = zoom;
    }

    function checkIfFlowIsInUse(flowFileName, appId, token) {
      let loggingEnabled = false;

      fetch(`/apps/api/${appId}/activeFlows?access_token=${token}`)
        .then(resp => resp.json())
        .then(list => {
          const inUse       = list.filter(x => x.flowName === flowFileName + ".json");
          const statusDiv   = document.getElementById("flowTesterContent") || document.getElementById("flowTesterContent") || document.getElementById("flowTestStatus");
          const activateBtn = document.getElementById("activateFlowButton");
          const logBtn      = document.getElementById("loggingButton");

          // ‚îÄ‚îÄ Update the ‚ÄúActivate Flow‚Äù button state ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
          if (inUse.length > 0) {
            activateBtn.textContent = "Activated";
            activateBtn.style.backgroundColor = "#4CAF50";  // Green
          } else {
            activateBtn.textContent = "Deactivated";
            activateBtn.style.backgroundColor = "#808080";  // Grey
          }

          if (inUse.length > 0) {
            // Flow is active: check if logging is enabled
            fetch(`/apps/api/${appId}/settings?access_token=${token}`)
              .then(r => r.json())
              .then(settings => {
                loggingEnabled = Array.isArray(settings?.perFlowLogEnabled) &&
                  settings.perFlowLogEnabled.includes(flowFileName + ".json");

                // ‚îÄ‚îÄ Update the ‚ÄúLogging‚Äù button ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                logBtn.textContent = loggingEnabled ? "Logging Enabled" : "Logging Disabled";
                logBtn.style.backgroundColor = loggingEnabled ? "#4CAF50" : "#808080";

                //hideTestUI();
                // ‚îÄ‚îÄ Build the status panel UI ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                const topName = document.getElementById("flowStatusName");
                const topFlags = document.getElementById("flowStatusFlags");
                if (topName) { topName.textContent = (flowFileName || "").replace(/\.json$/i,""); try{ fitFlowName(); }catch(_){}}
                if (topFlags) topFlags.innerHTML = `Flow is Active | ${loggingEnabled ? "Logging is Enabled" : "Logging is Disabled"}`;
                statusDiv.innerHTML = `
                  <div>
                    <button id="lastTraceBtn"
                      style="margin-left:2px;font-size:10px;padding:3px 5px;border-radius:7px;cursor:pointer;background:#808080;color:#fff;border:none;">
                      Last Trace
                    </button>
                    <button id="clearTraceBtn"
                      style="margin-left:2px;font-size:10px;padding:3px 5px;border-radius:7px;cursor:pointer;background:#808080;color:#fff;border:none;">
                      Clear Trace
                    </button>
                  </div>
                  <input id="testFlowInput" type="text"
                        placeholder="Test value..."
                        style="margin:4px 0; padding:7px 9px; border:1px solid #aaa; border-radius:5px; font-size:12px; width:160px; margin-right:8px;">
                  <button id="testFlowBtn"
                          style="background:#1b9b1b; color:#fff; border:none; padding:6px 10px; border-radius:5px; cursor:pointer; font-size:12px; margin-right:10px;">
                    ‚ñ∂Ô∏è Test
                  </button><br>
                  <label style="margin-left:8px; font-size:13px;">
                    <input type="checkbox" id="dryRunCheckbox" />
                    Dry Run
                  </label>
                  <br><small>To test this Flow, simply enter a value and click Test.</small>
                `;
                // ‚îÄ‚îÄ TEST‚ÄëFLOW BUTTON HANDLER (auto‚Äëpick first eventTrigger) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                const testBtn        = document.getElementById("testFlowBtn");
                const testInput      = document.getElementById("testFlowInput");
                const dryRunCheckbox = document.getElementById("dryRunCheckbox");

                testBtn.onclick = async () => {
                  const saveBtn = document.getElementById("sendFlow");
                  if (saveBtn && saveBtn.classList.contains("need-save")) {
                    alert("Please save file before Testing.");
                    return;
                  }
                  // clear node highlights
                  document.querySelectorAll(
                    '.drawflow-node.executed, .drawflow-node.last-executed, .drawflow-node.flow-path'
                  ).forEach(el => el.classList.remove('executed','last-executed','flow-path'));

                  // clear path highlights
                  document.querySelectorAll('.main-path.highlighted, .main-path.live-highlight').forEach(path => {
                    path.removeAttribute('stroke');
                    path.removeAttribute('style');
                    path.classList.remove('highlighted','live-highlight');
                  });

                  // 1) Normalize test value
                  const raw = testInput.value.trim();
                  if (!raw) {
                    alert("Please enter a test value.");
                    return;
                  }
                  let val = raw
                    .toLowerCase()
                    .replace(/(\d{1,2}):(\d{2})\s*(am|pm)/g, (_, h, m, ampm) => {
                      let hh = parseInt(h, 10) % 12;
                      if (ampm === "pm") hh += 12;
                      return (hh < 10 ? "0" + hh : hh) + ":" + m;
                    });

                  // 2) Pick the flow file
                  const dropdown = document.getElementById("hubitatFileDropdown");
                  let flow = dropdown.value.trim();
                  if (!flow.endsWith(".json")) flow += ".json";
                  if (!flow) {
                    alert("Please select a flow to test.");
                    return;
                  }

                  // 3) Credentials
                  const appId = document.getElementById("hubitatAppId").value.trim();
                  const token = document.getElementById("hubitatToken").value.trim();
                  if (!appId || !token) {
                    alert("Missing Hubitat App ID or Token.");
                    return;
                  }
                  const dryRun = dryRunCheckbox.checked;

                  // 4) Get dynamic sunrise/sunset times
                  async function getDynamicSunTimes() {
                    let lat = 42.36, lng = -71.06;
                    try {
                      if (navigator.geolocation) {
                        const pos = await new Promise((resolve, reject) =>
                          navigator.geolocation.getCurrentPosition(resolve, reject, {timeout: 2000}));
                        lat = pos.coords.latitude;
                        lng = pos.coords.longitude;
                      }
                    } catch(e) {}
                    try {
                      if (typeof SunCalc !== "undefined" && SunCalc.getTimes) {
                        const times = SunCalc.getTimes(new Date(), lat, lng);
                        const pad = n => (n < 10 ? "0" : "") + n;
                        return {
                          sunrise: pad(times.sunrise.getHours()) + ":" + pad(times.sunrise.getMinutes()),
                          sunset:  pad(times.sunset.getHours())  + ":" + pad(times.sunset.getMinutes())
                        };
                      }
                    } catch(e) {}
                    return { sunrise: "06:00", sunset: "20:00" };
                  }

                  const SUN_TIMES = await getDynamicSunTimes();

                  // 5) Find matching trigger node(s)
                  const df   = editor.drawflow?.drawflow || editor.drawflow;
                  const data = df?.Home?.data || {};

                  const triggers = Object.entries(data).filter(([id, nd]) => {
                    if (nd.name !== 'eventTrigger') return false;

                    // --- TIME TRIGGERS ---
                    if (nd.data.deviceId === "__time__") {
                      // --- BETWEEN (ex: between sunrise and 12:00) ---
                      if (nd.data.comparator === "between" && Array.isArray(nd.data.value)) {
                        let [start, end] = nd.data.value.map(String);
                        start = SUN_TIMES[start] || start;
                        end   = SUN_TIMES[end]   || end;
                        const toMins = t => {
                          const [h, m] = (t + ":").split(":").map(Number);
                          return h*60 + (m || 0);
                        };
                        const testMins  = toMins(val);
                        const startMins = toMins(start);
                        const endMins   = toMins(end);
                        if (startMins <= endMins) {
                          return testMins >= startMins && testMins <= endMins;
                        } else {
                          return testMins >= startMins || testMins <= endMins;
                        }
                      } else {
                        // single time, sunrise, sunset
                        if (val === "sunrise" || val === "sunset") {
                          return (nd.data.value || "").toLowerCase() === val; // lowercase compare
                        }
                        let triggerVal = SUN_TIMES[nd.data.value] || nd.data.value;
                        return String(triggerVal).toLowerCase() === String(val); // lowercase compare
                      }
                    }

                    // --- DEVICE TRIGGERS W/KNOWN VALUES ---
                    if (nd.data.attribute && window.ATTRIBUTE_KNOWN_VALUES && ATTRIBUTE_KNOWN_VALUES[nd.data.attribute]) {
                      return ATTRIBUTE_KNOWN_VALUES[nd.data.attribute]
                        .map(v => v.toLowerCase())
                        .includes(val);
                    }

                    // --- FALLBACK: EXACT MATCH (lowercase both sides) ---
                    return String(nd.data.value).toLowerCase() === val;
                  });

                  if (!triggers.length) {
                    alert(`No Trigger node matching test value "${val}" found.`);
                    return;
                  }

                  // Honor user-selected trigger only if it exists *in this flow*
                  // Avoid calling getNodeFromId unless the id is valid in current data
                  let selId = editor && editor.selected_id;
                  let node  = null;
                  if (selId && data && Object.prototype.hasOwnProperty.call(data, selId) &&
                      triggers.some(([id]) => id === selId)) {
                    node = data[selId]; // use current data snapshot
                  } else if (triggers.length) {
                    [selId, node] = triggers[0];
                  } else {
                    alert("No Event Trigger node found to Test.");
                    return;
                  }

                    // 6) Gather deviceIds from that trigger node
                    const deviceIds = Array.isArray(node.data.deviceIds)
                      ? node.data.deviceIds
                      : (node.data.deviceId ? [node.data.deviceId] : []);

                    // 7) Build payload & invoke testFlow
                    const payload = { flow, value: val, dryRun, deviceIds };
                    logAction(
                      `‚ñ∂Ô∏è Running flow "${flow}"${dryRun ? " (dry run)" : ""}` +
                      ` on ${deviceIds.length} device(s) with value "${val}"`,
                      "info"
                    );

                    try {
                      const res = await fetch(
                        `/apps/api/${appId}/testFlow?access_token=${token}`, {
                          method:  "POST",
                          headers: { 'Content-Type':'application/json' },
                          body:    JSON.stringify(payload)
                        }
                      );
                      if (!res.ok) throw new Error(await res.text());
                      const result = await res.json();
                      logAction(`‚úÖ Test successful: ${JSON.stringify(result)}`, "info");
                    }
                    catch (err) {
                      logAction(`‚ùå Test failed: ${err}`, "error");
                    }
                  };
                })
                .catch(err => {
                  console.error("Error fetching logging settings:", err);
                  logBtn.textContent = "Logging Disabled";
                  logBtn.style.backgroundColor = "#808080";
                });
            } else {
              // No flow active ‚Üí clear status panel & reset logging button
              const topName = document.getElementById("flowStatusName");
              const topFlags = document.getElementById("flowStatusFlags");
              if (topName) { topName.textContent = (flowFileName || "").replace(/\.json$/i,""); try{ fitFlowName(); }catch(_){}}
              if (topFlags) topFlags.innerHTML = `Flow is NOT Active | ${loggingEnabled ? "Logging is Enabled" : "Logging is Disabled"}`;
              statusDiv.innerHTML = `<span style="color:#b00; font-weight:600;">Activate Flow in Hubitat to enable Testing</span>`;
              logBtn.textContent = "Logging Disabled";
              logBtn.style.backgroundColor = "#808080";
            }
            pollFlowTraceUntilEnd();
          })
          .catch(e => {
            // On error, revert to safe defaults
            const activateBtn = document.getElementById("activateFlowButton");
            const logBtn      = document.getElementById("loggingButton");
            activateBtn.textContent = "Deactivated";
            activateBtn.style.backgroundColor = "#808080";
            logBtn.textContent      = "Logging Disabled";
            logBtn.style.backgroundColor = "#808080";
            const statusDiv = document.getElementById("flowTesterContent") || document.getElementById("flowTesterContent") || document.getElementById("flowTestStatus");
            if (statusDiv) {
              statusDiv.innerHTML = `<span style="color:#b00;">Failed to check flow status.</span>`;
            }
            console.error("Failed to fetch active flows:", e);
          });
        }

        function getNextNodePosition() {
          // Always use current visible canvas/grid size
          const grid = document.getElementById("drawflow");
          const cW = grid.offsetWidth;
          const cH = grid.offsetHeight;

          // Start in top-right, move down for each new node
          const col = window.nextNodeCol;
          const idx = window.nextNodeIndex;

          // Each column, 160px to the left
          const x = cW - window.nodeStartMargin - (col * 180);
          const y = window.nodeStartMargin + (idx * window.nodeYIncrement);

          // Move to next column if near bottom (using grid height or a limit)
          if (y + window.nodeYIncrement > cH - window.nodeStartMargin) {
            window.nextNodeCol += 1;
            window.nextNodeIndex = 0;
            return getNextNodePosition();
          } else {
            window.nextNodeIndex += 1;
            return { x, y };
          }
        }

        // Call this to reset placement after loading/clearing a flow
        function resetNodePlacement() {
          window.nextNodeCol = 0;
          window.nextNodeIndex = 0;
        }

        function getTopLeftOnScreenCoords(margin = 28) {
          const grid = document.getElementById('drawflow');
          let pan = { x: 0, y: 0 };
          let zoom = 1;
          if (window.editor && window.editor.precanvas && window.editor.precanvas.style.transform) {
            const match = window.editor.precanvas.style.transform.match(/translate\(([-\d.]+)px,\s*([-\d.]+)px\)\s*scale\(([\d.]+)\)/);
            if (match) {
              pan.x = parseFloat(match[1]);
              pan.y = parseFloat(match[2]);
              zoom = parseFloat(match[3]);
            }
          }
          // Add cumulative offset for each new node
          let x = ((margin + window.newNodeOffsetX - pan.x) / zoom);
          let y = ((margin + window.newNodeOffsetY - pan.y) / zoom);
          return { x, y };
        }

        

        // keep this helper
        function highlightFlowPathDelayed(run, delayMs = 100) {
          setTimeout(() => highlightFlowPath(run), delayMs);
        }

        async function fetchHubitatFileContent(fileName) {
          // Unified file fetcher:
          // - For user-editable flows: ALWAYS use /local/<name>.json
          // - For internal FE_* files (e.g., FE_lasttrace.json): use the Hubitat app file endpoint
          const ensureJson = (txt) => {
            try { return JSON.parse(txt); } catch (_) { return txt; }
          };

          const full = (String(fileName||"").endsWith(".json") ? String(fileName) : String(fileName) + ".json");

          // Treat files starting with FE_ as internal artifacts managed by the app
          const isInternal = /^FE_/i.test(full);

          if (!isInternal) {
            const url = `/local/${encodeURIComponent(full)}?ts=${Date.now()}`;
            return fetch(url, { method: "GET", cache: "no-store" })
              .then(res => res.ok ? res.text() : Promise.reject(new Error(`GET ${url} failed: ${res.status}`)))
              .then(ensureJson);
          }

          // Internal files fetched from the app API
          const appId = (document.getElementById("hubitatAppId")?.value || localStorage.getItem('hubitatAppId') || '').trim();
          const token = (document.getElementById("hubitatToken")?.value || localStorage.getItem('hubitatToken') || '').trim();
          if (!appId || !token) {
            logAction("Enter App ID and Access Token!", "error");
            return Promise.reject(new Error("Missing credentials"));
          }
          const url = `/apps/api/${appId}/getFile?name=${encodeURIComponent(full)}&access_token=${encodeURIComponent(token)}`;
          return fetch(url, { method: "GET", cache: "no-store" })
            .then(async res => {
              const raw = await res.text();
              if (!res.ok) throw new Error(`HTTP ${res.status}: ${raw}`);
              return ensureJson(raw);
            })
            .catch(e => { logAction("Failed to fetch file content: " + (e?.message || e), "error"); throw e; });
        }

        document.addEventListener("DOMContentLoaded", function () {
          const drawflow = document.getElementById("drawflow");
          const fileInput = document.getElementById("bgImageFile");
          const slider = document.getElementById('gridBrightnessSlider');
          const bgImageBtn = document.getElementById('bgImageBtn');
          const snapToGridToggle = document.getElementById('snapToGridToggle');

          // --- Open file picker on button click
          bgImageBtn.onclick = function() {
            fileInput.click();
          };

          // --- Storage helpers ---
          function savePrefs(obj) {
            localStorage.setItem("fe_bg_prefs", JSON.stringify(obj));
          }
          function loadPrefs() {
            try {
              return JSON.parse(localStorage.getItem("fe_bg_prefs")) || {};
            } catch (e) { return {}; }
          }

          // --- Restore settings from storage
          let prefs = loadPrefs();
          if (prefs.bgImage && prefs.bgImageType === "file") {
            try { document.documentElement.style.setProperty('--fe-bg-image', 'url("' + prefs.bgImage + '")'); } catch(_) {}
            drawflow && drawflow.classList.add('image-bg');
          }
          if (prefs.imageBrightness) {
            try { document.documentElement.style.setProperty('--fe-bg-brightness', String(prefs.imageBrightness)); } catch(_) {}
            if (slider) slider.value = String(prefs.imageBrightness);
          }
          if (prefs.snapToGrid !== undefined) {
            snapToGridToggle.checked = !!prefs.snapToGrid;
          }

          // --- File picker: load and display image
          fileInput.addEventListener("change", function () {
            const file = fileInput.files[0];
            if (file) {
              const reader = new FileReader();
              reader.onload = function (e) {
                // removed: img.src assignment; using CSS var now;
                drawflow.classList.add('image-bg');
                img.style.display = "";
                let p = loadPrefs();
                p.bgImage = e.target.result;
                p.bgImageType = "file";
                savePrefs(p);
              };
              reader.readAsDataURL(file);
            }
          });

          // --- Brightness slider
          slider.addEventListener('input', function () {
            const val = String(Math.min(1, Math.max(0, Number(slider.value))));
            img.style.opacity = val;
            let p = loadPrefs();
            p.imageBrightness = val;
            savePrefs(p);
            markFlowNeedsSave(true)
          });

          // --- Snap to grid: remember setting
          snapToGridToggle.addEventListener('change', function () {
            let p = loadPrefs();
            p.snapToGrid = snapToGridToggle.checked;
            savePrefs(p);
            markFlowNeedsSave(true)
          });
        });

        // Replace fetchHubitatVarFileContent if it's missing
        if (typeof fetchHubitatVarFileContent !== "function") {
          window.fetchHubitatVarFileContent = async function(filename) {
            console.warn("Stub: Pretending to load file:", filename);
            return ""; // Return empty content
          };
        }

        // Also patch uploadToHubitatFile if missing to avoid other issues
        if (typeof uploadToHubitatFile !== "function") {
          window.uploadToHubitatFile = async function(filename, content, options) {
            console.warn("Stub: Pretending to upload file:", filename);
            return true;
          };
        }

        // Patch alert if message is "Failed to get file: null"
        const originalAlert = window.alert;
        window.alert = function(message) {
          if (typeof message === "string" && message.includes("Failed to get file: null")) {
            console.warn("Suppressed alert:", message);
          } else {
            originalAlert(message);
          }
        };

        // Load globals now that patch is safe
        window.addEventListener("DOMContentLoaded", function() {
          autoLoadGlobalVarsFromHubitat();
        });
          
        function forceFixPortsOnAllNodes() {
          const module = window.editor.module || "Home";
          const nodes = window.editor.drawflow.drawflow[module].data;
          let changed = false;
          Object.entries(nodes).forEach(([id, node]) => {
            let t = (node.name || '').toLowerCase();
            let fix = false;

            if (t === 'eventtrigger' || t === 'schedule') {
            // 0 input, 1 output
            if (Object.keys(node.inputs).length !== 0) {
              node.inputs = {};
              fix = true;
            }
            if (Object.keys(node.outputs).length !== 1) {
              node.outputs = { "output_1": { connections: [] } };
              fix = true;
            }
          } else if (t === 'condition' || t === 'notmatchingvar') {
            // 1 input, 2 outputs
            if (Object.keys(node.inputs).length !== 1) {
              node.inputs = { "input_1": { connections: [] } };
              fix = true;
            }
            if (Object.keys(node.outputs).length !== 2) {
              node.outputs = {
                "output_1": { connections: [] },
                "output_2": { connections: [] }
              };
              fix = true;
            }
          } else if (t === 'donothing' || t === 'repeat') {
            // 1 input, 0 outputs
            if (Object.keys(node.inputs).length !== 1) {
              node.inputs = { "input_1": { connections: [] } };
              fix = true;
            }
            if (Object.keys(node.outputs).length !== 0) {
              node.outputs = {};
              fix = true;
            }
          } else if (t === 'comment') {
            // 0 input, 0 outputs
            if (Object.keys(node.inputs).length !== 0) {
              node.inputs = {};
              fix = true;
            }
            if (Object.keys(node.outputs).length !== 0) {
              node.outputs = {};
              fix = true;
            }
          } else {
            // All others: 1 input, 1 output
            if (Object.keys(node.inputs).length !== 1) {
              node.inputs = { "input_1": { connections: [] } };
              fix = true;
            }
            if (Object.keys(node.outputs).length !== 1) {
              node.outputs = { "output_1": { connections: [] } };
              fix = true;
            }
          }

          if (fix) changed = true;
        });
        if (changed) {
          window.editor.import(window.editor.export());
        }
      }

      document.getElementById('bgImageBtn').onclick = function() {
        document.getElementById('bgImageFile').click();
      };

      document.getElementById('bgImageFile').onchange = function(e) {
        const file = e.target.files[0];
        if (file) {
          const reader = new FileReader();
          reader.onload = function(evt) {
            // removed: img.src assignment; using CSS var now;
            img.style.display = '';
          };
          reader.readAsDataURL(file);
        }
      };

      document.getElementById('gridBrightnessSlider').addEventListener('input', function(e) {
        document.querySelector("#drawflow > #drawflow-bg-image").style.opacity = e.target.value;
      });

      //*****************************************************
      //  Export a Flow
      document.getElementById("exportAnonFlow").onclick = function() {
        if (!editor || !editor.export) return;

        // 1) Export the current flow
        let flow = editor.export();

        // 2) Strip out any device references
        if (flow?.drawflow?.Home?.data) {
          Object.values(getHomeDataFrom(flow)).forEach(node => {
            if (node.data) {
              node.data.deviceId    = "";
              node.data.deviceIds   = [];
              node.data.deviceLabel = "";
            }
          });
        }

        // 3) Build the blob & URL
        const blob = new Blob([JSON.stringify(flow, null, 2)], { type: "application/json" });
        const url  = URL.createObjectURL(blob);

        // 4) Determine filename from your <span id="flowName">‚Ä¶</span>
        const rawName = document.getElementById("flowName").textContent.trim();
        // If it ends in ‚Äú.json‚Äù, drop that
        const base    = rawName.toLowerCase().endsWith(".json")
                      ? rawName.slice(0, -5)
                      : rawName;
        const name    = base || "flow";  // fallback

        // 5) Trigger download
        const a = document.createElement("a");
        a.href     = url;
        a.download = `${name}_anonymized.json`;
        a.click();

        // 6) Cleanup
        setTimeout(() => URL.revokeObjectURL(url), 1000);
      };

      if (
        window.flowTraceSocket &&
        window.flowTraceSocket.readyState === WebSocket.OPEN
      ) {
        window.flowTraceSocket.close();
        logAction("Closed old ws", "info")
      }
    </script>
    <script>
      // A global Set to track selected nodes for multi-select
      // FE Selection: normalized Set wrapper (accepts '123' and 'node-123')
      if (!window._multiSelectedNodes || !window._multiSelectedNodes.__patched) {
        (function(){
          function norm(v){ return (v==null)? null : String(v).replace(/^node-/, ''); }
          const inner = new Set();
          window._multiSelectedNodes = {
            __patched: true,
            _inner: inner,
            add: function(v){ inner.add(norm(v)); return this; },
            delete: function(v){ return inner.delete(norm(v)); },
            has: function(v){ return inner.has(norm(v)); },
            clear: function(){ inner.clear(); },
            forEach: function(cb, thisArg){ inner.forEach(function(v){ cb.call(thisArg, v); }); },
            get size(){ return inner.size; },
            [Symbol.iterator]: function(){ return inner[Symbol.iterator](); }
          };
        })();
      }
      // Call this to update visual selection UI
            function updateNodeSelectionUI() {
        var has = (window._multiSelectedNodes && window._multiSelectedNodes.has.bind(window._multiSelectedNodes)) || function(){return false;};
        document.querySelectorAll('.drawflow-node').forEach(function(node){
          var raw = node.getAttribute('id') || '';
          var norm = String(raw).replace(/^node-/, '');
          if (has(norm) || has(raw)) node.classList.add('multi-selected');
          else node.classList.remove('multi-selected');
        });
      }
      
      window.addEventListener('DOMContentLoaded', function() {
        const W = 240, H = 140;
        const MINIMAP_ID = 'minimap-container';
        const CANVAS_ID = 'minimap-canvas';
        const STORAGE_KEY = "fe_minimap_pos";

        // Respect saved visibility
        const container = document.getElementById(MINIMAP_ID);

        // ---- DRAGGABLE MINIMAP LOGIC (with persistent storage) ----
        let isDragging = false, startX = 0, startY = 0, origX = 0, origY = 0;

        // Load position from storage (if any)
        function restoreMinimapPosition() {
          try {
            const pos = JSON.parse(localStorage.getItem(STORAGE_KEY));
            if (pos && typeof pos.left === "number" && typeof pos.top === "number") {
              container.style.left = pos.left + "px";
              container.style.top = pos.top + "px";
              container.style.right = "auto";
              container.style.bottom = "auto";
            } else {
              container.style.right = "28px";
              container.style.bottom = "24px";
            }
          } catch(e) {
            // fallback
            container.style.right = "28px";
            container.style.bottom = "24px";
          }
        }
        restoreMinimapPosition();

        container.addEventListener('mousedown', function(e) {
          // Only drag if clicking the container or canvas, not the inner label
          if (e.target.id !== MINIMAP_ID && e.target.id !== CANVAS_ID) return;
          isDragging = true;
          startX = e.clientX;
          startY = e.clientY;
          const rect = container.getBoundingClientRect();
          origX = rect.left;
          origY = rect.top;
          container.style.transition = "none";
          e.preventDefault();
        });

        document.addEventListener('mousemove', function(e) {
          if (!isDragging) return;
          const dx = e.clientX - startX;
          const dy = e.clientY - startY;
          const newLeft = origX + dx;
          const newTop = origY + dy;
          container.style.left = newLeft + "px";
          container.style.top = newTop + "px";
          container.style.right = "auto";
          container.style.bottom = "auto";
          // Save live while dragging
          localStorage.setItem(STORAGE_KEY, JSON.stringify({ left: newLeft, top: newTop }));
        });

        document.addEventListener('mouseup', function() {
          if (isDragging) {
            isDragging = false;
            container.style.transition = "";
            // Save one more time in case of final position
            const rect = container.getBoundingClientRect();
            localStorage.setItem(STORAGE_KEY, JSON.stringify({ left: rect.left, top: rect.top }));
          }
        });

        // Set initial left/top if not set
        container.style.position = "fixed";
        if (!container.style.left && !container.style.top) {
          container.style.right = "28px";
          container.style.bottom = "24px";
        }

        // ---- REALISTIC MINIMAP DRAWING ----
        function getNodeStyleAndLabel(id, n) {
          const el = document.getElementById('node-' + id);
          let bg = '#3ad688', border = '#222', txt = '';
          if (el) {
            const comp = window.getComputedStyle(el);
            bg = comp.backgroundColor || bg;
            border = comp.borderColor || border;
            // Use best label from tile
            const tile = el.querySelector('.trigger-tile, .device-tile, .condition-tile, .logic-node, .comment-node, .timer-tile, .delay-tile, .drawflow_content_node, div');
            if (tile) {
              txt = tile.textContent.trim().split('<br>')[0].substring(0, 6);
            } else {
              txt = el.textContent.trim().split('<br>')[0].substring(0, 6);
            }
          } else if (n.data && n.data.label) {
            txt = n.data.label.substring(0, 6);
          } else if (n.name) {
            txt = n.name.substring(0, 6);
          } else {
            txt = id;
          }
          return { bg, border, txt };
        }

        function renderMinimap() {
          const df = window.editor && window.editor.drawflow && window.editor.drawflow.drawflow;
          if (!df || !df.Home || !getHomeDataFrom(df)) return;
          const data = getHomeDataFrom(df);
          const nodes = Object.entries(data);

          if (!nodes.length) return;

          // Compute bounding box
          let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
          nodes.forEach(([id, n]) => {
            minX = Math.min(minX, n.pos_x);
            minY = Math.min(minY, n.pos_y);
            maxX = Math.max(maxX, n.pos_x + 170);
            maxY = Math.max(maxY, n.pos_y + 80);
          });
          minX -= 40; minY -= 40; maxX += 40; maxY += 40;
          const scaleX = W / Math.max(1, maxX - minX);
          const scaleY = H / Math.max(1, maxY - minY);
          const scale = Math.min(scaleX, scaleY);

          const ctx = document.getElementById(CANVAS_ID).getContext('2d');
          ctx.clearRect(0, 0, W, H);

          // Draw connections
          nodes.forEach(([id, n]) => {
            Object.values(n.outputs || {}).forEach(out => {
              (out.connections || []).forEach(conn => {
                const target = data[conn.node];
                if (!target) return;

                const x1 = Math.round((n.pos_x - minX + 80) * scale);
                const y1 = Math.round((n.pos_y - minY + 35) * scale);
                const x2 = Math.round((target.pos_x - minX + 80) * scale);
                const y2 = Math.round((target.pos_y - minY + 35) * scale);

                // Find the real DOM path element
                const pathEl = document.querySelector(
                  `.connection.node_out_node-${id}.node_in_node-${conn.node} .main-path,
                  .connection[data-from="${id}"][data-to="${conn.node}"] .main-path`
                );

                // Style based on whether it's highlighted upstream
                if (pathEl && pathEl.classList.contains('highlighted')) {
                  ctx.strokeStyle = "limegreen";
                  ctx.globalAlpha  = 1;
                  ctx.lineWidth    = 2;
                } else {
                  ctx.strokeStyle = "#888";
                  ctx.globalAlpha  = 0.85;
                  ctx.lineWidth    = 1.2;
                }

                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.bezierCurveTo(
                  x1 + 32, y1,
                  x2 - 32, y2,
                  x2, y2
                );
                ctx.stroke();
              });
            });
          });

          // Draw nodes with real color, border, label, and flow-path highlights
          nodes.forEach(([id, n]) => {
            const x = Math.round((n.pos_x - minX) * scale);
            const y = Math.round((n.pos_y - minY) * scale);
            const w = Math.max(30, Math.round(120 * scale));
            const h = Math.max(18, Math.round(48  * scale));

            // grab base style & label
            let { bg, border, txt } = getNodeStyleAndLabel(id, n);

            // if this node is in the active flow-path, force green
            const nodeEl = document.getElementById('node-' + id);
            if (nodeEl && nodeEl.classList.contains('flow-path')) {
              bg     = 'limegreen';
              border = 'limegreen';
            }

            // draw the box
            ctx.save();
            ctx.globalAlpha = 0.93;
            ctx.fillStyle   = bg;
            ctx.strokeStyle = border;
            ctx.lineWidth   = 1.8;
            ctx.beginPath();
            ctx.moveTo(x+4, y);
            ctx.lineTo(x+w-4, y);
            ctx.quadraticCurveTo(x+w, y, x+w, y+4);
            ctx.lineTo(x+w, y+h-4);
            ctx.quadraticCurveTo(x+w, y+h, x+w-4, y+h);
            ctx.lineTo(x+4, y+h);
            ctx.quadraticCurveTo(x, y+h, x, y+h-4);
            ctx.lineTo(x, y+4);
            ctx.quadraticCurveTo(x, y, x+4, y);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            ctx.restore();

            // Highlight selected node(s)
            const isSelected =
              (window._multiSelectedNodes && window._multiSelectedNodes.has(String(id))) ||
              (editor.selected_id && String(editor.selected_id) === String(id));
            if (isSelected) {
              ctx.save();
              ctx.shadowColor = "#00fff7";
              ctx.shadowBlur  = 10;
              ctx.strokeStyle = "#00fff7";
              ctx.lineWidth   = 4;
              ctx.globalAlpha = 0.92;
              ctx.beginPath();
              ctx.moveTo(x+4, y);
              ctx.lineTo(x+w-4, y);
              ctx.quadraticCurveTo(x+w, y, x+w, y+4);
              ctx.lineTo(x+w, y+h-4);
              ctx.quadraticCurveTo(x+w, y+h, x+w-4, y+h);
              ctx.lineTo(x+4, y+h);
              ctx.quadraticCurveTo(x, y+h, x, y+h-4);
              ctx.lineTo(x, y+4);
              ctx.quadraticCurveTo(x, y, x+4, y);
              ctx.closePath();
              ctx.stroke();
              ctx.restore();
            }

            // Draw label
            ctx.save();
            ctx.font         = `bold ${Math.max(9, Math.round(h / 2.3))}px sans-serif`;
            ctx.fillStyle    = "#181d20";
            ctx.globalAlpha  = 1.0;
            ctx.textAlign    = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(txt, x + w/2, y + h/2);
            ctx.restore();
          });

          // Draw viewport rectangle
          const precanvas = document.querySelector('.drawflow');
          if (precanvas) {
            const transform = window.getComputedStyle(precanvas).transform;
            let translateX = 0, translateY = 0, scaleDF = 1;
            if (transform && transform !== "none") {
              const match = transform.match(/matrix\(([^)]+)\)/);
              if (match) {
                const parts = match[1].split(',');
                scaleDF      = parseFloat(parts[0]);
                translateX   = parseFloat(parts[4]);
                translateY   = parseFloat(parts[5]);
              }
            }
            const rect   = document.getElementById('drawflow').getBoundingClientRect();
            const flowW  = rect.width, flowH = rect.height;
            const visX   = (-translateX) / scaleDF;
            const visY   = (-translateY) / scaleDF;
            const vx     = (visX - minX) * scale;
            const vy     = (visY - minY) * scale;
            const vw     = flowW / scaleDF * scale;
            const vh     = flowH / scaleDF * scale;
            ctx.save();
            ctx.strokeStyle = "#f4e43a";
            ctx.globalAlpha = 0.9;
            ctx.lineWidth   = 2;
            ctx.strokeRect(vx, vy, vw, vh);
            ctx.restore();
          }
        }

        function hookMinimapEvents() {
          if (!window.editor) return;
          window.editor.on('nodeMoved', renderMinimap);
          window.editor.on('nodeCreated', renderMinimap);
          window.editor.on('nodeRemoved', renderMinimap);
          window.editor.on('connectionCreated', renderMinimap);
          window.editor.on('connectionRemoved', renderMinimap);
          window.editor.on('import', renderMinimap);
          window.editor.on('zoom', renderMinimap);
          setInterval(renderMinimap, 2000);
        }
        document.getElementById(CANVAS_ID).addEventListener('click', function(e){
          const df = window.editor && window.editor.drawflow && window.editor.drawflow.drawflow;
          if (!df || !df.Home || !getHomeDataFrom(df)) return;
          const data = getHomeDataFrom(df);
          const nodes = Object.values(data);
          if (!nodes.length) return;

          // Compute world bounds used by minimap
          let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
          nodes.forEach(n => {
            minX = Math.min(minX, n.pos_x);
            minY = Math.min(minY, n.pos_y);
            maxX = Math.max(maxX, n.pos_x + 170);
            maxY = Math.max(maxY, n.pos_y + 80);
          });
          minX -= 40; minY -= 40; maxX += 40; maxY += 40;
          const scaleX = W / Math.max(1, maxX - minX);
          const scaleY = H / Math.max(1, maxY - minY);
          const scale  = Math.min(scaleX, scaleY);

          // Click -> world coordinate (unscaled layout pixels)
          const x = e.offsetX / scale + minX;
          const y = e.offsetY / scale + minY;

          const container = document.getElementById('drawflow');
          const precanvas = document.querySelector('.drawflow');
          const bg        = document.querySelector("#drawflow > #drawflow-bg-image");
          if (!container || !precanvas) return;

          // Scrollbar toggle (default ON unless storage '0')
          let scrollbarsOn = true;
          try { scrollbarsOn = (localStorage.getItem('fe_scrollbars_on') !== '0'); } catch(_){}

          if (scrollbarsOn) {
            // === Pure-scroll mode with scale=1 and padding to include negative coords ===
            // Neutralize transform/zoom so scroll reflects actual content geometry
            if (window.editor) {
              window.editor.canvas_x = 0;
              window.editor.canvas_y = 0;
              if (typeof window.editor.zoom === "number") window.editor.zoom = 1;
            }
            precanvas.style.transform = 'translate(0px, 0px) scale(1)';
            if (bg) bg.style.transform = '';

            // Compute padding to shift world so minX/minY are visible at scrollLeft=0/scrollTop=0
            const padLeft = Math.max(0, Math.ceil(-minX + 40));
            const padTop  = Math.max(0, Math.ceil(-minY + 40));
            const padRight = 40;
            const padBottom = 40;

            // Content box size (excluding padding)
            const baseW = Math.max(container.clientWidth,  Math.ceil((maxX - minX) + 200));
            const baseH = Math.max(container.clientHeight, Math.ceil((maxY - minY) + 200));

            // Apply geometry
            precanvas.style.paddingLeft = padLeft + 'px';
            precanvas.style.paddingTop  = padTop + 'px';
            precanvas.style.paddingRight = padRight + 'px';
            precanvas.style.paddingBottom = padBottom + 'px';
            precanvas.style.width  = baseW + 'px';
            precanvas.style.height = baseH + 'px';

            // Match background to total scrollable area so it scrolls with the flow
            const totalW = baseW + padLeft + padRight;
            const totalH = baseH + padTop  + padBottom;
            if (bg) {
              bg.style.display = 'block';
              bg.style.width  = totalW + 'px';
              bg.style.height = totalH + 'px';
            }

            // Center the clicked world point. Displayed coord = pad + (x - minX).
            const targetLeft = Math.max(0, Math.min((padLeft + (x - minX)) - (container.clientWidth  / 2), container.scrollWidth  - container.clientWidth));
            const targetTop  = Math.max(0, Math.min((padTop  + (y - minY)) - (container.clientHeight / 2), container.scrollHeight - container.clientHeight));

            container.scrollLeft = targetLeft;
            container.scrollTop  = targetTop;
            refreshConnectionsSoon();
          } else {
            // === Fallback: transform-centering (keeps current zoom) ===
            // Read current zoom from transform
            let scaleDF = 1;
            const tf = window.getComputedStyle(precanvas).transform;
            if (tf && tf !== "none") {
              const m = tf.match(/matrix\(([^)]+)\)/);
              if (m) {
                const parts = m[1].split(',');
                scaleDF = parseFloat(parts[0]);
              }
            }
            const rect = container.getBoundingClientRect();
            const targetX = -(x - rect.width  / (2 * scaleDF)) * scaleDF;
            const targetY = -(y - rect.height / (2 * scaleDF)) * scaleDF;
            if (window.editor) { window.editor.canvas_x = targetX; window.editor.canvas_y = targetY; }
            precanvas.style.transform = `translate(${targetX}px, ${targetY}px) scale(${scaleDF})`;
            if (bg) bg.style.transform = `translate(${targetX}px, ${targetY}px)`;
            refreshConnectionsSoon();
          }
        });

        hookMinimapEvents();
        // Keep connectors aligned while scrolling
        try {
          const __dfScrollEl = document.getElementById('drawflow');
          if (__dfScrollEl && !__dfScrollEl.__linesScrollHooked) {
            __dfScrollEl.__linesScrollHooked = true;
            let __last=0; let __pending=false;
            __dfScrollEl.addEventListener('scroll', function(){
              const now = performance.now();
              if (now - __last > 32) {
                __last = now;
                refreshConnectionsSoon();
              } else if (!__pending) {
                __pending = true;
                setTimeout(()=>{ __pending=false; refreshConnectionsSoon(); }, 34);
              }
            }, { passive: true });
          }
        } catch(_){}
        
        setTimeout(renderMinimap, 1000);
      });
      window.addEventListener('DOMContentLoaded', function() {
        window._multiSelectedNodes = new Set();
/* removed legacy attachNodeListeners */
let animationFrame = null;

        /* removed legacy listener for mousemove */
/* removed legacy listener for mouseup */
// Ensure every node has handler after creation/import
        if (window.editor) {
          window.editor.on('nodeCreated', function() {
updateMultiSelectUI();
          });
          window.editor.on('import', function() {
updateMultiSelectUI();
          });
          window.editor.on('nodeRemoved', function(id) {
            window._multiSelectedNodes.delete(String(id));
            updateMultiSelectUI();
          });
        }
        // Initial attach for existing nodes
});

      function getMultiSelectedNodeIds() {
        return Array.from(window._multiSelectedNodes || []);
      }

      // *******************************************
      function deleteSelectedNodes() {
        if (!window._multiSelectedNodes || window._multiSelectedNodes.size === 0) return;
        // Make a COPY of the selected IDs array
        const toDelete = Array.from(window._multiSelectedNodes);
        // Clear selection BEFORE deleting
        window._multiSelectedNodes.clear();
        // Now delete each node by id (call the same logic as single node delete)
        toDelete.forEach(id => {
          try {
            if (editor && typeof editor.removeNodeId === "function") {
              editor.removeNodeId("node-" + id);  // <-- THIS LINE FIXES IT
            }
          } catch (e) {
            // log or ignore, just in case node is already gone
          }
        });
        markFlowNeedsSave(true);
        // After delete, update editor UI
        setTimeout(() => {
          // Try to select a remaining node
          let remainingIds = [];
          if (editor.drawflow && getHomeFrom(editor) && getHomeDataFrom(editor)) {
            remainingIds = Object.keys(getHomeDataFrom(editor));
          }
          if (remainingIds.length) {
            editor.selected_id = remainingIds[0];
            window.renderEditor(editor.getNodeFromId(remainingIds[0]));
          } else {
            document.getElementById("nodeEditor").innerHTML = "Click a node to edit";
          }
        }, 10);
      }

      function duplicateSelectedNodes() {
        if (!window._multiSelectedNodes || window._multiSelectedNodes.size === 0) return;
        const toDuplicate = Array.from(window._multiSelectedNodes).map(String);
        const offsetStep = 40;
        let offset = 0;
        const newIds = [];

        toDuplicate.forEach(id => {
          const orig = editor.getNodeFromId(id);
          if (!orig) return;
          const newData = JSON.parse(JSON.stringify(orig.data));
          const nId = editor.addNode(
            orig.name,
            1, // inputs
            1, // outputs
            orig.pos_x + offset + offsetStep,
            orig.pos_y + offset + offsetStep,
            orig.class,
            newData,
            orig.html
          );
          newIds.push(nId);
          offset += offsetStep;
        });

        // Select all the new nodes
        if (newIds.length) {
          window._multiSelectedNodes = new Set(newIds.map(String));
          editor.selected_id = newIds[0];
          window.renderEditor(editor.getNodeFromId(editor.selected_id));
          markFlowNeedsSave(true);
        }
      }

      function hideContextMenu() {
        const cm = document.querySelector('.context-menu');
        if (cm) cm.remove();
      }

      function lockSelectedNodes(lockState) {
        if (!window._multiSelectedNodes || window._multiSelectedNodes.size === 0) return;
        Array.from(window._multiSelectedNodes).forEach(id => {
          const node = editor.getNodeFromId(id);
          if (node) {
            node.data.locked = !!lockState;
            editor.updateNodeDataFromId(node.id, node.data);
            editor.updateNodeHtmlFromId(node.id, nodeTileHtml(node.name, node.data, node.id));
            markFlowNeedsSave(true);
          }
        });
      }

      // Align Left: Use the left X of the first selected node
      document.getElementById("alignLeftBtn").onclick = function() {
        const sel = Array.from(window._multiSelectedNodes || []);
        if (sel.length < 2) return;
        const anchorId = sel[0];
        const anchor = editor.getNodeFromId(anchorId);
        if (!anchor) return;
        const anchorX = anchor.pos_x;
        sel.forEach(id => {
          if (id !== anchorId) {
            const n = editor.getNodeFromId(id);
            if (n) {
              n.pos_x = anchorX;
              editor.moveNodeTo(n.id, anchorX, n.pos_y);
            }
          }
        });
        markFlowNeedsSave(true);
      };

      // Align Right: Use the right edge of the first selected node
      document.getElementById("alignRightBtn").onclick = function() {
        const sel = Array.from(window._multiSelectedNodes || []);
        if (sel.length < 2) return;
        const anchorId = sel[0];
        const anchor = editor.getNodeFromId(anchorId);
        if (!anchor) return;
        const anchorRight = anchor.pos_x + 160; // 160 = node width in px
        sel.forEach(id => {
          if (id !== anchorId) {
            const n = editor.getNodeFromId(id);
            if (n) {
              n.pos_x = anchorRight - 160; // align right edge
              editor.moveNodeTo(n.id, n.pos_x, n.pos_y);
            }
          }
        });
        markFlowNeedsSave(true);
      };

      // Align Top: Use the top Y of the first selected node
      document.getElementById("alignTopBtn").onclick = function() {
        const sel = Array.from(window._multiSelectedNodes || []);
        if (sel.length < 2) return;
        const anchorId = sel[0];
        const anchor = editor.getNodeFromId(anchorId);
        if (!anchor) return;
        const anchorY = anchor.pos_y;
        sel.forEach(id => {
          if (id !== anchorId) {
            const n = editor.getNodeFromId(id);
            if (n) {
              n.pos_y = anchorY;
              editor.moveNodeTo(n.id, n.pos_x, anchorY);
            }
          }
        });
        markFlowNeedsSave(true);
      };

      // Align Bottom: Use the bottom edge of the first selected node
      document.getElementById("alignBottomBtn").onclick = function() {
        const sel = Array.from(window._multiSelectedNodes || []);
        if (sel.length < 2) return;
        const anchorId = sel[0];
        const anchor = editor.getNodeFromId(anchorId);
        if (!anchor) return;
        const anchorBottom = anchor.pos_y + 60; // 60 = node height in px
        sel.forEach(id => {
          if (id !== anchorId) {
            const n = editor.getNodeFromId(id);
            if (n) {
              n.pos_y = anchorBottom - 60; // align bottom edge
              editor.moveNodeTo(n.id, n.pos_x, n.pos_y);
            }
          }
        });
        markFlowNeedsSave(true);
      };

      // Align Center X (horizontal center): Use center X of first node
      document.getElementById("alignCenterBtn").onclick = function() {
        const sel = Array.from(window._multiSelectedNodes || []);
        if (sel.length < 2) return;
        const anchorId = sel[0];
        const anchor = editor.getNodeFromId(anchorId);
        if (!anchor) return;
        const anchorCenterX = anchor.pos_x + 160 / 2; // node width
        sel.forEach(id => {
          if (id !== anchorId) {
            const n = editor.getNodeFromId(id);
            if (n) {
              n.pos_x = anchorCenterX - 160 / 2;
              editor.moveNodeTo(n.id, n.pos_x, n.pos_y);
            }
          }
        });
        markFlowNeedsSave(true);
      };

      // Align Middle Y (vertical center): Use center Y of first node
      document.getElementById("alignMiddleBtn").onclick = function() {
        const sel = Array.from(window._multiSelectedNodes || []);
        if (sel.length < 2) return;
        const anchorId = sel[0];
        const anchor = editor.getNodeFromId(anchorId);
        if (!anchor) return;
        const anchorMiddleY = anchor.pos_y + 60 / 2; // node height
        sel.forEach(id => {
          if (id !== anchorId) {
            const n = editor.getNodeFromId(id);
            if (n) {
              n.pos_y = anchorMiddleY - 60 / 2;
              editor.moveNodeTo(n.id, n.pos_x, n.pos_y);
            }
          }
        });
        markFlowNeedsSave(true);
      };

      async function reloadHubitatApp(opts = {}) {
        const appId = document.getElementById("hubitatAppId")?.value.trim();
        const token = document.getElementById("hubitatToken")?.value.trim();
        if (!appId || !token) { 
          alert("Missing Hubitat appId/token"); 
          throw new Error("Missing Hubitat appId/token"); 
        }
        const url = `/apps/api/${appId}/forceReload?access_token=${token}`;
        const res = await fetch(url, {
          method: "POST",
          body: JSON.stringify({ action: "reload" }),
          headers: { "Content-Type": opts.mimeType || "application/json" }
        });
        if (!res.ok) {
          alert("Failed to reload app: " + (await res.text()));
          throw new Error("Failed to reload app");
        }
        return await res.json().catch(() => true);
      }

      document.addEventListener("DOMContentLoaded", function() {
        const canvas = document.getElementById("drawflow");
        if (canvas) {
          canvas.addEventListener("mousedown", function(e) {
            if (e.target === canvas) {
              window._multiSelectedNodes.clear();
              editor.selected_id = null;
              document.querySelectorAll('.drawflow-node').forEach(el => {
                el.classList.remove('selected-multi');
                el.classList.remove('selected');
              });
              // We still deselect, but leave the Node Editor alone here.
            }
          });
        }
      });

      // ‚îÄ‚îÄ Logging Button Click Handler ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      (function(){
        const el = document.getElementById("loggingButton");
        if (!el) return;
        el.addEventListener("click", async () => {
          const btn      = el;
          const flowName = (document.getElementById("hubitatFileDropdown")?.value || "").trim();
          const token    = (document.getElementById("hubitatToken")?.value || "").trim();
          const appId    = (document.getElementById("hubitatAppId")?.value || "").trim();

          // 1) Validate credentials & selection
          if (!hubitatCredentialsAreValid(true)) return;
          if (!flowName) {
            logAction("No Flow selected to change logging", "error");
            return;
          }

          // 2) Determine desired action
          const isEnabled = btn.textContent.trim() === "Logging Enabled";
          const action    = isEnabled ? "deselectFlowLog" : "selectFlowLog";
          const url       = `/apps/api/${appId}/${action}?access_token=${token}`;

          // 3) Disable button to prevent double-clicks
          btn.disabled = true;
          try {
            // 4) Call Hubitat API with JSON body
            const response = await fetch(url, {
              method:  "POST",
              headers: { "Content-Type": "application/json" },
              body:    JSON.stringify({ flow: flowName })
            });
            if (!response.ok) {
              throw new Error(`HTTP ${response.status} ${response.statusText}`);
            }
            const result = await response.json();

            // 5) Log success
            logAction(
              isEnabled
                ? `‚ùé Logging disabled: ${result.result || "OK"}`
                : `‚úÖ Logging enabled:   ${result.result || "OK"}`,
              "info"
            );

            // 6) Re-sync both buttons‚Äô state
            await checkIfFlowIsInUse(flowName, appId, token);
          } catch (err) {
            logAction(`‚ùå Failed to ${isEnabled ? "disable" : "enable"} logging: ${err}`, "error");
          } finally {
            // 7) Re-enable button
            btn.disabled = false;
          }
        });
      })();

      document.getElementById("saveAsFlow").onclick = async function() {
        // 1) Sanity check
        if (!hubitatCredentialsAreValid(true) || typeof editor.export !== "function") {
          return;
        }

        // 2) Prompt for the new name (no ‚Äú.json‚Äù)
        const flowNameEl = document.getElementById("flowName");
        let current = flowNameEl.textContent.trim();
        if (current.toLowerCase().endsWith(".json")) {
          current = current.slice(0, -5);
        }
        let name = prompt("Save flow as:", current);
        if (!name) return;  // user cancelled

        // 3) Sanitize the name
        name = name
          .replace(/\s+/g, "_")
          .replace(/[^a-zA-Z0-9_\-]/g, "")
          .replace(/_{2,}/g, "_")
          .replace(/^_+|_+$/g, "");

        // 4) Export & upload under name + ".json"
        const data = editor.export();
          __fe_stampViewport(data);
        data.flowName = name;
        if (window.flowVars?.getLocalVars) {
          data.variables = flowVars.getLocalVars();
        }
        await uploadToHubitatFile(`${name}.json`, JSON.stringify(data, null, 2));

        // 5) Update the on-page display to the bare name (no .json)
        flowNameEl.textContent = name;

        await reloadFlowDropdown(`${name}.json`);
        markFlowNeedsSave(false);
        logAction(`Saved flow as "${name}" to Hubitat File Manager.`, "success");
      };

      // ‚Äî Delete current flow and then clear UI + reload dropdown ‚Äî
      document.getElementById("deleteFlowAppBtn").onclick = async function() {
        // 1) grab credentials and the selected filename
        const token    = document.getElementById("hubitatToken").value.trim();
        const appId    = document.getElementById("hubitatAppId").value.trim();
        const dropdown = document.getElementById("hubitatFileDropdown");
        const fileName = dropdown.value.trim();

        if (!token || !appId || !fileName) {
          return logAction("Missing Token, App ID, or selected Flow", "error");
        }

        // 2) build the delete URL
        const url = `/apps/api/${appId}/deleteFile?access_token=${token}&name=${encodeURIComponent(fileName)}`;

        // 3) confirm
        if (!confirm(`Really delete "${fileName}" from Hubitat? This cannot be undone.`)) {
          return;
        }

        // 4) perform the DELETE
        try {
          const res = await fetch(url, { method: "DELETE" });
          if (!res.ok) throw new Error(await res.text());
          logAction(`‚úÖ Deleted "${fileName}" from Hubitat File Manager.`, "success");

          // 5) clear the displayed flow name
          document.getElementById("flowName").textContent = "";

          // 6) clear the canvas state
          editor.clear();
          document.getElementById("nodeEditor").innerHTML = "Click a node to edit";
        
          // 7) reset any ‚Äúin-use‚Äù flags and re-load globals
          checkIfFlowIsInUse("new", appId, token);
          await autoLoadGlobalVarsFromHubitat();
          await reloadFlowDropdown("");

          markFlowNeedsSave(false);
          logAction("Cleared workspace after deletion.", "info");
        } catch (e) {
          logAction("‚ùå Failed to delete file: " + e, "error");
        }
      };

      document.getElementById("renameFlow").onclick = async function() {
        // 1) Validate credentials & editor
        if (!hubitatCredentialsAreValid(true) || typeof editor?.export !== "function") {
          return;
        }

        // 2) Get old name and prompt for new
        const flowNameEl = document.getElementById("flowName");
        const oldName    = flowNameEl.textContent.trim();
        let newName      = prompt("Rename flow to:", oldName);
        if (!newName || newName === oldName) {
          return;
        }

        // 3) Sanitize newName (underscores, letters, numbers, dashes only)
        newName = newName
          .replace(/\s+/g, "_")
          .replace(/[^a-zA-Z0-9_\-]/g, "")
          .replace(/_{2,}/g, "_")
          .replace(/^_+|_+$/g, "");

        // 4) Export and overwrite flowName in JSON
        const data = editor.export();
          __fe_stampViewport(data);
        data.flowName = newName;
        if (window.flowVars?.getLocalVars) {
          data.variables = window.flowVars.getLocalVars();
        }

        // 5) Upload under the new filename
        await uploadToHubitatFile(newName + ".json", JSON.stringify(data, null, 2));

        // 6) Delete the old file
        const appId = document.getElementById("hubitatAppId").value.trim();
        const token = document.getElementById("hubitatToken").value.trim();
        await fetch(
          `/apps/api/${appId}/deleteFile?access_token=${token}&name=${encodeURIComponent(oldName)}`,
          { method: "DELETE" }
        );
        await reloadHubitatApp();

        // 7) Reflect the change in the UI
        flowNameEl.textContent = newName;
        const oldFilename = oldName + ".json";
        const newFilename = newName + ".json";

        await reloadFlowDropdown(`${newName}.json`);

        markFlowNeedsSave(false);
        logAction(`Renamed "${oldName}" ‚Üí "${newName}" in Hubitat File Manager.`, "success");
      };

      // ‚îÄ‚îÄ AUTO-SHOW & RESTORE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      window.addEventListener('load', function() {
        const mm = document.getElementById('minimap-container');
        if (!mm) return console.error('‚ùå minimap-container not found');
        // restore last pos or default
        try {
          const pos = JSON.parse(localStorage.getItem('fe_minimap_pos'));
          if (pos && pos.left != null && pos.top != null) {
            mm.style.left  = pos.left + 'px';
            mm.style.top   = pos.top  + 'px';
            mm.style.right = 'auto';
            mm.style.bottom= 'auto';
          }
        } catch (_) {}

        // Respect persisted visibility (same key used by the toggle)
        const on = (localStorage.getItem('fe_minimap_visible') === '1');
        mm.style.display = on ? 'block' : 'none';

        // If visible, try a render so it isn't just an empty box
        if (on) {
          if (typeof renderMinimap === 'function') renderMinimap();
          // give editor/layout a tick if needed
          setTimeout(() => { if (typeof renderMinimap === 'function') renderMinimap(); }, 300);
        }

        // Best-effort keep the button color in sync on load (without reaching into the closure)
        const btn = document.getElementById('minimapToggleButton');
        if (btn) {
          btn.style.backgroundColor = on ? '#4CAF50' : '#808080';
          btn.textContent = 'Mini-map';
        }
      });

      // ‚îÄ‚îÄ DRAG & PERSIST POSITION ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      (function enableMinimapDrag() {
        const mm = document.getElementById('minimap-container');
        if (!mm) return;

        let dragging = false,
            start   = { x: 0, y: 0 },
            origin  = { x: 0, y: 0 },
            handTimer = 0;

        // Helper to manage the cursor and keep "hand" visible for 2s after drag
        function setCursor(state){
          // clear any old linger
          if (handTimer) { clearTimeout(handTimer); handTimer = 0; }

          if (state === 'grabbing') {
            mm.style.cursor = 'grabbing';
            return;
          }
          if (state === 'grab') {
            mm.style.cursor = 'grab';
            // keep the hand for another 2 seconds
            handTimer = setTimeout(() => {
              // fall back to hover look after linger
              mm.style.cursor = 'pointer';
            }, 2000);
            return;
          }
          // default / hover
          mm.style.cursor = 'pointer';
        }

        // Default hover look = hand
        setCursor('grab');

        mm.addEventListener('mousedown', e => {
          // Only drag if clicking the container or canvas, not the inner label
          if (e.target.id !== 'minimap-container' && e.target.id !== 'minimap-canvas') return;
          dragging      = true;
          start.x       = e.clientX;
          start.y       = e.clientY;
          origin.x      = mm.offsetLeft;
          origin.y      = mm.offsetTop;
          setCursor('grabbing');           // <- was 'move'
          e.preventDefault();
        });

        document.addEventListener('mousemove', e => {
          if (!dragging) return;
          const dx = e.clientX - start.x;
          const dy = e.clientY - start.y;
          mm.style.left = origin.x + dx + 'px';
          mm.style.top  = origin.y + dy + 'px';
        });

        document.addEventListener('mouseup', () => {
          if (!dragging) return;
          dragging = false;
          setCursor('grab');               // <- was 'pointer' (now lingers 2s)
          // save new position
          localStorage.setItem('fe_minimap_pos',
            JSON.stringify({ left: mm.offsetLeft, top: mm.offsetTop })
          );
        });
      })();
   
      // ‚îÄ‚îÄ Trigger‚ÄëMatch Logging WebSocket ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      function startFlowTraceStream() {
        // don‚Äôt re‚Äëopen if already open
        if (
          window.flowTraceSocket &&
          window.flowTraceSocket.readyState === WebSocket.OPEN
        ) return;

        const appId = document.getElementById('hubitatAppId').value.trim();
        const token = document.getElementById('hubitatToken').value.trim();

        const ip    = getHubitatIP();
        if (!ip) {
          logAction('‚ö†Ô∏è Missing IP for TriggerLog WS', 'warn');
          return;
        }

        window.flowTraceSocket = new WebSocket(`ws://${ip}/eventsocket`);

        window.flowTraceSocket.addEventListener('open', () => {
          logAction('üîç WebSocket opened', 'info');
        });

        window.flowTraceSocket.addEventListener('message', ({ data }) => {
          let evt;
          try {
            evt = JSON.parse(data);
          } catch {
            return;
          }

          if (evt.source === 'LOCATION' && evt.name === 'feTrace') {
            const type = String(evt.value || '').toLowerCase();     // "start" | "step" | "end"
            const desc = String(evt.descriptionText || '');
            const m = desc.match(/\bfor\s+([^\s]+\.json)\b/i);       // may be absent (ok)
            const flowFromDesc = m ? m[1].toLowerCase() : '';

            const openRaw  = (document.getElementById('flowName')?.textContent || '').trim();
            const openFile = openRaw.toLowerCase().endsWith('.json') ? openRaw.toLowerCase()
                                                                    : (openRaw.toLowerCase() + '.json');

            if (flowFromDesc && flowFromDesc !== openFile) return;   // event is for a different flow

            if (type === 'start') {
              // clear LIVE highlights only
              document.querySelectorAll('.drawflow-node.flow-path').forEach(n => n.classList.remove('flow-path'));
              document.querySelectorAll('.main-path.live-highlight').forEach(p => {
                p.removeAttribute('stroke'); p.removeAttribute('style'); p.classList.remove('live-highlight');
              });

              window.flowTracePollingActive = true;
              if (typeof pollFlowTraceUntilEnd === 'function') { try { pollFlowTraceUntilEnd(); } catch(e) {} }
              return;
            }

            if (type === 'step') {
              if (!window.flowTracePollingActive) window.flowTracePollingActive = true;
              if (typeof pollFlowTraceUntilEnd === 'function') { try { pollFlowTraceUntilEnd(); } catch(e) {} }
              return;
            }

            if (type === 'end') {
              if (typeof pollFlowTraceUntilEnd === 'function') { try { pollFlowTraceUntilEnd(); } catch(e) {} }
              return;
            }
            return;
          }

          // ‚îÄ‚îÄ Existing device‚Äêtrigger logic ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
          if (evt.source !== 'DEVICE' || !evt.name || !evt.deviceId) return;
          clearAllSelections();
          const nodes =
            editor?.drawflow?.Home?.data ||
            editor?.drawflow?.drawflow?.Home?.data;
          if (!nodes) return;

          const match = Object.values(nodes).find(n => {
            const rawIds = Array.isArray(n.data.deviceIds)
              ? n.data.deviceIds
              : [n.data.deviceId];
            return rawIds.map(x => Number(x)).includes(Number(evt.deviceId))
                && n.data.attribute === evt.name;
          });

          if (match) {
            window.editor.selected_id = match.id;
            // clear previous highlights
            document.querySelectorAll('.drawflow-node.executed, .drawflow-node.last-executed')
              .forEach(n => n.classList.remove('executed','last-executed'));
            document.querySelectorAll('.main-path')
              .forEach(p => {
                p.removeAttribute('stroke');
                p.removeAttribute('style');
                p.classList.remove('highlighted');
              });

            logAction(
              `‚ö° Trigger on node ${match.id}: ` +
              `${evt.displayName} ‚Üí ${evt.value}`,
              'info'
            );
            flowTracePollingActive = true;
            pollFlowTraceUntilEnd();
          }
        });

        window.flowTraceSocket.addEventListener('error', err =>
          console.error('‚ùå WebSocket error', err)
        );
      }

      document.addEventListener('DOMContentLoaded', startFlowTraceStream);

      // Clear Trace
      /* delegated handler for clearTraceBtn (button can be injected later) */
function __fe_handleClearTrace(){

        // clear node highlights
        document.querySelectorAll(
          '.drawflow-node.executed, .drawflow-node.last-executed, .drawflow-node.flow-path'
        ).forEach(el => el.classList.remove('executed','last-executed','flow-path'));

        // clear path highlights
        document.querySelectorAll('.main-path.highlighted, .main-path.live-highlight').forEach(path => {
          path.removeAttribute('stroke');
          path.removeAttribute('style');
          path.classList.remove('highlighted','live-highlight');
        });

        // stop live‚Äëpolling if active
        if (typeof flowTracePollInterval !== 'undefined' && flowTracePollInterval) {
          clearInterval(flowTracePollInterval);
          flowTracePollInterval = null;
        }

        logAction('üóëÔ∏è Trace cleared', 'info');
      
}
(function(){
  const __btn=document.getElementById('clearTraceBtn');
  if(__btn) __btn.addEventListener('click', __fe_handleClearTrace);
  document.addEventListener('click', function(e){
    const t = e.target && (e.target.id === 'clearTraceBtn' || (e.target.closest && e.target.closest('#clearTraceBtn')));
    if(t) { e.preventDefault(); __fe_handleClearTrace(); }
  }, true);
})();
/* delegated handler for lastTraceBtn (button can be injected later) */
async function __fe_handleLastTraceFile(){

        // 1) Clear previous highlights
        document.querySelectorAll('.drawflow-node.executed, .drawflow-node.last-executed, .drawflow-node.flow-path')
          .forEach(n => n.classList.remove('executed','last-executed','flow-path'));
        document.querySelectorAll('.main-path.highlighted, .main-path.live-highlight')
          .forEach(p => { p.removeAttribute('stroke'); p.removeAttribute('style'); p.classList.remove('highlighted','live-highlight'); });

        // 2) Determine the "active" flow from the UI
        const nameEl = document.getElementById('flowName');
        const raw = (nameEl ? nameEl.textContent : (window.currentFlowFile || '')).trim();
        if (!raw) { logAction('No flow loaded.', 'warn'); return; }
        const want = raw.toLowerCase().endsWith('.json') ? raw.toLowerCase() : (raw.toLowerCase() + '.json'); // 

        // 3) Load and normalize FE_lasttrace.json to an array of runs
        let resp;
        try {
          const u = `/local/FE_lasttrace.json?ts=${Date.now()}`;
          const r = await fetch(u, { cache: 'no-store' });
          const t = await r.text();
          resp = JSON.parse(t);
        } catch (e) {
          logAction('Failed to read FE_lasttrace.json: ' + (e && e.message ? e.message : e), 'error');
          return;
        }
        const list = Array.isArray(resp) ? resp : (resp && Array.isArray(resp.flows) ? resp.flows : []); // 
        if (!list.length) { logAction('No flow traces found.', 'info'); return; }

        // 4) Filter to this flow (case-insensitive) and choose the most recent COMPLETED run
        const runs = list.filter(r => String(r.flowFile || '').toLowerCase() === want); // 
        if (!runs.length) { logAction('No previous runs for this editor.', 'info'); return; }

        // Most recent by last-step timestamp
        runs.sort((a,b) => {
          const ta = (a.steps && a.steps.length) ? (a.steps[a.steps.length - 1].timestamp || 0) : 0;
          const tb = (b.steps && b.steps.length) ? (b.steps[b.steps.length - 1].timestamp || 0) : 0;
          return tb - ta;
        });

        // Prefer a run that ended (endOfFlow / finished), else take the latest
        const completed = runs.find(r => {
          const steps = r.steps || [];
          const last = steps[steps.length - 1];
          return (String(last?.nodeType || last?.step || '').toLowerCase() === 'endofflow') || r.finished;
        }) || runs[0]; // 

        // 5) Extract only real steps (with nodeId) and paint them green
        const realSteps = (completed.steps || []).filter(s => s && s.nodeId); // 
        if (!realSteps.length) { logAction('Trace had no node steps.', 'info'); return; }

        // Nodes
        realSteps.forEach((step, idx) => {
          const el = document.getElementById(`node-${step.nodeId}`);
          if (el) {
            el.classList.add('executed');
            if (idx === realSteps.length - 1) el.classList.add('last-executed');
          }
        });

        // Edges
        for (let i = 0; i < realSteps.length - 1; i++) {
          const from = realSteps[i].nodeId, to = realSteps[i+1].nodeId;
          const sel = `.connection.node_out_node-${from}.node_in_node-${to} .main-path`;
          const path = document.querySelector(sel) ||
                      document.querySelector(`.connection[data-from="${from}"][data-to="${to}"] .main-path`);
          if (path) {
            path.setAttribute('stroke','limegreen');
            path.setAttribute('style','stroke: limegreen !important; stroke-width: 8px !important; filter: drop-shadow(0 0 6px #0f0) !important;');
            path.classList.add('highlighted');
          }
        }

        // Optional: update "Last Run" label if timestamp is present (your existing pattern)
        const ts = completed.timestamp || (completed.runId && /^\d{13}/.test(completed.runId) ? parseInt(String(completed.runId).split('_')[0], 10) : null);
        if (ts) {
          const d = new Date(ts);
          const el = document.getElementById('lastRunLine');
          if (el) el.textContent = `Last Run: ${d.toLocaleDateString(undefined,{year:'numeric',month:'short',day:'numeric'})} - ${d.toLocaleTimeString(undefined,{hour:'2-digit',minute:'2-digit',second:'2-digit'})}`; // 
        }
      
}
(function(){
  const __btn=document.getElementById('lastTraceBtn');
  if(__btn) __btn.addEventListener('click', __fe_handleLastTraceFile);
  document.addEventListener('click', function(e){
    const t = e.target && (e.target.id === 'lastTraceBtn' || (e.target.closest && e.target.closest('#lastTraceBtn')));
    if(t) { e.preventDefault(); __fe_handleLastTraceFile(); }
  }, true);
})();
function hideTestUI() {
        const statusDiv = document.getElementById("flowTesterContent") || document.getElementById("flowTesterContent") || document.getElementById("flowTestStatus");
        if (!statusDiv) return;

        const testBtn      = statusDiv.querySelector('#testFlowBtn');
        const testInput    = statusDiv.querySelector('#testFlowInput');
        const dryRunLabel  = statusDiv.querySelector('#dryRunCheckbox')?.closest('label');

        const selNode = editor.getNodeFromId(editor.selected_id);
        const isMulti = selNode?.name === 'eventTrigger'
                    && Array.isArray(selNode.data.deviceIds)
                    && selNode.data.deviceIds.length > 1;

        if (isMulti) {
          if (testBtn)     testBtn.hidden     = true;
          if (testInput)   testInput.hidden   = true;
          if (dryRunLabel) dryRunLabel.hidden = true;

          if (!statusDiv.querySelector('#testNaMsg')) {
            const naMsg = document.createElement('div');
            naMsg.id          = 'testNaMsg';
            naMsg.textContent = 'Testing not Available';
            naMsg.style       = 'font-size:12px;color:#b00;margin:8px 0;';
            statusDiv.appendChild(naMsg);
          }
        } else {
          if (testBtn)     testBtn.hidden     = false;
          if (testInput)   testInput.hidden   = false;
          if (dryRunLabel) dryRunLabel.hidden = false;
          const naMsg = statusDiv.querySelector('#testNaMsg');
          if (naMsg) naMsg.remove();
        }
      }

      /**
       * Returns a CSS style string to outline in red any node whose required inputs are missing.
       * Supports all built‚Äëin tile types.
       *
       * @param {string} type  The node type (e.g. "eventTrigger", "device", "schedule", etc.)
       * @param {object} data  The node‚Äôs data object
       * @returns {string}     A CSS style (e.g. "border:2px solid #fa2b2b;") or "" if no error
       */
      function getErrorStyle(type, data) {
        const t = (type || "").toLowerCase();
        let hasError = false;

        switch (t) {
          // ‚îÄ‚îÄ Logic & Comment nodes: never error ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
          case "donothing":
          case "comment":
            break;

          // ‚îÄ‚îÄ Delay nodes: require numeric duration ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
          case "delay":
            if (typeof data.ms !== "number" || isNaN(data.ms)) {
              hasError = true;
            }
            break;
          case "delaymin":
            if (typeof data.delayMin !== "number" || isNaN(data.delayMin)) {
              hasError = true;
            }
            break;

          // ‚îÄ‚îÄ Save/Restore Device State: require a device ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
          case "savedevicestate":
          case "restoredevicestate":
            if (!data.deviceId) {
              hasError = true;
            }
            break;

          // ‚îÄ‚îÄ Schedule: must have at least one of cron, repeatDays, or time ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
          case "schedule":
            if (
              !data.cron &&
              (!Array.isArray(data.repeatDays) || data.repeatDays.length === 0) &&
              !data.time
            ) {
              hasError = true;
            }
            break;

          // ‚îÄ‚îÄ Repeat Until/Max: different requirements by mode ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
          case "repeat":
            if (data.repeatMode === "until") {
              if (!data.deviceId || !data.attribute || !data.comparator) {
                hasError = true;
              } else if (data.comparator === "between") {
                if (
                  !Array.isArray(data.value) ||
                  !data.value[0] ||
                  !data.value[1]
                ) {
                  hasError = true;
                }
              } else if (
                data.comparator !== "changes" &&
                (data.value === undefined || data.value === "")
              ) {
                hasError = true;
              }
            } else {
              if (
                typeof data.repeatMax !== "number" ||
                isNaN(data.repeatMax) ||
                data.repeatMax < 1
              ) {
                hasError = true;
              }
            }
            break;

          // ‚îÄ‚îÄ Variable assignment: require name and value ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
          case "setvariable":
            if (!data.varName || data.varValue === undefined || data.varValue === "") {
              hasError = true;
            }
            break;

          // ‚îÄ‚îÄ NotMatchingVar: need target devices and an output variable ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
          case "notmatchingvar":
            const targetsNMV = Array.isArray(data.targetDeviceId)
              ? data.targetDeviceId
              : [data.targetDeviceId];
            if (
              targetsNMV.length === 0 ||
              targetsNMV.every(id => !id) ||
              !data.outputVar
            ) {
              hasError = true;
            }
            break;

          // ‚îÄ‚îÄ Notification: must pick at least one device and supply a message ‚îÄ‚îÄ‚îÄ‚îÄ
          case "notification":
            const targetsNOT = Array.isArray(data.targetDeviceId)
              ? data.targetDeviceId
              : [data.targetDeviceId];
            if (
              targetsNOT.length === 0 ||
              targetsNOT.every(id => !id) ||
              !data.message
            ) {
              hasError = true;
            }
            break;

          // ‚îÄ‚îÄ Device Action: need device(s) and a command ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
          case "device":
            const devs = Array.isArray(data.deviceIds)
              ? data.deviceIds
              : data.deviceId
              ? [data.deviceId]
              : [];
            if (devs.length === 0 || devs.every(id => !id) || !data.command) {
              hasError = true;
            }
            break;

          // ‚îÄ‚îÄ Event Trigger & Condition: device, attribute, comparator, value ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
          case "eventtrigger":
          case "condition":
            if (!data.deviceId || !data.attribute || !data.comparator) {
              hasError = true;
            } else if (data.comparator === "between") {
              if (
                !Array.isArray(data.value) ||
                !data.value[0] ||
                !data.value[1]
              ) {
                hasError = true;
              }
            } else if (
              data.comparator !== "changes" &&
              (data.value === undefined || data.value === "")
            ) {
              hasError = true;
            }
            break;

          // ‚îÄ‚îÄ Unknown types: assume valid ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
          default:
            break;
        }

        return hasError ? "border:2px solid #fa2b2b;" : "";
      }

      function clearAllSelections() {
        // 1) Clear multi‚Äëselect on canvas
        window._multiSelectedNodes.clear();
        updateMultiSelectUI();
      }
      
      async function getDynamicSunTimes() {
        // 1. Try to use browser geolocation
        let lat = 42.36, lng = -71.06; // Boston fallback
        try {
          if (navigator.geolocation) {
            const pos = await new Promise((resolve, reject) =>
              navigator.geolocation.getCurrentPosition(resolve, reject, {timeout: 2000}));
            lat = pos.coords.latitude;
            lng = pos.coords.longitude;
          }
        } catch(e) {
          // Could not get geolocation, will use default coords
        }

        // 2. Try to use SunCalc for sunrise/sunset
        try {
          if (typeof SunCalc !== "undefined" && SunCalc.getTimes) {
            const times = SunCalc.getTimes(new Date(), lat, lng);
            const pad = n => (n < 10 ? "0" : "") + n;
            return {
              sunrise: pad(times.sunrise.getHours()) + ":" + pad(times.sunrise.getMinutes()),
              sunset:  pad(times.sunset.getHours())  + ":" + pad(times.sunset.getMinutes())
            };
          }
        } catch(e) {
          // SunCalc failed, will use hardcoded times
        }

        // 3. Fallback to static times if everything else fails
        return { sunrise: "06:00", sunset: "20:00" };
      }

      function getOS() {
        if (navigator.userAgentData && navigator.userAgentData.platform) {
          const p = navigator.userAgentData.platform.toLowerCase();
          if (p.includes('mac')) return 'mac';
          if (p.includes('win')) return 'windows';
          if (p.includes('linux')) return 'linux';
          return 'other';
        }
        const p = navigator.platform.toLowerCase();
        if (p.includes('mac')) return 'mac';
        if (p.includes('win')) return 'windows';
        if (p.includes('linux')) return 'linux';
        return 'other';
      }

      const os = getOS();
      if (os === 'mac') {
        document.getElementById('multiSelectTip-mac').style.display = '';
      } else {
        document.getElementById('multiSelectTip-win').style.display = '';
      }

      // Always only register this once!
      (function() {
        const button       = document.getElementById("activateFlowButton");
        const flowDropdown = document.getElementById("hubitatFileDropdown");

        // Remove any previous handler, just in case
        button.replaceWith(button.cloneNode(true));
        const newButton = document.getElementById("activateFlowButton");

        newButton.addEventListener("click", async () => {
          const flowName = flowDropdown?.value?.trim() || "";
          const token    = document.getElementById("hubitatToken")?.value.trim()  || "";
          const appId    = document.getElementById("hubitatAppId")?.value.trim()  || "";

          // 1) Validate inputs
          if (!hubitatCredentialsAreValid(true)) {
            logAction("Missing App ID or Token", "error");
            return;
          }
          if (!flowName) {
            logAction("No Flow selected to activate/deactivate", "error");
            return;
          }

          // 2) Decide endpoint
          const isActive = newButton.textContent.trim() === "Activated";
          const action   = isActive ? "deselectFlow" : "selectFlow";
          const url      = `/apps/api/${appId}/${action}?access_token=${token}`;

          // 3) Disable to prevent double‚Äêclicks
          newButton.disabled = true;
          try {
            // ‚îÄ‚îÄ Send the flow name in the POST body ‚îÄ‚îÄ
            const response = await fetch(url, {
              method:  "POST",
              headers: { "Content-Type": "application/json" },
              body:    JSON.stringify({ flow: flowName })
            });
            if (!response.ok) {
              throw new Error(`HTTP ${response.status} ${response.statusText}`);
            }
            const result = await response.json();

            // 4) Log success
            logAction(
              isActive
                ? `‚ùé Flow deactivated: ${result.result || JSON.stringify(result)}`
                : `‚úÖ Flow activated:   ${result.result || JSON.stringify(result)}`,
              "info"
            );

            // 5) Refresh UI state (ALWAYS use checkIfFlowIsInUse for UI!)
            await checkIfFlowIsInUse(flowName, appId, token);

          } catch (err) {
            logAction(`‚ùå Toggle failed: ${err}`, "error");
          } finally {
            newButton.disabled = false;
          }
        });
      })();

      function buildVariableTriggerEditor(pickerDiv, node, appendOnly) {
        if (!node.data.variableName) node.data.variableName = "";
        if (!node.data.comparator) node.data.comparator = "==";
        if (node.data.value === undefined) node.data.value = "";

        const oldPanels = pickerDiv.querySelectorAll('.variable-trigger-panel');
        oldPanels.forEach(panel => panel.remove());

        if (!appendOnly) pickerDiv.innerHTML = "";

        const container = document.createElement("div");
        container.className = "variable-trigger-panel";

        const varLabel = document.createElement("label");
        varLabel.textContent = "Variable Name";
        varLabel.style.display = "block";
        container.appendChild(varLabel);

        const flowFile = window.flowVars?.getCurrentFlowFile?.() || "";
        const flowVars = Array.isArray(window.FE_flowvars?.[flowFile]) ? window.FE_flowvars[flowFile] : [];

        const vars = [
          ...flowVars.map(v => v.name),
          ...(Array.isArray(window.FE_global_vars) ? window.FE_global_vars.map(v => v.name) : [])
        ].filter(Boolean)
        .sort((a, b) => a.localeCompare(b, undefined, { sensitivity: 'base' }));

        const varSelect = document.createElement("select");
        varSelect.style.display = "block";
        varSelect.style.marginBottom = "12px";

        varSelect.innerHTML =
          `<option value="" ${!node.data.variableName ? "selected" : ""}>(select)</option>` +
          vars.map(v =>
            `<option value="${v}" ${node.data.variableName === v ? "selected" : ""}>${v}</option>`
          ).join("");
        varSelect.onchange = () => {
          node.data.variableName = varSelect.value;
          editor.updateNodeDataFromId(node.id, node.data);
          buildVariableTriggerEditor(pickerDiv, node, appendOnly);
          markFlowNeedsSave(true);
        };
        container.appendChild(varSelect);

        renderComparatorPicker(container, node, ["==", "!=", ">", "<", ">=", "<=", "between"], {
          "==": "equals", "!=": "not equals",
          ">": ">", "<": "<", ">=": "‚â•", "<=": "‚â§", "between": "between"
        }, () => {
          node.data.comparator = container.querySelector("select:last-of-type").value;
          node.data.value = "";
          editor.updateNodeDataFromId(node.id, node.data);
          buildVariableTriggerEditor(pickerDiv, node, appendOnly);
          markFlowNeedsSave(true);
        });

        const between = node.data.comparator === "between";
        renderValueField(container, node, [], () => {
          editor.updateNodeDataFromId(node.id, node.data);
          markFlowNeedsSave(true);
        }, between);

        pickerDiv.appendChild(container);
      }

      function logAction(msg, type = "info") {
        const logLines = document.getElementById("logLines");
        if (logLines) {
          logLines.innerHTML += `<span class="log-${type}">${msg}</span><br>`;
          logLines.scrollTop = logLines.scrollHeight;
        }
      }

      document.getElementById('clearLogBtn').onclick = function () {
        const logLines = document.getElementById('logLines');
        if (logLines) logLines.innerHTML = "";
      };
    </script>
    <script>
      window.addEventListener("load", function () {
        // Wait until the FE_flowvars.js is parsed and credentials are in place
        function tryInitVars() {
          if (typeof window.initVariablesAfterCreds === "function") {
            window.initVariablesAfterCreds();
          } else {
            setTimeout(tryInitVars, 50);
          }
        }
        tryInitVars();
      });
    </script>
    <script>
      // === Live Trace logger ===
      (() => {
        window.TRACE_DBG = true; // flip to false to silence
        window.traceLog = (...args) => window.TRACE_DBG && console.log('%c[LiveTrace]', 'color:#eab308;font-weight:bold', ...args);
      })();
    </script>
    <script>
      // === Robust ctrl/cmd‚Äëclick multi-select for Drawflow nodes ===
      // Keeps highlight across load and avoids conflicts with Drawflow's own click handler.
      (function () {
        if (window.__fe_multiSelectInstalled__) return;
        window.__fe_multiSelectInstalled__ = true;

        // FE Selection: normalized Set wrapper (accepts '123' and 'node-123')
if (!window._multiSelectedNodes || !window._multiSelectedNodes.__patched) {
  (function(){
    function norm(v){ return (v==null)? null : String(v).replace(/^node-/, ''); }
    const inner = new Set();
    window._multiSelectedNodes = {
      __patched: true,
      _inner: inner,
      add: function(v){ inner.add(norm(v)); return this; },
      delete: function(v){ return inner.delete(norm(v)); },
      has: function(v){ return inner.has(norm(v)); },
      clear: function(){ inner.clear(); },
      forEach: function(cb, thisArg){ inner.forEach(function(v){ cb.call(thisArg, v); }); },
      get size(){ return inner.size; },
      [Symbol.iterator]: function(){ return inner[Symbol.iterator](); }
    };
  })();
}
function nodeIdFromEl(el) {
          if (!el) return null;
          const id = el.id || "";
          return id.startsWith("node-") ? id.slice(5) : null;
        }
        function getDrawflowRoot() {
          return document.querySelector('#drawflow .drawflow') || document.querySelector('#drawflow');
        }
        function reapplyMultiSelectHighlights() {
          const root = getDrawflowRoot();
          if (!root) return;
          [...window._multiSelectedNodes].forEach(id => {
            const el = root.querySelector('#node-' + id);
            if (el) el.classList.add('multi-selected');
            else window._multiSelectedNodes.delete(id);
          });
        }

        // Observe node removals so the Set stays clean
        const obs = new MutationObserver(() => {
          const root = getDrawflowRoot();
          if (!root) return;
          [...window._multiSelectedNodes].forEach(id => {
            if (!root.querySelector('#node-' + id)) window._multiSelectedNodes.delete(id);
          });
        });
        const startObs = () => {
          const root = getDrawflowRoot();
          if (root) obs.observe(root, { childList: true, subtree: true });
        };
        document.addEventListener('DOMContentLoaded', startObs);

        // Capture-phase mousedown to toggle without letting Drawflow clear selection
        document.addEventListener('mousedown', function (e) {
          const nodeEl = e.target.closest('.drawflow-node');
          const isMeta = e.ctrlKey || e.metaKey;
          if (!nodeEl || !isMeta) return;

          // Toggle highlight
          const id = nodeIdFromEl(nodeEl);
          if (!id) return;
          if (nodeEl.classList.contains('multi-selected')) {
            nodeEl.classList.remove('multi-selected');
            window._multiSelectedNodes.delete(id);
          } else {
            nodeEl.classList.add('multi-selected');
            window._multiSelectedNodes.add(id);
          }

          // Stop the library from replacing the selection
          e.preventDefault();
          e.stopPropagation();
        }, true);

        // Clicking on empty canvas clears multi-select (normal behavior)
        document.addEventListener('mousedown', function (e) {
          const root = document.querySelector('#drawflow');
          if (!root) return;
          const clickedInsideNode = !!e.target.closest('.drawflow-node');
          const isMeta = e.ctrlKey || e.metaKey;
          if (clickedInsideNode || isMeta) return;
          // if clicking on background or UI, clear multi-select
          if (!root.contains(e.target)) return;
          const df = root.querySelector('.drawflow') || root;
          df.querySelectorAll('.drawflow-node.multi-selected').forEach(el => el.classList.remove('multi-selected'));
          window._multiSelectedNodes.clear();
        }, true);

        // Hook restoreFlowFromJson to reapply highlights after imports
        (function hookRestore() {
          const key = '__restore_hooked__';
          if (window[key]) return;
          window[key] = true;
          const prior = window.restoreFlowFromJson;
          if (typeof prior === 'function') {
            window.restoreFlowFromJson = async function () {
              const result = await prior.apply(this, arguments);
              // Give Drawflow a tick to build DOM, then reapply highlights
              setTimeout(reapplyMultiSelectHighlights, 20);
              return result;
            };
          } else {
            // If it loads later, try again
            const retry = setInterval(() => {
              if (typeof window.restoreFlowFromJson === 'function') {
                clearInterval(retry);
                window.restoreFlowFromJson = (function (orig) {
                  return async function () {
                    const result = await orig.apply(this, arguments);
                    setTimeout(reapplyMultiSelectHighlights, 20);
                    return result;
                  };
                })(window.restoreFlowFromJson);
              }
            }, 50);
            setTimeout(() => clearInterval(retry), 8000);
          }
        })();

        // Reapply once everything is loaded
        window.addEventListener('load', () => setTimeout(reapplyMultiSelectHighlights, 60));
      })();
    </script>
    <script>
      document.addEventListener('DOMContentLoaded', function () {
        const fitBtn = document.getElementById('fitViewBtn');
        if (fitBtn) {
          fitBtn.addEventListener('click', function () {
            if (typeof zoomDrawflowToFit === 'function') {
              try { zoomDrawflowToFit(); } catch (e) { console.warn('zoomDrawflowToFit failed:', e); }
            } else {
              console.warn('zoomDrawflowToFit() not found');
            }
          });
        }
      });
    </script>

  <!-- BEGIN: Variable Name Duplicate Check (robust, globals-only) -->
  <script>
    (function(){
      'use strict';
      if (window.__finalVarNameDupCheck) return;
      window.__finalVarNameDupCheck = true;

      function toList(n){ return Array.prototype.slice.call(n||[]); }
      function norm(s){ return String(s==null?'':s).trim().toLowerCase(); }

      function getGlobalNameSet(){
        try{
          var arr = Array.isArray(window.FE_global_vars) ? window.FE_global_vars : [];
          var set = new Set();
          for (var i=0;i<arr.length;i++){
            var v = arr[i];
            if (v && v.name) set.add(norm(v.name));
          }
          return set;
        }catch(_){ return new Set(); }
      }

      function findVarManager(){ return document.getElementById('variableManager'); }

      function findNameInput(container){
        if (!container) return null;

        // 1) Label-based (preferred)
        var labels = toList(container.querySelectorAll('label'));
        for (var i=0;i<labels.length;i++){
          var txt = norm(labels[i].textContent||'');
          if (txt.indexOf('variable name') !== -1){
            // next siblings or inside
            var el = labels[i].nextElementSibling;
            for (var j=0;j<8 && el; j++, el = el.nextElementSibling){
              if (el.tagName && el.tagName.toLowerCase()==='input') return el;
              var inside = el && el.querySelector && el.querySelector('input');
              if (inside) return inside;
            }
            // same group
            var group = labels[i].parentElement;
            if (group){
              var any = group.querySelector('input');
              if (any) return any;
            }
          }
        }

        // 2) Placeholder-based
        var phInput = container.querySelector('input[placeholder*="Variable"][placeholder*="Name" i]');
        if (phInput) return phInput;

        // 3) Before the "Initial Value" field
        var iv = toList(container.querySelectorAll('input[placeholder],textarea[placeholder]'))
                  .find(function(el){ return /initial\s*value/i.test(el.getAttribute('placeholder')||''); });
        if (iv){
          var w = iv.previousElementSibling, guard=0;
          while (w && guard++<40){
            if (w.tagName && w.tagName.toLowerCase()==='input') return w;
            w = w.previousElementSibling;
          }
        }

        // 4) First input before a Save button
        var saveBtn = toList(container.querySelectorAll('button')).find(function(b){ return norm(b.textContent)==='save'; });
        if (saveBtn){
          var fields = [];
          var e = saveBtn.previousElementSibling, g=0;
          while (e && g++<80){
            if (e.tagName && /^(input|select|textarea)$/i.test(e.tagName)) fields.unshift(e);
            e = e.previousElementSibling;
          }
          var inputs = fields.filter(function(el){ return el.tagName && el.tagName.toLowerCase()==='input'; });
          if (inputs.length) return inputs[0];
        }

        // 5) Last resort
        return container.querySelector('input');
      }

      function paint(container, nameEl){
        try{
          if (!container || !nameEl) return;
          var nm = (nameEl.value||'').trim();
          if (!nm){
            nameEl.style.outline='';
            nameEl.style.borderColor='';
            return;
          }
          var dup = getGlobalNameSet().has(norm(nm));
          if (dup){
            nameEl.style.outline = '2px solid #fa2b2b';
            nameEl.style.borderColor = '#fa2b2b';
          } else {
            nameEl.style.outline = '';
            nameEl.style.borderColor = '';
          }
        }catch(_){}
      }

      function wire(){
        var vm = findVarManager();
        if (!vm) return;
        var nameEl = findNameInput(vm);
        if (!nameEl || nameEl.__dupNameWired) return;

        var repaint = function(){ paint(vm, nameEl); };
        nameEl.addEventListener('input', repaint);
        nameEl.addEventListener('change', repaint);

        // Initial paints (allow globals to load)
        setTimeout(repaint, 0);
        setTimeout(repaint, 300);
        setTimeout(repaint, 1200);

        // Repaint after global vars refresh
        if (typeof window.refreshVarsAndInspector === 'function' && !window.refreshVarsAndInspector.__dupNameWrap){
          var orig = window.refreshVarsAndInspector;
          window.refreshVarsAndInspector = async function(){
            var r = await orig.apply(this, arguments);
            try { repaint(); } catch(e){}
            return r;
          };
          window.refreshVarsAndInspector.__dupNameWrap = true;
        }

        nameEl.__dupNameWired = true;
      }

      function install(){
        wire();
        // Watch for (re)renders of variable manager
        var root = document.getElementById('variableManagerPanel') || document;
        try{
          var mo = new MutationObserver(function(){ wire(); });
          mo.observe(root, { childList:true, subtree:true });
        }catch(e){}
      }

      if (document.readyState==='loading') document.addEventListener('DOMContentLoaded', install);
      else install();
      window.addEventListener('load', function(){ setTimeout(install, 200); });
    })();
  </script>
  <!-- END: Variable Name Duplicate Check (robust, globals-only) -->

  <!-- BEGIN: Variable Save Confirmation (minimal, variables panel only) -->
  <script>
    (function(){
      'use strict';
      if (window.__vmVarSaveConfirm) return;
      window.__vmVarSaveConfirm = true;

      function norm(s){ return String(s==null?'':s).trim().toLowerCase(); }

      function wire(){
        var panel = document.getElementById('variableManager');
        if (!panel) return;

        // Find the Add-Variable Save button within the variables panel only
        var btns = Array.prototype.slice.call(panel.querySelectorAll('button'));
        if (!btns.length) return;

        // Prefer the button literally labeled "Save"; otherwise first button before a "Delete" button
        var saveBtn = btns.find(function(b){ return norm(b.textContent)==='save'; });
        if (!saveBtn){
          var delIdx = btns.findIndex(function(b){ return norm(b.textContent)==='delete'; });
          saveBtn = btns.find(function(b, idx){ return delIdx === -1 ? idx === 0 : idx < delIdx; });
        }
        if (!saveBtn || saveBtn.__vmConfirmBound) return;

        // Show a confirmation AFTER the app's own save handler runs
        saveBtn.addEventListener('click', function(){
          try {
            if (saveBtn.disabled) return;
            setTimeout(function(){ /* alert removed: unified to app message */ 
            try{ window.__autoRefresh = false; }catch(_){}
            }, 600);
          } catch(e){ /* noop */ }
        }, true); // capture so we don't interfere

        saveBtn.__vmConfirmBound = true;
      }

      function install(){
        wire();
        var root = document.getElementById('variableManagerPanel') || document;
        try {
          var mo = new MutationObserver(function(){ wire(); });
          mo.observe(root, { childList:true, subtree:true });
        } catch(e){}
      }

      if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', install);
      else install();
      window.addEventListener('load', function(){ setTimeout(install, 200); });
    })();
  </script>
  <!-- END: Variable Save Confirmation (minimal, variables panel only) -->

  <!-- BEGIN: Variable Name Duplicate Check ‚Äî Globals Only (final) -->
  <script>
    (function(){
      'use strict';
      if (window.__vmNameDupFinalPatch__) return;
      window.__vmNameDupFinalPatch__ = true;

      function norm(s){ return String(s==null?'':s).trim().toLowerCase(); }
      function toList(n){ return Array.prototype.slice.call(n||[]); }

      function getGlobalNameSet(){
        try{
          var arr = Array.isArray(window.FE_global_vars) ? window.FE_global_vars : [];
          var set = new Set();
          for (var i=0;i<arr.length;i++){
            var v = arr[i];
            if (v && v.name) set.add(norm(v.name));
          }
          return set;
        }catch(_){ return new Set(); }
      }

      function findPanel(){ return document.getElementById('variableManager'); }

      function byLabel(container, labelLower){
        var labels = toList(container.querySelectorAll('label'));
        for (var i=0;i<labels.length;i++){
          var txt = norm(labels[i].textContent||'');
          if (txt.indexOf(labelLower) !== -1){
            var el = labels[i].nextElementSibling;
            for (var j=0;j<8 && el; j++, el = el.nextElementSibling){
              if (el.tagName && /^(input|select|textarea)$/i.test(el.tagName)) return el;
              var inside = el.querySelector && el.querySelector('input,select,textarea');
              if (inside) return inside;
            }
            var group = labels[i].parentElement;
            if (group){
              var any = group.querySelector('input,select,textarea');
              if (any) return any;
            }
          }
        }
        return null;
      }

      function findFields(panel){
        if (!panel) return {};
        // Prefer label-based
        var nameEl  = byLabel(panel, 'variable name');
        var scopeEl = byLabel(panel, 'scope');
        // Fallbacks
        if (!nameEl){
          // Try: input right before Initial Value field
          var iv = panel.querySelector('input[placeholder*="Initial"][placeholder*="Value" i], textarea[placeholder*="Initial"][placeholder*="Value" i]');
          if (iv){
            var w = iv.previousElementSibling, guard=0;
            while (w && guard++<40){
              if (w.tagName && w.tagName.toLowerCase()==='input'){ nameEl = w; break; }
              w = w.previousElementSibling;
            }
          }
        }
        if (!scopeEl){
          // First select in the add-variable area
          var selects = panel.querySelectorAll('select');
          scopeEl = selects && selects.length ? selects[0] : null;
        }
        // Save button (to repaint after saving)
        var saveBtn = toList(panel.querySelectorAll('button')).find(function(b){
          return norm(b.textContent)==='save';
        }) || null;

        return { nameEl, scopeEl, saveBtn };
      }

      function isGlobalSelected(scopeEl){
        if (!scopeEl) return false;
        var v = norm(scopeEl.value||'');
        if (v==='global') return true;
        var txt = (scopeEl.options && scopeEl.selectedIndex>=0) ? norm(scopeEl.options[scopeEl.selectedIndex].text||'') : '';
        return txt.indexOf('global') !== -1;
      }

      function repaint(panel, nameEl, scopeEl){
        try{
          if (!nameEl) return;
          var nm = (nameEl.value||'').trim();
          // Only check when Scope=Global
          if (!isGlobalSelected(scopeEl) || !nm){
            nameEl.style.outline=''; nameEl.style.borderColor=''; nameEl.style.boxShadow='';
            return;
          }
          var dup = getGlobalNameSet().has(norm(nm));
          if (dup){
            nameEl.style.outline='2px solid #fa2b2b';
            nameEl.style.borderColor='#fa2b2b';
            nameEl.style.boxShadow='0 0 0 2px rgba(250,43,43,0.25)';
          } else {
            nameEl.style.outline=''; nameEl.style.borderColor=''; nameEl.style.boxShadow='';
          }
        }catch(_){}
      }

      function wire(){
        var panel = findPanel();
        if (!panel) return;
        var fx = findFields(panel);
        if (!fx.nameEl) return;
        if (fx.nameEl.__dupBoundFinal) return;

        var doRepaint = function(){ repaint(panel, fx.nameEl, fx.scopeEl); };

        fx.nameEl.addEventListener('input', doRepaint);
        fx.nameEl.addEventListener('change', doRepaint);
        if (fx.scopeEl){
          fx.scopeEl.addEventListener('input', doRepaint);
          fx.scopeEl.addEventListener('change', doRepaint);
        }

        // Also repaint after Save so the state is correct post-add
        if (fx.saveBtn && !fx.saveBtn.__dupRepaintAfterSave){
          fx.saveBtn.addEventListener('click', function(){
            setTimeout(doRepaint, 700);
          }, true);
          fx.saveBtn.__dupRepaintAfterSave = true;
        }

        // Initial paints (allow globals to load first)
        setTimeout(doRepaint, 0);
        setTimeout(doRepaint, 300);
        setTimeout(doRepaint, 1200);

        // Repaint when the global vars list refreshes
        if (typeof window.refreshVarsAndInspector === 'function' && !window.refreshVarsAndInspector.__dupFinalWrap2){
          var orig = window.refreshVarsAndInspector;
          window.refreshVarsAndInspector = async function(){
            var r = await orig.apply(this, arguments);
            try { doRepaint(); } catch(_){}
            return r;
          };
          window.refreshVarsAndInspector.__dupFinalWrap2 = true;
        }

        fx.nameEl.__dupBoundFinal = true;
      }

      function install(){
        wire();
        var root = document.getElementById('variableManagerPanel') || document;
        try{
          var mo = new MutationObserver(function(){ wire(); });
          mo.observe(root, { childList:true, subtree:true });
        }catch(_){}
      }

      if (document.readyState==='loading') document.addEventListener('DOMContentLoaded', install);
      else install();
      window.addEventListener('load', function(){ setTimeout(install, 200); });
    })();
  </script>
  <!-- END: Variable Name Duplicate Check ‚Äî Globals Only (final) -->

  <script>
    // Flow Tester collapse/expand behavior
    (function(){
      function wireFlowTester(){
        var testHeader = document.getElementById("flowTesterHeader");
        var testContent = document.getElementById("flowTesterContent");
        var testArrow = document.getElementById("flowTesterArrow");
        if (!testHeader || !testContent || !testArrow) return;
        // collapsed by default
        testContent.style.display = "none";
        testArrow.style.transform = "rotate(-90deg)";
        if (!testHeader.__wired){
          testHeader.addEventListener("click", function(){
            var open = (testContent.style.display === "none") ? false : true;
            testContent.style.display = open ? "none" : "";
            testArrow.style.transform = open ? "rotate(-90deg)" : "rotate(0deg)";
          });
          testHeader.__wired = true;
        }
      }
      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", wireFlowTester);
      } else {
        wireFlowTester();
      }
      window.addEventListener("load", function(){ setTimeout(wireFlowTester, 200); });
    })();
  </script>

  <script>
    // Shrink Flow Name text to fit its container
    function fitFlowName(minPx=12, maxPx=28){
      var el = document.getElementById('flowStatusName');
      if(!el) return;
      // reset to max and measure
      el.style.fontSize = (maxPx||28) + 'px';
      el.style.whiteSpace = 'nowrap';
      el.style.overflow = 'hidden';
      var parent = el.parentElement;
      var maxWidth = parent ? parent.clientWidth - 16 : el.clientWidth;
      var size = parseFloat(window.getComputedStyle(el).fontSize) || (maxPx||28);
      var safety = 40;
      while (el.scrollWidth > maxWidth && size > (minPx||12) && safety-- > 0){
        size -= 1;
        el.style.fontSize = size + 'px';
      }
    }
    // Debounced resize
    (function(){
      var t;
      window.addEventListener('resize', function(){
        clearTimeout(t); t = setTimeout(fitFlowName, 100);
      });
      document.addEventListener('DOMContentLoaded', function(){ setTimeout(fitFlowName, 50); });
    })();

    function applyLiveStep(prevId, nextId) {
      // nodes
      if (nextId != null) {
        const node = document.getElementById(`node-${nextId}`);
        if (node) node.classList.add('flow-path'); // yellow ring you already style in CSS
      }
      // edge (class-based OR data-* markup)
      if (prevId != null && nextId != null) {
        const selA = `.connection.node_out_node-${prevId}.node_in_node-${nextId} .main-path`;
        const selB = `.connection[data-from="${prevId}"][data-to="${nextId}"] .main-path`;
        const path = document.querySelector(selA) || document.querySelector(selB);
        if (path) {
          path.setAttribute('stroke', 'gold');
          path.setAttribute('style',
            'stroke: gold !important; stroke-width: 8px !important; filter: drop-shadow(0 0 6px gold) !important;');
          path.classList.add('live-highlight');
        }
      }
    }
  </script>
  <script>
    // Canonical Live/Last Trace highlighter: supports both connection markups
    function highlightFlowPath(run, isLive = false) {
      if (!run || !Array.isArray(run.steps)) return;

      // Only clear prior LIVE strokes so Last Trace (green) stays
      document.querySelectorAll('.main-path.live-highlight').forEach(p => {
        p.removeAttribute('stroke');
        p.removeAttribute('style');
        p.classList.remove('live-highlight');
      });

      // Unique node ids in execution order
      const nodeIds = [];
      for (const s of (run.steps || [])) {
        const id = s && s.nodeId != null ? String(s.nodeId) : '';
        if (id && !nodeIds.includes(id)) nodeIds.push(id);
      }

      nodeIds.forEach((id, idx) => {
        const nodeEl = document.getElementById(`node-${id}`);
        if (nodeEl && !window.traceCleared) nodeEl.classList.add('flow-path');

        const nextId = nodeIds[idx + 1];
        if (!nextId) return;

        // Support both connection markups
        const classSel = `.connection.node_out_node-${id}.node_in_node-${nextId} .main-path`;
        const dataSel  = `.connection[data-from="${id}"][data-to="${nextId}"] .main-path`;
        const pathEl = document.querySelector(classSel) || document.querySelector(dataSel);
        if (pathEl) {
          const color = isLive ? 'gold' : 'limegreen';
          const cls   = isLive ? 'live-highlight' : 'highlighted';
          pathEl.setAttribute('stroke', color);
          pathEl.setAttribute('style', `stroke: ${color} !important; stroke-width: 8px !important; filter: drop-shadow(0 0 6px ${color}) !important;`);
          pathEl.classList.add(cls);
        }
      });

      if (typeof renderMinimap === 'function') renderMinimap();
    }

    // Single global poll interval handle
    let flowTracePollInterval = null;

    // Unified live poller: normalize like Last Trace, pick newest, paint gold, stop at end
    async function pollFlowTraceUntilEnd() {
      if (!window.flowTracePollingActive) return;

      const rawName = (document.getElementById('flowName')?.textContent || '').trim();
      if (!rawName) return;
      const flowFile = rawName.toLowerCase().endsWith('.json') ? rawName.toLowerCase() : (rawName.toLowerCase() + '.json');

      if (flowTracePollInterval) clearInterval(flowTracePollInterval);

      flowTracePollInterval = setInterval(async () => {
        
    try{ window.__autoRefresh = true; if (typeof window.beginDirtySuppression==='function') window.beginDirtySuppression(1500, 'interval'); }catch(_){ }
    try {
          const traces = (await (async ()=>{  const u=`/local/FE_lasttrace.json?ts=${Date.now()}`;  const r=await fetch(u,{cache:'no-store'});  const t=await r.text();  try{ return JSON.parse(t); }catch(_){ try{ logAction('FlowTrace parse error','warn'); }catch(e){}; return []; }})()) ;
          const list = Array.isArray(traces) ? traces : (traces && Array.isArray(traces.flows) ? traces.flows : []);
          const runs = list.filter(t => String(t.flowFile || '').toLowerCase() === flowFile);
          if (!runs.length) return;

          // Choose most recent
          runs.sort((a,b) => {
            const aLast = (a.steps && a.steps.length) ? (a.steps[a.steps.length-1].timestamp || 0) : 0;
            const bLast = (b.steps && b.steps.length) ? (b.steps[b.steps.length-1].timestamp || 0) : 0;
            if (bLast !== aLast) return bLast - aLast;
            const ta = (a.timestamp ?? (a.runId && /^\d{13}/.test(a.runId) ? parseInt(a.runId,10) : 0)) | 0;
            const tb = (b.timestamp ?? (b.runId && /^\d{13}/.test(b.runId) ? parseInt(b.runId,10) : 0)) | 0;
            return tb - ta;
          });
          const run = runs[0];

          // Paint LIVE
          highlightFlowPath(run, true);

          // Stop on EndOfFlow
          const last = (run.steps && run.steps[run.steps.length - 1]) || {};
          const done = String(last.nodeType || last.step || '').toLowerCase() === 'endofflow' || run.finished;
          if (done) {
            clearInterval(flowTracePollInterval);
            flowTracePollInterval = null;
            window.flowTracePollingActive = false;
            if (typeof refreshVarsAndInspector === 'function') { try { await refreshVarsAndInspector(); } catch(e){} }
          }
        } catch (e) {
          console.error('Live Trace poll error', e);
          clearInterval(flowTracePollInterval);
          flowTracePollInterval = null;
        }
      
    try{ window.__autoRefresh = false; }catch(_){}
    }, 500);
    }
  </script>
  <script>
    // Dock button: move flow to top-left with current zoom preserved
    (function(){
      function getViewportView() {
        try {
          if (typeof window.__fe_getViewportView === "function") {
            return window.__fe_getViewportView();
          }
          var ed = window.editor || {};
          var z = (typeof ed.zoom === "number") ? ed.zoom :
                  (typeof ed.zoom_value === "number") ? ed.zoom_value : 1;
          var x = (typeof ed.canvas_x === "number") ? ed.canvas_x :
                  (typeof ed.pos_x === "number") ? ed.pos_x : 0;
          var y = (typeof ed.canvas_y === "number") ? ed.canvas_y :
                  (typeof ed.pos_y === "number") ? ed.pos_y : 0;
          return { x: x, y: y, zoom: z };
        } catch (e) { return { x: 0, y: 0, zoom: 1 }; }
      }
      function applyViewportView(view) {
        try {
          if (typeof window.__fe_applyViewportView === "function") {
            window.__fe_applyViewportView(view);
            return;
          }
          var ed = window.editor || {};
          var el = ed.precanvas ||
                  document.querySelector("#drawflow .precanvas") ||
                  document.querySelector(".precanvas") ||
                  document.querySelector(".parent-drawflow .precanvas");
          if (el) {
            el.style.transformOrigin = "0 0";
            el.style.transform = "translate(" + view.x + "px, " + view.y + "px) scale(" + view.zoom + ")";
          }
          if (typeof ed.canvas_x === "number") ed.canvas_x = view.x;
          if (typeof ed.canvas_y === "number") ed.canvas_y = view.y;
          if (typeof ed.pos_x === "number") ed.pos_x = view.x;
          if (typeof ed.pos_y === "number") ed.pos_y = view.y;
          if (typeof ed.zoom === "number") ed.zoom = view.zoom;
          if (typeof ed.zoom_value === "number") ed.zoom_value = view.zoom;
        } catch (e) {}
      }
      function dockFlowTopLeft(margin) {
        try {
          var df = document.getElementById("drawflow");
          if (!df) return;
          var nodes = df.querySelectorAll(".drawflow-node");
          if (!nodes.length) return;
          var minX = Infinity, minY = Infinity;
          for (var i = 0; i < nodes.length; i++) {
            var el = nodes[i];
            var x = parseFloat(el.style.left) || 0;
            var y = parseFloat(el.style.top)  || 0;
            if (x < minX) minX = x;
            if (y < minY) minY = y;
          }
          if (!isFinite(minX) || !isFinite(minY)) return;
          var view = getViewportView();
          var z = (view && view.zoom) ? view.zoom : 1;
          var pad = (typeof margin === "number") ? margin : 20;
          var xNew = pad - (minX * z);
          var yNew = pad - (minY * z);
          applyViewportView({ x: xNew, y: yNew, zoom: z });
          if (typeof window.markFlowNeedsSave === "function") window.markFlowNeedsSave(true);
        } catch (e) { if (window.console && console.warn) console.warn("Dock error:", e); }
      }
      window.dockFlowTopLeft = dockFlowTopLeft;
      document.addEventListener("DOMContentLoaded", function(){
      var btn = document.getElementById("dockBtn");
      if (btn) btn.addEventListener("click", function(){ dockFlowTopLeft(20); });
    
      // Toggle canvas scrollbars (green = ON, grey = OFF)
      (function(){
        var sbtn = document.getElementById('toggleScrollbarsBtn');
        var canvas = document.getElementById('drawflow');
        if (!sbtn || !canvas) return;

        function applySB(on){
          // 1) Toggle overflow
          canvas.style.setProperty('overflow', on ? 'auto' : 'hidden', 'important');
          // 2) Button visual state
          sbtn.style.backgroundColor = on ? '#4CAF50' : '#808080';
          sbtn.style.color = '#fff';
          sbtn.title = on ? 'Scrollbars: ON' : 'Scrollbars: OFF';
          // 3) Persist
          try { localStorage.setItem('fe_scrollbars_on', on ? '1' : '0'); } catch(_) {}
        }

        // Initial state (default ON unless storage says '0')
        var initial = true;
        try { initial = (localStorage.getItem('fe_scrollbars_on') !== '0'); } catch(_) {}
        applySB(initial);

        // Click to toggle
        sbtn.addEventListener('click', function(){
          var cur = true;
          try { cur = (localStorage.getItem('fe_scrollbars_on') !== '0'); } catch(_) {}
          applySB(!cur);
        });
      })();
      });
    })();
  </script>
  <script>
    // Safe override that avoids prior syntax issues.
    (function(){
      async function __cleanRefreshVarsAndInspector(){
        try {
          const resp = await (typeof fetchVarsFromApp === 'function' ? fetchVarsFromApp() : Promise.resolve({}));
          const globals = Array.isArray(resp.globals) ? resp.globals
                        : Array.isArray(resp.globalVars) ? resp.globalVars
                        : [];

          const flowsMapRaw = (resp && resp.flows && typeof resp.flows === 'object') ? resp.flows
                            : (resp && resp.flowVarsMap && typeof resp.flowVarsMap === 'object') ? resp.flowVarsMap
                            : (resp && resp.flowVars && typeof resp.flowVars === 'object') ? resp.flowVars
                            : {};

          var norm = {};
          Object.keys(flowsMapRaw).forEach(function(k){
            var base = String(k || '').replace(/\.json$/i, '');
            var arr = Array.isArray(flowsMapRaw[k]) ? flowsMapRaw[k] : [];
            norm[base] = arr;
            norm[base + '.json'] = arr;
          });

          window.FE_global_vars = globals.slice();
          window.FE_flowvars = norm;

          if (window.flowVars) {
            if (typeof window.flowVars.setGlobalVars === 'function') {
              window.flowVars.setGlobalVars(globals);
            }
            if (typeof window.flowVars.setAllFlowVarsMap === 'function') {
              window.flowVars.setAllFlowVarsMap(norm);
            }
            var current = (window.flowVars.getCurrentFlowFile && window.flowVars.getCurrentFlowFile()) ||
                          (document.getElementById('hubitatFileDropdown') && document.getElementById('hubitatFileDropdown').value || '').replace(/\.json$/i, '');
            if (current && typeof window.flowVars.setCurrentFlowFile === 'function') {
              window.flowVars.setCurrentFlowFile(current);
            }
          }

          if (typeof window.renderVariableInspector === 'function') {
            window.renderVariableInspector();
          }
        } catch (e) {
          try { console.error(e); } catch(_) {}
          alert('Failed to refresh variables from app:<br>' + (e && e.message ? e.message : e));
        }
      }

      // Override to the clean implementation
      window.refreshVarsAndInspector = __cleanRefreshVarsAndInspector;
    })();
  </script>
  <script>
    // Robust WS hook: auto-refresh variables when app emits feTrace: varsUpdated
    (function(){try{
      var _origAdd = WebSocket.prototype.addEventListener;
      WebSocket.prototype.addEventListener = function(type, listener, opts){
        if(type === 'message' && typeof listener === 'function'){
          var wrapped = function(evt){
            try{
              var payload = evt && evt.data;
              if (typeof payload === 'string') {
                try { payload = JSON.parse(payload); } catch(_){}
              }
              if (payload && typeof payload === 'object') {
                var src  = String(payload.source || (payload.event && payload.event.source) || '').toUpperCase();
                var name = String(payload.name   || (payload.event && payload.event.name)   || '');
                var val  = String(payload.value  || (payload.event && payload.event.value)  || '').toLowerCase();
                if (src === 'LOCATION' && name === 'feTrace' && val === 'varsupdated') {
                  if (typeof window.refreshVarsAndInspector === 'function') {
                    window.refreshVarsAndInspector();
                  }
                }
              }
            }catch(e){}
            return listener.call(this, evt);
          };
          return _origAdd.call(this, type, wrapped, opts);
        }
        return _origAdd.call(this, type, listener, opts);
      };
    }catch(e){ try{console.warn('WS varsUpdated hook failed:', e);}catch(_){} }})();
  </script>
  <script>
    /* === Safe override: refreshVarsAndInspector that tolerates flows|flowVarsMap|flowVars === */
    (function(){
      function pickFlowsMap(resp){
        if (resp && resp.flows && typeof resp.flows === 'object') return resp.flows;
        if (resp && resp.flowVarsMap && typeof resp.flowVarsMap === 'object') return resp.flowVarsMap;
        if (resp && resp.flowVars && typeof resp.flowVars === 'object') return resp.flowVars;
        return {};
      }
      function normalizeFlowKeys(map){
        var out = {};
        if (!map || typeof map !== 'object') return out;
        Object.keys(map).forEach(function(k){
          var base = String(k || '').replace(/\.json$/i, '');
          var arr = Array.isArray(map[k]) ? map[k] : [];
          out[base] = arr;
          out[base + '.json'] = arr;
        });
        return out;
      }

      async function __overrideRefreshVarsAndInspector(){
        try{
          var resp = await (typeof fetchVarsFromApp === 'function' ? fetchVarsFromApp() : Promise.resolve({}));
          var globals = Array.isArray(resp && resp.globals) ? resp.globals
                      : Array.isArray(resp && resp.globalVars) ? resp.globalVars
                      : [];
          var flowsNorm = normalizeFlowKeys(pickFlowsMap(resp));

          // expose
          window.FE_global_vars = globals.slice();
          window.FE_flowvars = flowsNorm;

          // pass to var engine if present
          if (window.flowVars){
            if (typeof window.flowVars.setGlobalVars === 'function') window.flowVars.setGlobalVars(globals);
            if (typeof window.flowVars.setAllFlowVarsMap === 'function') window.flowVars.setAllFlowVarsMap(flowsNorm);
            var current = (window.flowVars.getCurrentFlowFile && window.flowVars.getCurrentFlowFile()) ||
                          ((document.getElementById('hubitatFileDropdown') && document.getElementById('hubitatFileDropdown').value) || '').replace(/\.json$/i,'');
            if (current && typeof window.flowVars.setCurrentFlowFile === 'function') window.flowVars.setCurrentFlowFile(current);
          }

          if (typeof window.renderVariableInspector === 'function') window.renderVariableInspector();
        }catch(e){
          try{ console.error(e); }catch(_){}
          alert('Failed to refresh variables from app:<br>' + (e && e.message ? e.message : e));
        }
      }

      // Override without touching the original function body to avoid redeclarations
      window.refreshVarsAndInspector = __overrideRefreshVarsAndInspector;
    })();
  </script>
  <script>
    /* === Robust WS hook: trigger refresh on feTrace: varsUpdated === */
    (function(){
      try{
        var origAdd = WebSocket.prototype.addEventListener;
        WebSocket.prototype.addEventListener = function(type, listener, opts){
          if (type === 'message' && typeof listener === 'function'){
            var wrapped = function(evt){
              try{
                var payload = evt && evt.data;
                if (typeof payload === 'string'){ try{ payload = JSON.parse(payload); }catch(_){} }
                if (payload && typeof payload === 'object'){
                  var src  = String(payload.source || (payload.event && payload.event.source) || '').toUpperCase();
                  var name = String(payload.name   || (payload.event && payload.event.name)   || '');
                  var val  = String(payload.value  || (payload.event && payload.event.value)  || '').toLowerCase();
                  if (src === 'LOCATION' && name === 'feTrace' && val === 'varsupdated'){
                    if (typeof window.refreshVarsAndInspector === 'function'){ window.refreshVarsAndInspector(); }
                  }
                }
              }catch(e){}
              return listener.call(this, evt);
            };
            return origAdd.call(this, type, wrapped, opts);
          }
          return origAdd.call(this, type, listener, opts);
        };
      }catch(e){ try{ console.warn('varsUpdated WS hook failed:', e); }catch(_){} }
    })();
  </script>
  <!-- ===== DIRTY ON MOVE + ALIGN (append-only) ===== -->
  <script>
    (function(){
      if (window.__dirtyHooksInstalled) return;
      window.__dirtyHooksInstalled = true;

      // Mark dirty when a tile actually moves
      (function setupDirtyOnNodeDrag(){
        let startPos = null, nodeEl = null;
        function getPos(el){
          try {
            const left = parseFloat(el.style.left || el.getAttribute('data-left') || el.offsetLeft || 0);
            const top  = parseFloat(el.style.top  || el.getAttribute('data-top')  || el.offsetTop  || 0);
            return {left: left||0, top: top||0};
          } catch (_) { return {left:0, top:0}; }
        }
        document.addEventListener('mousedown', function(e){
          const n = e.target && e.target.closest && e.target.closest('.drawflow-node');
          if (!n){ startPos=null; nodeEl=null; return; }
          nodeEl = n; startPos = getPos(n);
        }, true);
        document.addEventListener('mouseup', function(){
          if (!nodeEl || !startPos) return;
          const endPos = getPos(nodeEl);
          const moved = (Math.round(endPos.left) !== Math.round(startPos.left)) ||
                        (Math.round(endPos.top)  !== Math.round(startPos.top));
          nodeEl = null; startPos = null;
          if (moved) { try { markFlowNeedsSave(true); } catch(_){} }
        }, true);
      })();

      // Mark dirty after any align button click
      (function setupDirtyOnAlignButtons(){
        const ids = ["alignLeftBtn","alignRightBtn","alignTopBtn","alignBottomBtn","alignCenterBtn","alignMiddleBtn"];
        ids.forEach(id => {
          const b = document.getElementById(id);
          if (!b) return;
          if (b.__dirtyAlignHook) return;
          b.addEventListener('click', function(){ setTimeout(function(){ try { markFlowNeedsSave(true); } catch(_){} }, 0); }, true);
          b.__dirtyAlignHook = true;
        });
      })();
    })();
  </script>
  <script>
    // === Drag/move hardening override (idempotent) ===
    (function ensureMoveNodeToPatched(){
      const apply = () => {
        try {
          if (!window || !window.editor) return false;
          if (window.editor && typeof window.editor.moveNodeTo === 'function' && window.editor.moveNodeTo.__patched) return true;
          const ed = window.editor;
          const patched = function(id, x, y) {
            try {
              // Update internal model
              const nodes = (typeof getHomeDataFrom === 'function') ? getHomeDataFrom(this || ed) : {};
              const n = nodes && nodes[id];
              if (n) {
                n.pos_x = Number(x)||0;
                n.pos_y = Number(y)||0;
              }
              // Ask the library to update connections if available
              if (this && typeof this.updateConnectionNodes === 'function') {
                this.updateConnectionNodes('node-' + id);
              } else if (ed && typeof ed.updateConnectionNodes === 'function') {
                ed.updateConnectionNodes('node-' + id);
              }
              // If library exposes updateNodePosition, call that too for completeness
              if (this && typeof this.updateNodePosition === 'function') {
                try { this.updateNodePosition(id, Number(x)||0, Number(y)||0); } catch(_){}
              } else if (ed && typeof ed.updateNodePosition === 'function') {
                try { ed.updateNodePosition(id, Number(x)||0, Number(y)||0); } catch(_){}
              }
              // Minimal DOM sync as fallback
              const el = document.getElementById('node-' + id);
              if (el) {
                el.style.left = (Number(x)||0) + 'px';
                el.style.top = (Number(y)||0) + 'px';
              }
              if (typeof markFlowNeedsSave === 'function') markFlowNeedsSave(true);
            } catch (e) {
              console.error('moveNodeTo failed:', e);
            }
          };
          patched.__patched = true;
          ed.moveNodeTo = patched;
          return true;
        } catch (_) { return false; }
      };
      const t = setInterval(() => { if (apply()) clearInterval(t); }, 25);
      apply();
    })();
  </script>
  <script>
    // === Save button "red again" fix: suppress dirty marks during and just after Save ===
    (function () {
      if (window.__saveGuardInstalled) return;
      window.__saveGuardInstalled = true;
      window.__suppressDirtyUntil = 0;

      // Wrap markFlowNeedsSave to honor suppression window
      const _origMark = window.markFlowNeedsSave;
window.markFlowNeedsSave = function(needed = true) {
  if (typeof needed === "undefined") needed = true;
  const btn = document.getElementById("sendFlow");
  // ALWAYS honor clearing requests immediately
  if (needed === false) {
    if (btn) btn.classList.remove("need-save");
    try { if (typeof _origMark === "function") _origMark(false); } catch(_){}
    return;
  }
  // Otherwise, allow existing suppression for auto-refresh / saving
  const now = Date.now();
  const suppressed =
    (window.__suppressDirtyUntil && now < window.__suppressDirtyUntil) ||
    (document && document.body && document.body.classList && document.body.classList.contains("is-saving")) ||
    !!window.__autoRefresh;
  if (btn) {
    if (needed) btn.classList.add("need-save");
    else btn.classList.remove("need-save");
  }
  try { if (typeof _origMark === "function" && !suppressed) _origMark(needed); } catch(_){}
};

      // Hook Save button so suppression starts BEFORE app's own save handler
      function attachSaveHook(){
        var btn = document.getElementById("sendFlow");
        if (!btn || btn.__dirtyHookAttached) return;
        btn.__dirtyHookAttached = true;
        btn.addEventListener("click", function(){ window.beginDirtySuppression(2000, "save"); }, true);
      }
      attachSaveHook();
      var mo = new MutationObserver(attachSaveHook);
      mo.observe(document.documentElement || document.body, { childList:true, subtree:true });

      // Patch editor.moveNodeTo to update position + lines WITHOUT flipping dirty
      function patchMove(){
        try {
          var ed = window.editor;
          if (!ed || typeof ed !== "object") return false;
          if (ed.moveNodeTo && ed.moveNodeTo.__patchedSafe) return true;
          var patched = function(id, x, y){
            try {
              // Update internal model (supports Home under either shape)
              var h = (window.getHomeDataFrom ? window.getHomeDataFrom(ed) : null) || {};
              var node = h && h[id];
              var nx = Number(x)||0, ny = Number(y)||0;
              if (node) { node.pos_x = nx; node.pos_y = ny; }

              // Minimal DOM sync
              var el = document.getElementById('node-' + id);
              if (el) { el.style.left = nx + 'px'; el.style.top = ny + 'px'; }

              // Ask library to re-route connectors if available
              if (typeof ed.updateConnectionNodes === 'function') {
                ed.updateConnectionNodes('node-' + id);
              }
            } catch(e){ console && console.error && console.error('moveNodeTo (patched) error:', e); }
          };
          patched.__patchedSafe = true;
          ed.moveNodeTo = patched;
          return true;
        } catch(_) { return false; }
      }
      var t = setInterval(function(){ if (patchMove()) clearInterval(t); }, 30);
      patchMove();
    })();
  </script>
  <!-- BEGIN: Single-alert normalization -->
  <script>
    (function(){
      try {
        var prev = window.alert;
        if (!prev || prev.__feVarMsgPatch) return;
        function patched(msg){
          try{
            if (typeof msg === 'string'){
              var m = msg.trim().toLowerCase();
              if (m === 'variable saved') {
                return prev.call(window, 'Variable has been added.');
              }
            }
          }catch(_){}
          return prev.apply(window, arguments);
        }
        patched.__feVarMsgPatch = true;
        window.alert = patched;
      } catch(_){}
    })();
  </script>
  <!-- END: Single-alert normalization -->
  <script>
    // === Re-open Schedule Trigger editor by double-clicking a Schedule tile ===
    (function attachScheduleDblclick() {
      try {
        document.addEventListener('dblclick', function(e) {
          const tile = e.target.closest && e.target.closest('.schedule-tile');
          if (!tile) return;
          const nodeEl = tile.closest('.drawflow-node');
          if (!nodeEl) return;
          const idStr = (nodeEl.id || '').replace('node-', '');
          const nodeId = parseInt(idStr, 10);
          if (!window.editor || isNaN(nodeId)) return;
          const node = window.editor.getNodeFromId(nodeId);
          if (!node || node.name !== 'schedule') return;
          // Prefer full spec if present, otherwise synthesize from legacy fields
          const spec = node.data && (node.data.scheduleSpec || {
            tz: undefined,
            times: node.data.time ? [node.data.time] : [],
            byday: Array.isArray(node.data.repeatDays) ? node.data.repeatDays : [],
            cronText: node.data.cron || ''
          });
          if (window.FE_Scheduler && typeof window.FE_Scheduler.open === 'function') {
            window.FE_Scheduler.open(spec, nodeId);
          }
        }, true);
      } catch (err) {
        console.warn('Failed to attach dblclick schedule editor:', err);
      }
    })();
  </script>

  <!-- Scheduler Modal (single source of truth) -->
  <div id="fe-scheduler-modal" style="display:none; position:fixed; inset:0; z-index:9999; background:rgba(0,0,0,0.45);">
    <div style="position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); width:520px; max-width:92vw; background:#1e1e1e; color:#eee; border:1px solid #555; border-radius:8px; box-shadow:0 10px 30px rgba(0,0,0,0.5);">
      <div style="padding:10px 14px; border-bottom:1px solid #444; display:flex; align-items:center; justify-content:space-between;">
        <div style="font-weight:600;">Schedule Trigger</div>
        <button id="fe-sched-close" style="background:#333;border:0;color:#eee;padding:6px 10px;border-radius:6px;cursor:pointer;">‚úï</button>
      </div>
      <div style="padding:12px 14px; max-height:65vh; overflow:auto;">
        <div style="margin-bottom:12px;">
          <label style="display:block;font-size:12px;opacity:0.8;margin-bottom:4px;">Days (choose one or more)</label>
          <div id="fe-sched-days" style="display:flex; flex-wrap:wrap; gap:8px;">
            <!-- Days checkboxes injected -->
          </div>
        </div>

        <div style="margin-bottom:12px;">
          <div style="display:flex;align-items:center;gap:6px;cursor:pointer;" id="fe-sched-time-toggle">
            <strong>Time</strong><span aria-hidden="true">‚ñæ</span>
          </div>
          <div id="fe-sched-time-panel" style="margin-top:6px; display:none;">
            <div style="display:flex; gap:8px; align-items:center; margin-bottom:8px;">
              <input id="fe-sched-time-input" type="time" style="background:#2a2a2a;border:1px solid #555;color:#eee;padding:6px;border-radius:6px;">
              <button id="fe-sched-time-add" style="background:#2f6fed;border:0;color:white;padding:6px 10px;border-radius:6px;cursor:pointer;">Add</button>
            </div>
            <div id="fe-sched-time-list" style="display:flex; flex-wrap:wrap; gap:6px;"></div>
          </div>
        </div>

        <div style="margin-bottom:12px;">
          <div style="display:flex;align-items:center;gap:6px;cursor:pointer;" id="fe-sched-skip-toggle">
            <strong>Skip dates</strong><span aria-hidden="true">‚ñæ</span>
          </div>
          <div id="fe-sched-skip-panel" style="margin-top:6px; display:none;">
            <div style="font-size:12px;opacity:0.85;margin-bottom:6px;">(Optional) Dates to skip. Click + to add YYYY-MM-DD items.</div>
            <div style="display:flex; gap:8px; align-items:center; margin-bottom:8px;">
              <input id="fe-sched-skip-input" type="date" style="background:#2a2a2a;border:1px solid #555;color:#eee;padding:6px;border-radius:6px;">
              <button id="fe-sched-skip-add" style="background:#2f6fed;border:0;color:white;padding:6px 10px;border-radius:6px;cursor:pointer;">Add</button>
            </div>
            <div id="fe-sched-skip-list" style="display:flex; flex-wrap:wrap; gap:6px;"></div>
          </div>
        </div>

        <div style="margin-bottom:8px;">
          <label style="display:block;font-size:12px;opacity:0.8;margin-bottom:4px;">Cron (auto)</label>
          <input id="fe-sched-cron" type="text" readonly style="width:100%; background:#2a2a2a;border:1px solid #555;color:#bbb;padding:6px;border-radius:6px;">
          <div style="font-size:11px;opacity:0.7;margin-top:4px;">Timezone is the hub's location timezone.</div>
        </div>
      </div>
      <div style="padding:10px 14px; border-top:1px solid #444; display:flex; justify-content:flex-end; gap:8px;">
        <button id="fe-cron-reset" style="background:#333;border:0;color:#eee;padding:8px 12px;border-radius:6px;cursor:pointer;">Reset</button>
        <button id="fe-sched-cancel" style="background:#333;border:0;color:#eee;padding:8px 12px;border-radius:6px;cursor:pointer;">Cancel</button>
        <button id="fe-sched-insert" style="background:#3bb273;border:0;color:#102010;padding:8px 12px;border-radius:6px;cursor:pointer;font-weight:600;">Insert Trigger</button>
      </div>
    </div>
  </div>

  <script>
    (function(){
      // Build FE_Scheduler only once
      if (window.FE_Scheduler && typeof window.FE_Scheduler.open === 'function') return;

      const modal = document.getElementById('fe-scheduler-modal');
      const daysHost = document.getElementById('fe-sched-days');
      const timeToggle = document.getElementById('fe-sched-time-toggle');
      const timePanel  = document.getElementById('fe-sched-time-panel');
      const timeInput  = document.getElementById('fe-sched-time-input');
      const timeAdd    = document.getElementById('fe-sched-time-add');
      const timeList   = document.getElementById('fe-sched-time-list');

      const skipToggle = document.getElementById('fe-sched-skip-toggle');
      const skipPanel  = document.getElementById('fe-sched-skip-panel');
      const skipInput  = document.getElementById('fe-sched-skip-input');
      const skipAdd    = document.getElementById('fe-sched-skip-add');
      const skipList   = document.getElementById('fe-sched-skip-list');

      const cronEl     = document.getElementById('fe-sched-cron');

      const btnCancel  = document.getElementById('fe-sched-cancel');
      const btnClose   = document.getElementById('fe-sched-close');
      const btnInsert  = document.getElementById('fe-sched-insert');

      const DAY_CODES = ['SU','MO','TU','WE','TH','FR','SA'];
      const DAY_LABEL = {SU:'Sun', MO:'Mon', TU:'Tue', WE:'Wed', TH:'Thu', FR:'Fri', SA:'Sat'};

      function buildDays() {
        daysHost.innerHTML = '';
        DAY_CODES.forEach(code => {
          const id = 'fe-sched-day-' + code;
          const w = document.createElement('label');
          w.style.display = 'inline-flex';
          w.style.alignItems = 'center';
          w.style.gap = '6px';
          w.style.border = '1px solid #555';
          w.style.padding = '6px 8px';
          w.style.borderRadius = '6px';
          w.style.cursor = 'pointer';
          w.innerHTML = '<input type="checkbox" id="'+id+'" data-code="'+code+'"><span>'+DAY_LABEL[code]+'</span>';
          daysHost.appendChild(w);
        });
      }

      function getSelectedDays() {
        return Array.from(daysHost.querySelectorAll('input[type=checkbox]:checked'))
          .map(cb => cb.getAttribute('data-code'));
      }

      function getTimes() {
        return Array.from(timeList.querySelectorAll('[data-time]')).map(x => x.getAttribute('data-time'));
      }
      function getSkipDates() {
        return Array.from(skipList.querySelectorAll('[data-date]')).map(x => x.getAttribute('data-date'));
      }

      function badges(host, items, attr) {
        host.innerHTML = '';
        items.forEach(val => {
          const b = document.createElement('span');
          b.setAttribute(attr, val);
          b.textContent = val;
          b.style.background = '#2a2a2a';
          b.style.border = '1px solid #555';
          b.style.padding = '4px 8px';
          b.style.borderRadius = '12px';
          b.style.fontSize = '12px';
          b.style.userSelect = 'none';
          b.style.cursor = 'default';
          const del = document.createElement('button');
          del.textContent = '√ó';
          del.style.marginLeft = '6px';
          del.style.background = 'transparent';
          del.style.color = '#999';
          del.style.border = '0';
          del.style.cursor = 'pointer';
          del.onclick = () => { b.remove(); updateCronPreview(); };
          b.appendChild(del);
          host.appendChild(b);
        });
      }

      function updateCronPreview() {
        // Very simple generator: if one time -> classic cron. Many times -> show first and indicate +N
        const days = getSelectedDays();
        const times = getTimes();
        if (!times.length) { cronEl.value = ''; return; }
        const t = times[0]; // HH:MM
        const [hh, mm] = t.split(':');
        const dow = days.length ? days.join(',') : '*';
        // Hubitat uses Quartz cron "sec min hour dom mon dow" -> Use "0 mm HH ? * DOW"
        const dowForQuartz = days.length ? days.join(',') : '*';
        const cron = `0 ${mm} ${hh} ? * ${dowForQuartz}`;
        cronEl.value = cron + (times.length > 1 ? `  (+${times.length-1} more)` : '');
      }

      timeToggle.onclick = () => {
        timePanel.style.display = (timePanel.style.display === 'none') ? 'block' : 'none';
      };
      skipToggle.onclick = () => {
        skipPanel.style.display = (skipPanel.style.display === 'none') ? 'block' : 'none';
      };
      timeAdd.onclick = () => {
        if (!timeInput.value) return;
        const next = Array.from(timeList.querySelectorAll('[data-time]')).map(x => x.getAttribute('data-time'));
        if (!next.includes(timeInput.value)) next.push(timeInput.value);
        badges(timeList, next, 'data-time');
        updateCronPreview();
      };
      skipAdd.onclick = () => {
        if (!skipInput.value) return;
        const next = Array.from(skipList.querySelectorAll('[data-date]')).map(x => x.getAttribute('data-date'));
        if (!next.includes(skipInput.value)) next.push(skipInput.value);
        badges(skipList, next, 'data-date');
      };

      function show() { modal.style.display = 'block'; }
      function hide() { modal.style.display = 'none'; }

      // Core: create/update node 
      async function applyToNode(nodeIdOrNull) {
        const times = getTimes();
        const days = getSelectedDays();
        const skip = getSkipDates();
        const cron = cronEl.value.replace(/\\s+\\(\\+\\d+ more\\)$/, '').trim();

        const data = {
          type: 'schedule',
          // legacy/friendly for tile
          times: times,
          repeatDays: days,
          cron: cron,
          // canonical spec for app side (no timezone field; hub tz is implied)
          scheduleSpec: {
            tz: undefined,
            times: times,
            byday: days,
            skip_dates: skip,
            advanced_cron: cron ? { expression: cron } : undefined,
            preview: cron ? [cron] : []
          }
        };

        if (!window.editor) return;
        if (nodeIdOrNull && !isNaN(parseInt(nodeIdOrNull))) {
          const id = parseInt(nodeIdOrNull);
          const node = window.editor.getNodeFromId(id);
          if (node) {
            node.data = Object.assign({}, node.data || {}, data);
            window.editor.updateNodeHtmlFromId(id, nodeTileHtml('schedule', node.data, id));
            window.editor.updateNodeDataFromId(id, node.data);
            markFlowNeedsSave(true);
          }
        } else {
          // Create new node at the "next new node" coords like other add buttons do.
          const nx = (window.newNodeOffsetX || 0) + 40;
          const ny = (window.newNodeOffsetY || 0) + 40;
          window.newNodeOffsetX = nx;
          window.newNodeOffsetY = ny;
          const html = nodeTileHtml('schedule', data, 0);
          if (typeof window.editor?.addNode === 'function') {
            const id = window.editor.addNode('schedule', 1, 1, nx, ny, 'schedule', data, html);
            // center nudge fixes canvas line redraw
            setTimeout(() => {
              try { window.editor.moveNodeTo(id, nx+1, ny); window.editor.moveNodeTo(id, nx, ny); } catch(e){}
            }, 20);
            markFlowNeedsSave(true);
          }
        }
      }

      window.FE_Scheduler = {
        open: function(spec, nodeId) {
          // Initialize inputs
          buildDays();
          // Preload if editing
          const d = (spec && typeof spec === 'object') ? spec : {};
          const times = Array.isArray(d.times) ? d.times : (d.time ? [d.time] : []);
          const byday = Array.isArray(d.byday) ? d.byday : (Array.isArray(d.repeatDays) ? d.repeatDays : []);
          const skip  = Array.isArray(d.skip_dates) ? d.skip_dates : [];

          // days
          byday.forEach(code => {
            const cb = daysHost.querySelector('input[data-code="'+code+'"]');
            if (cb) cb.checked = true;
          });
          // times
          badges(timeList, times, 'data-time');
          // skip dates
          badges(skipList, skip, 'data-date');

          updateCronPreview();
          show();

          // Replace Insert label if editing
          btnInsert.textContent = nodeId ? 'Save' : 'Insert Trigger';

          // Wire once per open
          btnInsert.onclick = () => { applyToNode(nodeId); hide(); };
          btnCancel.onclick = btnClose.onclick = () => hide();
        }
      };
    })();
  </script>
  <script id="fe-scheduler-enhancer-js">
    // ==== Scheduler Popup Enhancer (inline) ====
    (function(){
      function qs(s, r=document){ return r.querySelector(s); }
      function qsa(s, r=document){ return Array.from(r.querySelectorAll(s)); }

      // Utility: wire section headers to toggle bodies
      function wireSections(root){
        if(!root) return;
        // Look for explicit sections first
        const sections = qsa('.modal-card .section', root);
        if(sections.length){
          sections.forEach(sec => {
            const hd = qs('.sec-hd', sec);
            if(!hd) return;
            // Ensure caret exists
            if(!qs('.caret', hd)){
              const span = document.createElement('span');
              span.className = 'caret';
              span.textContent = '‚ñº';
              hd.appendChild(span);
            }
            hd.addEventListener('click', () => {
              sec.classList.toggle('open');
            });
          });
          return;
        }
        // If no .section blocks found, guess by headings containing "Time" or "Skip Dates"
        const labels = qsa('.modal-card h3, .modal-card h4, .modal-card .label, .modal-card .row-title', root);
        labels.forEach(lab => {
          const txt = (lab.textContent || '').trim().toLowerCase();
          if(txt === 'time' || txt === 'skip dates' || txt === 'skip date' || txt.includes('time') || txt.includes('skip')){
            lab.style.cursor = 'pointer';
            if(!lab.querySelector('.caret')){
              const c = document.createElement('span');
              c.className = 'caret';
              c.textContent = '‚ñº';
              c.style.marginLeft = '8px';
              lab.appendChild(c);
            }
            const container = lab.closest('.row, .group, .fieldset, .section, .card, .block') || lab.parentElement;
            const body = container ? (container.querySelector('.sec-bd, .body, .content, .fields, .details')) : null;
            if(body){
              container.classList.add('section');
              (container.querySelector('.sec-hd') || lab).classList.add('sec-hd');
              body.classList.add('sec-bd');
              lab.addEventListener('click', () => container.classList.toggle('open'));
            }
          }
        });
      }

      // Expose a helper to be called whenever the popup is created/shown
      window.__feEnhanceSchedulerPopup = function(){
        const root = document.getElementById('feSchedulePopup') || document.getElementById('scheduleModal') || document.getElementById('schedulePopup') || document.getElementById('fe-scheduler-modal');
        if(!root) return;
        // Hide timezone rows if any slip through
        qsa('[data-field="timezone"], .timezone-row, .tz-row', root).forEach(el => el.style.display = 'none');
        // Wire sections & add carets
        wireSections(root);
      };

      // Try to run when DOM is ready and whenever a schedule popup is re-opened
      document.addEventListener('DOMContentLoaded', () => {
        // Common custom events ‚Äî call enhancer when popup opens
        ['fe:schedule:open','schedule:open','openSchedule','show:schedule'].forEach(evt => {
          document.addEventListener(evt, () => { try{ window.__feEnhanceSchedulerPopup(); }catch(e){} });
        });
        // Also poll briefly after load in case popup was already injected
        setTimeout(() => { try{ window.__feEnhanceSchedulerPopup(); }catch(e){} }, 500);
      });
    })();
  </script>
  <script>
    // === FE Editor: Self-contained "Schedule Trigger" Cron UI (single-file) ===
    (function(){
      const DAYS = ["SU","MO","TU","WE","TH","FR","SA"];
      const DNAME = {SU:"Sun",MO:"Mon",TU:"Tue",WE:"Wed",TH:"Thu",FR:"Fri",SA:"Sat"};
      const $ = s => document.querySelector(s);
      const $$ = s => Array.from(document.querySelectorAll(s));

      // ---------- inject modal + styles once ----------
      function ensureCronModal(){
        if (document.getElementById('fe-cron-overlay')) return;
        const css = document.createElement('style');
        css.id = 'fe-cron-style';
        css.textContent = `
    #fe-cron-overlay{position:fixed;inset:0;background:#0009;display:none;z-index:10000}
    #fe-cron-modal{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);width:720px;max-width:95vw;background:#1c2326;border:1px solid #3b4448;border-radius:14px;color:#e8f0f2;box-shadow:0 12px 40px #000c;font:14px/1.4 system-ui,Segoe UI,Roboto,Arial}
    #fe-cron-hd{display:flex;align-items:center;justify-content:space-between;padding:12px 14px;border-bottom:1px solid #2f373b}
    #fe-cron-tabs{display:flex;gap:6px;padding:8px 12px;border-bottom:1px solid #2f373b}
    #fe-cron-tabs button{cursor:pointer;border:1px solid #3a454a;background:#222b2f;color:#cfe6ee;padding:6px 10px;border-radius:10px}
    #fe-cron-tabs button.active{background:#2d3940;border-color:#4a5b62}
    #fe-cron-body{padding:12px 14px}
    .fe-row{display:flex;gap:10px;flex-wrap:wrap;margin:8px 0}
    .fe-col{display:flex;flex-direction:column;gap:6px}
    .fe-input,.fe-select{background:#1a2124;border:1px solid #3a454a;border-radius:8px;color:#e8f0f2;padding:6px 8px}
    .fe-chip{display:inline-block;border:1px solid #3a454a;background:#141a1d;color:#cde4ec;border-radius:999px;padding:3px 8px;margin:3px 6px 0 0;cursor:pointer;font-size:12px}
    .fe-hr{border:0;border-top:1px dashed #334047;margin:12px 0}
    #fe-cron-footer{display:flex;justify-content:space-between;gap:10px;padding:10px 14px;border-top:1px solid #2f373b}
    #fe-cron-preview{max-height:120px;overflow:auto;font-family:ui-monospace,SFMono-Regular,Consolas,monospace;font-size:12px;background:#111719;border:1px solid #2a3438;border-radius:8px;padding:8px}
    .fe-btn{cursor:pointer;border:1px solid #3a454a;background:#243037;color:#e8f0f2;padding:8px 12px;border-radius:10px}
    .fe-btn.primary{background:#3b7e9a;border-color:#4aa0c0}
    .fe-badge{display:inline-block;border:1px solid #3a454a;background:#12181b;color:#acd7e6;border-radius:999px;padding:2px 8px;font-size:12px;margin-left:6px}
    #fe-cron-days label{display:inline-flex;align-items:center;gap:6px;border:1px solid #3a454a;background:#141b1f;border-radius:10px;padding:4px 8px;margin:2px 4px 2px 0;user-select:none}
    #fe-cron-times div{display:flex;align-items:center;gap:6px;margin:4px 0}
        `;
        document.head.appendChild(css);

        const wrap = document.createElement('div');
        wrap.innerHTML = `
    <div id="fe-cron-overlay" role="dialog" aria-modal="true" aria-labelledby="fe-cron-title">
      <div id="fe-cron-modal">
        <div id="fe-cron-hd">
          <div><b id="fe-cron-title">Schedule Trigger</b><span id="fe-cron-badges"></span></div>
          <button class="fe-btn" id="fe-cron-close" title="Close">‚úï</button>
        </div>

        <div class="fe-row" style="padding:8px 14px 0 14px;">
          <div class="fe-col">
            <label>Skip dates ‚ñæ</label>
            <div class="fe-row">
              <input id="fe-cron-exc-date" type="date" class="fe-input">
              <button class="fe-btn" id="fe-cron-exc-add">Add</button>
              <div id="fe-cron-exc-list" style="align-self:center"></div>
            </div>
          </div>
        </div>

        <div id="schedule-tabs">
          <button data-tab="quick" class="active">Quick</button>
          <button data-tab="weekly">Weekly</button>
          <button data-tab="monthly">Monthly</button>
          <button data-tab="advanced">Advanced</button>
        </div>

        <div id="fe-cron-body">
          <div data-pane="quick">
            <div class="fe-col">
              <label>Time(s) ‚ñæ</label>
              <div id="fe-cron-times"></div>
              <button class="fe-btn" id="fe-cron-add-time">Add time</button>
            </div>
            <div class="fe-col">
              <label>Days</label>
              <div id="fe-cron-days"></div>
              <div>
                <span class="fe-chip" data-preset="weekdays">Weekdays</span>
                <span class="fe-chip" data-preset="weekends">Weekends</span>
                <span class="fe-chip" data-preset="everyday">Every day</span>
              </div>
            </div>
          </div>

          <div data-pane="weekly" hidden>
            <div class="fe-col">
              <label>Every N weeks</label>
              <input id="fe-week-interval" type="number" min="1" class="fe-input" style="width:100px" value="1">
            </div>
            <div class="fe-col">
              <label>Time(s) ‚ñæ</label>
              <div id="fe-week-times"></div>
              <button class="fe-btn" id="fe-week-add-time">Add time</button>
            </div>
            <div class="fe-col">
              <label>Days</label>
              <div id="fe-week-days"></div>
            </div>
          </div>

          <div data-pane="monthly" hidden>
            <div class="fe-row">
              <div class="fe-col">
                <label>Mode</label>
                <select id="fe-month-mode" class="fe-select" style="width:220px">
                  <option value="dom">On day(s) of month</option>
                  <option value="nth">On the Nth weekday</option>
                </select>
              </div>
              <div class="fe-col" id="fe-month-dom">
                <label>Days (e.g. 1,15,-1)</label>
                <input id="fe-month-days" class="fe-input" placeholder="1,15,-1">
              </div>
              <div class="fe-row" id="fe-month-nth" hidden>
                <div class="fe-col">
                  <label>Nth</label>
                  <select id="fe-month-n" class="fe-select"><option>1</option><option>2</option><option>3</option><option>4</option><option>Last</option></select>
                </div>
                <div class="fe-col">
                  <label>Weekday</label>
                  <select id="fe-month-wd" class="fe-select">
                    <option value="MO">Monday</option><option value="TU">Tuesday</option><option value="WE">Wednesday</option>
                    <option value="TH">Thursday</option><option value="FR">Friday</option><option value="SA">Saturday</option><option value="SU">Sunday</option>
                  </select>
                </div>
              </div>
            </div>
            <div class="fe-col">
              <label>Every N months</label>
              <input id="fe-month-interval" type="number" min="1" class="fe-input" style="width:100px" value="1">
            </div>
            <div class="fe-col">
              <label>Time(s) ‚ñæ</label>
              <div id="fe-month-times"></div>
              <button class="fe-btn" id="fe-month-add-time">Add time</button>
            </div>
          </div>

          <div data-pane="advanced" hidden>
            <div class="fe-col">
              <label>Cron expression</label>
              <input id="fe-cron-raw" class="fe-input" placeholder="e.g. 0 14 * * 3  (2:00 pm Wednesdays)">
              <div style="margin-top:6px">
                <span class="fe-chip" data-cron="*/5 * * * *">Every 5 min</span>
                <span class="fe-chip" data-cron="0 * * * *">Every hour</span>
                <span class="fe-chip" data-cron="0 8 * * 1-5">Weekdays 8:00</span>
              </div>
            </div>
          </div>

          <div class="fe-hr"></div>
          <div class="fe-row">
            <div class="fe-col" style="flex:1">
              <label>Preview (next 10)</label>
              <div id="fe-cron-preview">(changes update live)</div>
            </div>
          </div>
        </div>

        <div id="fe-cron-footer">
          <div><span id="fe-badge-rrule" class="fe-badge"></span><span id="fe-badge-cron" class="fe-badge"></span></div>
          <div><button class="fe-btn" id="fe-cron-reset">Reset</button><button class="fe-btn" id="fe-cron-cancel">Cancel</button><button class="fe-btn primary" id="fe-cron-insert">Insert Trigger</button></div>
        </div>
      </div>
    </div>`;
        
    // Remember which node this modal is editing
    if (typeof nodeId !== 'undefined') window.currentCronNodeId = nodeId;
    // Restore prior selections for this node
    if (window.currentCronNodeId) restoreScheduleUI(window.currentCronNodeId);
    document.body.appendChild(wrap.firstElementChild);
    }

    // ---------- helpers ----------
    function fmtTime12(hhmm){
      if(!hhmm) return '';
      const [h,m] = hhmm.split(':').map(x=>parseInt(x,10));
      const ampm = (h>=12?'PM':'AM');
      const hr = ((h%12)||12);
      return `${hr}:${String(m||0).padStart(2,'0')} ${ampm}`;
    }
    function daysSummary(list){
      const set = new Set(list||[]);
      if (DAYS.every(d=>set.has(d))) return 'Every day';
      const wk = ['MO','TU','WE','TH','FR']; const we = ['SA','SU'];
      const isWeekdays = wk.every(d=>set.has(d)) && we.every(d=>!set.has(d));
      const isWeekends = we.every(d=>set.has(d)) && wk.every(d=>!set.has(d));
      if (isWeekdays) return 'Weekdays';
      if (isWeekends) return 'Weekends';
      const ordered = DAYS.filter(d=>set.has(d)).map(d=>DNAME[d]).join(', ');
      return ordered || '‚Äî';
    }
    function buildCronFor(hhmm, byWeekday){
      // Very basic 5-field cron: m h * * DOW
      if(!hhmm){ return ''; }
      const [h,m] = hhmm.split(':');
      const dow = (byWeekday && byWeekday.length && byWeekday.length<7)
        ? byWeekday.map(d => ({SU:0,MO:1,TU:2,WE:3,TH:4,FR:5,SA:6}[d])).join(',')
        : '*';
      return `${parseInt(m,10)} ${parseInt(h,10)} * * ${dow}`;
    }

    // ---------- UI wiring ----------
    function fillDays(containerId, sel){
      const host = document.getElementById(containerId);
      host.innerHTML = '';
      DAYS.forEach(d=>{
        const id = `${containerId}-${d}`;
        const w = document.createElement('label');
        w.innerHTML = `<input type="checkbox" id="${id}"> ${DNAME[d]}`;
        host.appendChild(w);
        $('#'+id).checked = (sel||[]).includes(d);
      });
    }
    function getDays(containerId){
      return $$('#'+containerId+' input[type=checkbox]')
        .filter(i=>i.checked).map(i=>i.id.split('-').pop());
    }
    function addTimeRow(hostId, val){
      const host = document.getElementById(hostId);
      const div = document.createElement('div');
      div.innerHTML = `<input type="time" class="fe-input" value="${val||''}"><button class="fe-btn" title="Remove">‚úï</button>`;
      host.appendChild(div);
      div.querySelector('button').onclick = ()=> div.remove();
    }
    function getTimes(hostId){
      return $$('#'+hostId+' input[type=time]').map(i=>i.value).filter(Boolean);
    }
    function badges(spec, outCron){
      $('#fe-badge-rrule').textContent = spec.kind==='advanced_cron' ? '' : 'Cron';
      $('#fe-badge-cron').textContent = outCron ? ('Cron: '+outCron) : '';
    }

    // ---------- open/close + read spec ----------
    function openCron(spec, nodeId){
      ensureCronModal();
      const ov = $('#fe-cron-overlay');
      ov.dataset.nodeId = (nodeId!=null? String(nodeId) : '');
      // default spec
      spec = spec || { kind:'quick', by_weekday:["MO","TU","WE","TH","FR"], times:["08:00"] };

      // tabs
      $$('#fe-cron-tabs button').forEach(b=>{
        b.onclick = () => {
          $$('#fe-cron-tabs button').forEach(x=>x.classList.remove('active'));
          b.classList.add('active');
          const tab = b.getAttribute('data-tab');
          $$('#fe-cron-body [data-pane]').forEach(p=>p.hidden = p.getAttribute('data-pane')!==tab);
        };
      });

      // times/days (quick)
      fillDays('fe-cron-days', spec.by_weekday || []);
      $('#fe-cron-times').innerHTML='';
      (spec.times||['08:00']).forEach(t=>addTimeRow('fe-cron-times', t));
      $('#fe-cron-add-time').onclick = () => addTimeRow('fe-cron-times', '');

      // presets
      $$('#fe-cron-body [data-preset]').forEach(ch => ch.onclick = ()=>{
        const k = ch.getAttribute('data-preset');
        let val = [];
        if (k==='everyday') val = DAYS.slice();
        if (k==='weekdays') val = ['MO','TU','WE','TH','FR'];
        if (k==='weekends') val = ['SA','SU'];
        fillDays('fe-cron-days', val);
        refreshPreview();
      });

      // weekly
      $('#fe-week-interval').value = (spec.week_interval||1);
      fillDays('fe-week-days', spec.by_weekday || []);
      $('#fe-week-times').innerHTML='';
      (spec.times||['08:00']).forEach(t=>addTimeRow('fe-week-times', t));
      $('#fe-week-add-time').onclick = ()=> addTimeRow('fe-week-times','');

      // monthly
      $('#fe-month-mode').value = (spec.month_mode || 'dom');
      $('#fe-month-days').value = (spec.month_days || '');
      $('#fe-month-n').value = (spec.month_n || '1');
      $('#fe-month-wd').value = (spec.month_wd || 'MO');
      $('#fe-month-interval').value = (spec.month_interval || 1);
      toggleMonthlyMode();
      function toggleMonthlyMode(){
        const mode = $('#fe-month-mode').value;
        $('#fe-month-dom').hidden = (mode!=='dom');
        $('#fe-month-nth').hidden = (mode!=='nth');
        refreshPreview();
      }
      $('#fe-month-mode').onchange = toggleMonthlyMode;
      $('#fe-month-add-time').onclick = ()=> addTimeRow('fe-month-times','');
      $('#fe-month-times').innerHTML='';
      (spec.times||['08:00']).forEach(t=>addTimeRow('fe-month-times', t));

      // advanced
      $('#fe-cron-raw').value = spec.cronText || '';
      $$('#fe-cron-body [data-cron]').forEach(c=> c.onclick = ()=>{
        $('#fe-cron-raw').value = c.getAttribute('data-cron');
        refreshPreview();
      });

      // exclude dates
      const excHost = $('#fe-cron-exc-list');
      excHost.innerHTML='';
      (spec.exclude_dates||[]).forEach(d=> addExc(d));
      $('#fe-cron-exc-add').onclick = ()=>{
        const v = $('#fe-cron-exc-date').value;
        if (v) addExc(v);
      };
      function addExc(v){
        const s = document.createElement('span');
        s.className='fe-chip';
        s.textContent=v;
        s.title='Remove';
        s.onclick=()=> s.remove();
        excHost.appendChild(s);
      }

      // preview + badges
      function readSpec(){
        const activeTab = ($('#fe-cron-tabs .active')||{}).getAttribute && $('#fe-cron-tabs .active').getAttribute('data-tab');

        const out = { kind: activeTab||'quick' };
        if (out.kind==='advanced') {
          out.kind = 'advanced_cron';
          out.cronText = $('#fe-cron-raw').value.trim();
        } else if (out.kind==='weekly') {
          out.by_weekday = getDays('fe-week-days');
          out.times = getTimes('fe-week-times');
          out.week_interval = Math.max(1, parseInt($('#fe-week-interval').value||'1',10));
        } else if (out.kind==='monthly') {
          out.month_mode = $('#fe-month-mode').value;
          out.times = getTimes('fe-month-times');
          out.month_interval = Math.max(1, parseInt($('#fe-month-interval').value||'1',10));
          if (out.month_mode==='dom') {
            out.month_days = ($('#fe-month-days').value||'').trim();
          } else {
            out.month_n = $('#fe-month-n').value;
            out.month_wd = $('#fe-month-wd').value;
          }
        } else {
          out.kind = 'quick';
          out.by_weekday = getDays('fe-cron-days');
          out.times = getTimes('fe-cron-times');
        }
        out.exclude_dates = $$('#fe-cron-exc-list .fe-chip').map(x=>x.textContent);
        return out;
      }
      function refreshPreview(){
      const s = readSpec();
      const DOW_MAP = {SU:0,MO:1,TU:2,WE:3,TH:4,FR:5,SA:6};
      const toHM = (t)=>{ const [h,m] = String(t||'08:00').split(':').map(x=>parseInt(x,10)||0); return {h,m}; };
      const fmt = (d)=>{
        try{
          return d.toLocaleString(undefined,{weekday:'short', month:'short', day:'numeric', year:'numeric', hour:'numeric', minute:'2-digit'});
        }catch(_){ return d.toString(); }
      };
      const isExcluded = (d)=>{
        const y = d.getFullYear(), m = String(d.getMonth()+1).padStart(2,'0'), dd = String(d.getDate()).padStart(2,'0');
        const key = `${y}-${m}-${dd}`;
        return (s.exclude_dates||[]).some(x=>String(x).slice(0,10)===key);
      };
      const pushIf = (arr, d)=>{ if (d > new Date() && !isExcluded(d)) arr.push(new Date(d)); };

      let next = [];

      if (s.kind === 'advanced_cron') {
        const txt = (s.cronText||'').trim();
        let mm=null, hh=null, dows='*';
        const parts = txt.split(/\s+/);
        if (parts.length>=5) { mm = parseInt(parts[0],10); hh = parseInt(parts[1],10); dows = parts[4]||'*'; }
        const set = new Set();
        if (dows==='*' || isNaN(mm)||isNaN(hh)) {
          next = [txt];
        } else {
          const addRange=(a,b)=>{ for(let i=a;i<=b;i++) set.add(((i%7)+7)%7); };
          dows.split(',').forEach(tok=>{
            if (/^\d+-\d+$/.test(tok)){ const [a,b]=tok.split('-').map(n=>parseInt(n,10)); addRange(a,b); }
            else if (/^\d+$/.test(tok)){ set.add(parseInt(tok,10)); }
          });
          let d = new Date(); d.setSeconds(0,0);
          for(let i=0; next.length<10 && i<800; i++){
            if (set.has(d.getDay()) || set.size===0) {
              const cand = new Date(d.getFullYear(), d.getMonth(), d.getDate(), hh, mm, 0, 0);
              pushIf(next, cand);
            }
            d.setDate(d.getDate()+1);
          }
          next = next.sort((a,b)=>a-b).slice(0,10).map(fmt);
        }
      } else if (s.kind === 'monthly') {
        const times = (s.times && s.times.length ? s.times : ['08:00']).map(toHM);
        const interval = Math.max(1, parseInt(s.month_interval||1,10));
        let month = new Date(); month.setHours(0,0,0,0);
        let count = 0;
        while (next.length<10 && count<24){
          if ((s.month_mode||'dom') === 'nth') {
            const nth = (s.month_n||'1');
            const wd = DOW_MAP[s.month_wd] ?? 1;
            const first = new Date(month.getFullYear(), month.getMonth(), 1);
            const day0 = first.getDay();
            let date = 1 + ((wd - day0 + 7) % 7);
            if (String(nth).toLowerCase()==='last'){
              const lastDay = new Date(month.getFullYear(), month.getMonth()+1, 0);
              const back = ((lastDay.getDay() - wd + 7) % 7);
              date = lastDay.getDate() - back;
            } else {
              const k = parseInt(nth,10)||1;
              date += 7*(k-1);
            }
            times.forEach(t=>pushIf(next, new Date(month.getFullYear(), month.getMonth(), date, t.h, t.m, 0, 0)));
          } else {
            const raw = String(s.month_days||'').trim();
            const days = raw ? raw.split(/\s*,\s*/).filter(Boolean) : [];
            const last = new Date(month.getFullYear(), month.getMonth()+1, 0).getDate();
            (days.length?days:[1]).forEach(dv=>{
              let dd = parseInt(dv,10);
              if (String(dv).startsWith('-')) dd = last + 1 + dd;
              if (dd>=1 && dd<=last){
                times.forEach(t=>pushIf(next, new Date(month.getFullYear(), month.getMonth(), dd, t.h, t.m, 0, 0)));
              }
            });
          }
          count++;
          month = new Date(month.getFullYear(), month.getMonth()+interval, 1);
        }
        next = next.sort((a,b)=>a-b).slice(0,10).map(fmt);
      } else {
        const by = (s.by_weekday && s.by_weekday.length) ? s.by_weekday : ["SU","MO","TU","WE","TH","FR","SA"];
        const weekInterval = s.kind==='weekly' ? Math.max(1, parseInt(s.week_interval||1,10)) : 1;
        const times = (s.times && s.times.length ? s.times : ['08:00']).map(toHM);
        const now = new Date();
        const startMonday = new Date(now);
        const dow = startMonday.getDay();
        const diffToMon = (dow+6)%7;
        startMonday.setDate(startMonday.getDate()-diffToMon);
        startMonday.setHours(0,0,0,0);
        let d = new Date(startMonday);
        for (let days=0; next.length<10 && days<365; days++){
          const thisWeekIndex = Math.floor((d - startMonday)/(7*24*3600*1000));
          const weekOk = (thisWeekIndex % weekInterval)===0;
          const code = Object.keys(DOW_MAP).find(k=>DOW_MAP[k]===d.getDay());
          if (weekOk && by.includes(code)){
            times.forEach(t=>pushIf(next, new Date(d.getFullYear(), d.getMonth(), d.getDate(), t.h, t.m, 0, 0)));
          }
          d.setDate(d.getDate()+1);
        }
        next = next.sort((a,b)=>a-b).slice(0,10).map(fmt);
      }

      const host = document.getElementById('fe-cron-preview');
      if (Array.isArray(next)) {
        host.innerHTML = next.length ? next.join('<br>') : '(no upcoming times in range)';
      } else {
        host.textContent = next || '';
      }
      badges(s, (typeof s.cronText==='string' && s.cronText.trim()) ? s.cronText.trim() : '');
    }

    // events
    $('#fe-cron-close').onclick = ()=> $('#fe-cron-overlay').style.display='none';
    $('#fe-cron-cancel').onclick = ()=> $('#fe-cron-overlay').style.display='none';
    $$('#fe-cron-body input, #fe-cron-body select').forEach(el=> el.oninput = refreshPreview);

    // show modal
    $('#fe-cron-overlay').style.display='block';
    refreshPreview();
  }

  // expose & wiring
  const API = {
    open: openCron,
    getSpec: function(){ /* used during insert */ return null; }
  };
  window.FE_Cron = API;

  // Intercept toolbar "Schedule Trigger" so it opens the popup (no auto-node)
  document.addEventListener('click', function(e){
    const b = e.target && e.target.closest && e.target.closest('#addSchedule');
    if (!b) return;
    try{ e.preventDefault(); e.stopImmediatePropagation(); e.stopPropagation(); }catch(_){}
    // new node via Insert; here we just open UI with defaults
    openCron(null, null);
  }, true);

  // Double-click schedule node to edit
  document.addEventListener('DOMContentLoaded', function(){
    ensureCronModal();
    const df = document.getElementById('drawflow');
    if (!df || df.__fe_sched_dbl) return;
    df.__fe_sched_dbl = true;
    df.addEventListener('dblclick', function(e){
      const nodeEl = e.target && e.target.closest ? e.target.closest('.drawflow-node') : null;
      if(!nodeEl) return;
      const id = (nodeEl.id||'').replace('node-','');
      if(!id || !window.editor) return;
      try{
        const n = window.editor.getNodeFromId(id);
        if (!n || (n.name||'').toLowerCase()!=='schedule') return;
        // Pre-fill from existing
        const spec = (n.data && n.data.scheduleSpec) ? n.data.scheduleSpec : null;
        openCron(spec||null, parseInt(id,10));
      }catch(_){}
    });
  });

  // Insert Trigger: add or update node + sticky tile content
  document.addEventListener('click', function(e){
    const btn = e.target && e.target.closest && e.target.closest('#fe-cron-insert');
    if (!btn) return;
    try{ e.preventDefault(); e.stopImmediatePropagation(); e.stopPropagation(); }catch(_){}

    const ov = document.getElementById('fe-cron-overlay');
    // read spec from UI
    function readSpecForSave(){
      const active = ($('#fe-cron-tabs .active')||{}).getAttribute && $('#fe-cron-tabs .active').getAttribute('data-tab');
      // reuse reader from openCron scope by rebuilding minimal spec:
      // (We re-query fields directly to keep it self-contained.)
      const out = { kind: active||'quick' };
      if (out.kind==='advanced') {
        out.kind='advanced_cron';
        out.cronText = ($('#fe-cron-raw')||{}).value || '';
        out.times = [];
        out.by_weekday = [];
      } else if (out.kind==='weekly') {
        out.by_weekday = Array.from(document.querySelectorAll('#fe-week-days input:checked')).map(i=>i.id.split('-').pop());
        out.times = Array.from(document.querySelectorAll('#fe-week-times input[type=time]')).map(i=>i.value).filter(Boolean);
        out.week_interval = Math.max(1, parseInt(($('#fe-week-interval')||{}).value||'1',10));
      } else if (out.kind==='monthly') {
        out.month_mode = ($('#fe-month-mode')||{}).value || 'dom';
        out.times = Array.from(document.querySelectorAll('#fe-month-times input[type=time]')).map(i=>i.value).filter(Boolean);
        out.month_interval = Math.max(1, parseInt(($('#fe-month-interval')||{}).value||'1',10));
        if (out.month_mode==='dom') out.month_days = ($('#fe-month-days')||{}).value || '';
        else { out.month_n = ($('#fe-month-n')||{}).value || '1'; out.month_wd = ($('#fe-month-wd')||{}).value || 'MO'; }
      } else {
        out.kind='quick';
        out.by_weekday = Array.from(document.querySelectorAll('#fe-cron-days input:checked')).map(i=>i.id.split('-').pop());
        out.times = Array.from(document.querySelectorAll('#fe-cron-times input[type=time]')).map(i=>i.value).filter(Boolean);
      }
      out.exclude_dates = Array.from(document.querySelectorAll('#fe-cron-exc-list .fe-chip')).map(x=>x.textContent);
      // build simple cron(s)
      const by = (out.by_weekday && out.by_weekday.length) ? out.by_weekday : DAYS.slice();
      const times = out.times && out.times.length ? out.times : ['08:00'];
      const cronList = (out.kind==='advanced_cron') ? [out.cronText||''] : times.map(t=>buildCronFor(t, by));
      out.cronText = cronList.join(' ‚Ä¢ ');
      return out;
    }

    const spec = readSpecForSave();
    const by = (spec.by_weekday && spec.by_weekday.length) ? spec.by_weekday : DAYS.slice();
    const times = spec.times && spec.times.length ? spec.times : ['08:00'];

    // prepare tile data
    const tileData = {
      cron: spec.cronText || '',
      repeatDays: by,
      time: times[0] || '',
      scheduleSpec: spec
    };

    // update existing or add new
    if (ov && ov.dataset && ov.dataset.nodeId) {
      const id = parseInt(ov.dataset.nodeId,10);
      try{
        const ed = window.editor;
        const node = ed && ed.getNodeFromId ? ed.getNodeFromId(id) : null;
        if (node) {
          node.data = Object.assign({}, node.data, tileData);
          if (typeof ed.updateNodeHtmlFromId === 'function') {
            ed.updateNodeHtmlFromId(id, nodeTileHtml('schedule', node.data, id));
          }
        }
              if (typeof ed.updateNodeDataFromId === 'function') { ed.updateNodeDataFromId(id, node.data); }
        }catch(_){}
    } else {
      try {
        const ed = window.editor;
        // center-ish position
        const vp = ed.precanvas.getBoundingClientRect();
        const x = (ed.canvas_x * -1) + vp.width/2 - 90;
        const y = (ed.canvas_y * -1) + vp.height/2 - 40;
        ed.addNode('schedule', 0, 1, x, y, 'schedule', tileData);
      } catch(_){}
    }

    try{ window.markFlowNeedsSave && window.markFlowNeedsSave(true); }catch(_){}
    if (ov) ov.style.display='none';
  });

  // ---------- Tile rendering (sticky across refresh) ----------
  (function installNodeTileHtmlOverride(){
    const orig = window.nodeTileHtml;
    function scheduleTileHtml(data){
      const daysTxt = daysSummary((data && data.scheduleSpec && data.scheduleSpec.by_weekday) || (data && data.repeatDays) || []);
      const timesArr = (data && data.scheduleSpec && data.scheduleSpec.times) || (data && data.times) || [];
      const timeTxt = (timesArr.length ? timesArr.map(fmtTime12).join(', ') : (data && data.time ? fmtTime12(data.time) : '‚Äî'));
      const cronTxt = (data && data.scheduleSpec && data.scheduleSpec.cronText) || (data && data.cron) || '';
      return `
        <div class="tile-title" style="font-weight:600;margin-bottom:4px">Schedule</div>
        <div class="tile-sub" style="font-size:12px;opacity:.9;line-height:1.35">
          <div>Days: ${daysTxt}</div>
          <div>Time: ${timeTxt}</div>
        </div>
        <div style="border-top:1px solid #3a454a;margin:8px 0"></div>
        <div class="tile-cron" style="font-family:ui-monospace,Consolas,monospace;font-size:12px;opacity:.95">${cronTxt||''}</div>
      `;
    }
    window.nodeTileHtml = function(name, data, id){
      if ((name||'').toLowerCase()==='schedule') return scheduleTileHtml(data||{});
      if (typeof orig === 'function') return orig(name, data, id);
      // generic fallback
      return `<div style="font-weight:600">${name||'Node'}</div>`;
    };
  })();

  // Ensure any legacy timezone rows in other popups are hidden and caret-y sections get wired (if present)
  document.addEventListener('DOMContentLoaded', function(){
    // If your file had an enhancer, keep the behavior: hide timezone + add carets
    try{
      const root = document.getElementById('feSchedulePopup') || document.getElementById('scheduleModal') || document.getElementById('schedulePopup') || document.getElementById('fe-scheduler-modal');
      if (root){
        root.querySelectorAll('[data-field="timezone"], .timezone-row, .tz-row').forEach(el => el.style.display='none');
      }
    }catch(_){}
  });
})();
  </script>
  <!-- BEGIN_FE_CRON_ONLY -->
  <script>
    // Single-file Cron-based Schedule Trigger UI for FE Editor
    (function(){
      const DAYS = ["SU","MO","TU","WE","TH","FR","SA"];
      const DNAME = {SU:"Sun",MO:"Mon",TU:"Tue",WE:"Wed",TH:"Thu",FR:"Fri",SA:"Sat"};
      const $ = s => document.querySelector(s);
      const $$ = s => Array.from(document.querySelectorAll(s));

      function ensureCronModal(){
        if (document.getElementById('fe-cron-overlay')) return;
        const css = document.createElement('style');
        css.id = 'fe-cron-style';
        css.textContent = `#fe-cron-overlay{position:fixed;inset:0;background:#0009;display:none;z-index:10000}
    #fe-cron-modal{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);width:720px;max-width:95vw;background:#1c2326;border:1px solid #3b4448;border-radius:14px;color:#e8f0f2;box-shadow:0 12px 40px #000c;font:14px/1.4 system-ui,Segoe UI,Roboto,Arial}
    #fe-cron-hd{display:flex;align-items:center;justify-content:space-between;padding:12px 14px;border-bottom:1px solid #2f373b}
    #fe-cron-tabs{display:flex;gap:6px;padding:8px 12px;border-bottom:1px solid #2f373b}
    #fe-cron-tabs button{cursor:pointer;border:1px solid #3a454a;background:#222b2f;color:#cfe6ee;padding:6px 10px;border-radius:10px}
    #fe-cron-tabs button.active{background:#2d3940;border-color:#4a5b62}
    #fe-cron-body{padding:12px 14px}.fe-row{display:flex;gap:10px;flex-wrap:wrap;margin:8px 0}.fe-col{display:flex;flex-direction:column;gap:6px}
    .fe-input,.fe-select{background:#1a2124;border:1px solid #3a454a;border-radius:8px;color:#e8f0f2;padding:6px 8px}
    .fe-chip{display:inline-block;border:1px solid #3a454a;background:#141a1d;color:#cde4ec;border-radius:999px;padding:3px 8px;margin:3px 6px 0 0;cursor:pointer;font-size:12px}
    .fe-hr{border:0;border-top:1px dashed #334047;margin:12px 0}
    #fe-cron-footer{display:flex;justify-content:space-between;gap:10px;padding:10px 14px;border-top:1px solid #2f373b}
    #fe-cron-preview{max-height:120px;overflow:auto;font-family:ui-monospace,SFMono-Regular,Consolas,monospace;font-size:12px;background:#111719;border:1px solid #2a3438;border-radius:8px;padding:8px}
    .fe-btn{cursor:pointer;border:1px solid #3a454a;background:#243037;color:#e8f0f2;padding:8px 12px;border-radius:10px}.fe-btn.primary{background:#3b7e9a;border-color:#4aa0c0}
    .fe-badge{display:inline-block;border:1px solid #3a454a;background:#12181b;color:#acd7e6;border-radius:999px;padding:2px 8px;font-size:12px;margin-left:6px}
    #fe-cron-days label{display:inline-flex;align-items:center;gap:6px;border:1px solid #3a454a;background:#141b1f;border-radius:10px;padding:4px 8px;margin:2px 4px 2px 0;user-select:none}
    #fe-cron-times div{display:flex;align-items:center;gap:6px;margin:4px 0}`;
        document.head.appendChild(css);

        const wrap = document.createElement('div');
        wrap.innerHTML = `
        <div id="fe-cron-overlay" role="dialog" aria-modal="true" aria-labelledby="fe-cron-title">
          <div id="fe-cron-modal">
            <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:12px;">
              <b id="fe-cron-title">Schedule Trigger</b>
              <div>
                <button id="fe-cron-reset"
                        style="margin-right:8px; padding:6px 14px; border-radius:7px; cursor:pointer;">
                  Reset
                </button>
                <button id="fe-cron-cancel"
                        style="margin-right:8px; padding:6px 14px; border-radius:7px; cursor:pointer;">
                  Cancel
                </button>
                <button id="fe-cron-insert"
                        style="padding:6px 14px; border-radius:7px; background:#3498db; color:#fff; cursor:pointer;">
                  Insert Trigger
                </button>
              </div>
            </div>

            <div class="fe-row" style="padding:8px 14px 0 14px;">
              <div class="fe-col">
                <label>Skip dates ‚ñæ</label>
                <div class="fe-row">
                  <input id="fe-cron-exc-date" type="date" class="fe-input">
                  <button class="fe-btn" id="fe-cron-exc-add">Add</button>
                  <div id="fe-cron-exc-list" style="align-self:center"></div>
                </div>
              </div>
            </div>

            <div id="fe-cron-tabs">
              <button data-tab="quick" class="active">Quick</button>
              <button data-tab="weekly">Weekly</button>
              <button data-tab="monthly">Monthly</button>
              <button data-tab="advanced">Advanced</button>
            </div>

            <div id="fe-cron-body">
              <div data-pane="quick">
                <div class="fe-col">
                  <label>Time(s) ‚ñæ</label>
                  <div id="fe-cron-times"></div>
                  <button class="fe-btn" id="fe-cron-add-time">Add time</button>
                </div>
                <div class="fe-col">
                  <label>Days</label>
                  <div id="fe-cron-days"></div>
                  <div>
                    <span class="fe-chip" data-preset="weekdays">Weekdays</span>
                    <span class="fe-chip" data-preset="weekends">Weekends</span>
                    <span class="fe-chip" data-preset="everyday">Every day</span>
                  </div>
                </div>
              </div>

              <div data-pane="weekly" hidden>
                <div class="fe-col">
                  <label>Every N weeks</label>
                  <input id="fe-week-interval" type="number" min="1" class="fe-input" style="width:100px" value="1">
                </div>
                <div class="fe-col">
                  <label>Time(s) ‚ñæ</label>
                  <div id="fe-week-times"></div>
                  <button class="fe-btn" id="fe-week-add-time">Add time</button>
                </div>
                <div class="fe-col">
                  <label>Days</label>
                  <div id="fe-week-days"></div>
                </div>
              </div>

              <div data-pane="monthly" hidden>
                <div class="fe-row">
                  <div class="fe-col">
                    <label>Mode</label>
                    <select id="fe-month-mode" class="fe-select" style="width:220px">
                      <option value="dom">On day(s) of month</option>
                      <option value="nth">On the Nth weekday</option>
                    </select>
                  </div>
                  <div class="fe-col" id="fe-month-dom">
                    <label>Days (e.g. 1,15,-1)</label>
                    <input id="fe-month-days" class="fe-input" placeholder="1,15,-1">
                  </div>
                  <div class="fe-row" id="fe-month-nth" hidden>
                    <div class="fe-col">
                      <label>Nth</label>
                      <select id="fe-month-n" class="fe-select"><option>1</option><option>2</option><option>3</option><option>4</option><option>Last</option></select>
                    </div>
                    <div class="fe-col">
                      <label>Weekday</label>
                      <select id="fe-month-wd" class="fe-select">
                        <option value="MO">Monday</option><option value="TU">Tuesday</option><option value="WE">Wednesday</option>
                        <option value="TH">Thursday</option><option value="FR">Friday</option><option value="SA">Saturday</option><option value="SU">Sunday</option>
                      </select>
                    </div>
                  </div>
                </div>
                <div class="fe-col">
                  <label>Every N months</label>
                  <input id="fe-month-interval" type="number" min="1" class="fe-input" style="width:100px" value="1">
                </div>
                <div class="fe-col">
                  <label>Time(s) ‚ñæ</label>
                  <div id="fe-month-times"></div>
                  <button class="fe-btn" id="fe-month-add-time">Add time</button>
                </div>
              </div>

              <div data-pane="advanced" hidden>
                <div class="fe-col">
                  <label>Cron expression</label>
                  <input id="fe-cron-raw" class="fe-input" placeholder="e.g. 0 14 * * 3  (2:00 pm Wednesdays)">
                  <div style="margin-top:6px">
                    <span class="fe-chip" data-cron="*/5 * * * *">Every 5 min</span>
                    <span class="fe-chip" data-cron="0 * * * *">Every hour</span>
                    <span class="fe-chip" data-cron="0 8 * * 1-5">Weekdays 8:00</span>
                  </div>
                </div>
              </div>

              <div class="fe-hr"></div>
              <div class="fe-row">
                <div class="fe-col" style="flex:1">
                  <label>Preview (next 10)</label>
                  <div id="fe-cron-preview">(changes update live)</div>
                </div>
              </div>
            </div>
          </div>
        </div>`;
        
    // Remember which node this modal is editing
    if (typeof nodeId !== 'undefined') window.currentCronNodeId = nodeId;
    // Restore prior selections for this node
    if (window.currentCronNodeId) restoreScheduleUI(window.currentCronNodeId);
    document.body.appendChild(wrap.firstElementChild);
      }

      function fmtTime12(hhmm){
        if(!hhmm) return '';
        const [h,m] = hhmm.split(':').map(x=>parseInt(x,10));
        const ampm = (h>=12?'PM':'AM');
        const hr = ((h%12)||12);
        return `${hr}:${String(m||0).padStart(2,'0')} ${ampm}`;
      }
      function daysSummary(list){
        const set = new Set(list||[]);
        if (DAYS.every(d=>set.has(d))) return 'Every day';
        const wk = ['MO','TU','WE','TH','FR']; const we = ['SA','SU'];
        const isWeekdays = wk.every(d=>set.has(d)) && we.every(d=>!set.has(d));
        const isWeekends = we.every(d=>set.has(d)) && wk.every(d=>!set.has(d));
        if (isWeekdays) return 'Weekdays';
        if (isWeekends) return 'Weekends';
        const ordered = DAYS.filter(d=>set.has(d)).map(d=>DNAME[d]).join(', ');
        return ordered || '‚Äî';
      }
      function buildCronFor(hhmm, byWeekday){
        if(!hhmm){ return ''; }
        const [h,m] = hhmm.split(':');
        const dow = (byWeekday && byWeekday.length && byWeekday.length<7)
          ? byWeekday.map(d => ({SU:0,MO:1,TU:2,WE:3,TH:4,FR:5,SA:6}[d])).join(',')
          : '*';
        return `${parseInt(m,10)} ${parseInt(h,10)} * * ${dow}`;
      }
      function fillDays(containerId, sel){
        const host = document.getElementById(containerId);
        host.innerHTML = '';
        DAYS.forEach(d=>{
          const id = `${containerId}-${d}`;
          const w = document.createElement('label');
          w.innerHTML = `<input type="checkbox" id="${id}"> ${DNAME[d]}`;
          host.appendChild(w);
          document.getElementById(id).checked = (sel||[]).includes(d);
        });
      }
      function getDays(containerId){
        return Array.from(document.querySelectorAll('#'+containerId+' input[type=checkbox]'))
          .filter(i=>i.checked).map(i=>i.id.split('-').pop());
      }
      function addTimeRow(hostId, val){
        const host = document.getElementById(hostId);
        const div = document.createElement('div');
        div.innerHTML = `<input type="time" class="fe-input" value="${val||''}"><button class="fe-btn" title="Remove">‚úï</button>`;
        host.appendChild(div);
        div.querySelector('button').onclick = ()=> div.remove();
      }
      function getTimes(hostId){
        return Array.from(document.querySelectorAll('#'+hostId+' input[type=time]')).map(i=>i.value).filter(Boolean);
      }
      function badges(spec, outCron){
        const b1 = document.getElementById('fe-badge-rrule'), b2 = document.getElementById('fe-badge-cron');
        if (b1) b1.textContent = spec.kind==='advanced_cron' ? '' : 'Cron';
        if (b2) b2.textContent = outCron ? ('Cron: '+outCron) : '';
      }

      function openCron(spec, nodeId){
        ensureCronModal();
        const ov = document.getElementById('fe-cron-overlay');
        ov.dataset.nodeId = (nodeId!=null? String(nodeId) : '');
        spec = spec || { kind:'quick', by_weekday:["MO","TU","WE","TH","FR"], times:["08:00"] };

        // Tabs
        Array.from(document.querySelectorAll('#fe-cron-tabs button')).forEach(b=>{
          b.onclick = () => {
            Array.from(document.querySelectorAll('#fe-cron-tabs button')).forEach(x=>x.classList.remove('active'));
            b.classList.add('active');
            const tab = b.getAttribute('data-tab');
            Array.from(document.querySelectorAll('#fe-cron-body [data-pane]'))
              .forEach(p=>p.hidden = p.getAttribute('data-pane')!==tab);
          };
        });

        const initialTab = (spec.kind === 'advanced_cron' ? 'advanced' : (spec.kind || 'quick'));
        const initBtn = document.querySelector(`#fe-cron-tabs [data-tab="${initialTab}"]`);
        if (initBtn) initBtn.click();

        // Quick
        fillDays('fe-cron-days', spec.by_weekday || []);
        document.getElementById('fe-cron-times').innerHTML='';
        (spec.times||['08:00']).forEach(t=>addTimeRow('fe-cron-times', t));
        document.getElementById('fe-cron-add-time').onclick = () => addTimeRow('fe-cron-times', '');

        // Presets
        Array.from(document.querySelectorAll('#fe-cron-body [data-preset]')).forEach(ch => ch.onclick = ()=>{
          const k = ch.getAttribute('data-preset');
          let val = [];
          if (k==='everyday') val = DAYS.slice();
          if (k==='weekdays') val = ['MO','TU','WE','TH','FR'];
          if (k==='weekends') val = ['SA','SU'];
          fillDays('fe-cron-days', val);
          refreshPreview();
        });

        // Weekly
        document.getElementById('fe-week-interval').value = (spec.week_interval||1);
        fillDays('fe-week-days', spec.by_weekday || []);
        document.getElementById('fe-week-times').innerHTML='';
        (spec.times||['08:00']).forEach(t=>addTimeRow('fe-week-times', t));
        document.getElementById('fe-week-add-time').onclick = ()=> addTimeRow('fe-week-times','');

        // Monthly
        document.getElementById('fe-month-mode').value = (spec.month_mode || 'dom');
        document.getElementById('fe-month-days').value = (spec.month_days || '');
        document.getElementById('fe-month-n').value = (spec.month_n || '1');
        document.getElementById('fe-month-wd').value = (spec.month_wd || 'MO');
        document.getElementById('fe-month-interval').value = (spec.month_interval || 1);
        const toggleMonthlyMode = () => {
          const mode = document.getElementById('fe-month-mode').value;
          document.getElementById('fe-month-dom').hidden = (mode!=='dom');
          document.getElementById('fe-month-nth').hidden = (mode!=='nth');
          refreshPreview();
        };
        document.getElementById('fe-month-mode').onchange = toggleMonthlyMode;
        toggleMonthlyMode();
        document.getElementById('fe-month-add-time').onclick = ()=> addTimeRow('fe-month-times','');
        document.getElementById('fe-month-times').innerHTML='';
        (spec.times||['08:00']).forEach(t=>addTimeRow('fe-month-times', t));

        // Advanced
        const cronRaw = document.getElementById('fe-cron-raw');
        cronRaw.value = spec.cronText || '';
        Array.from(document.querySelectorAll('#fe-cron-body [data-cron]')).forEach(c=> c.onclick = ()=>{
          cronRaw.value = c.getAttribute('data-cron');
          refreshPreview();
        });

        // Exclude dates
        const excHost = document.getElementById('fe-cron-exc-list');
        excHost.innerHTML='';
        (spec.exclude_dates||[]).forEach(d=> addExc(d));
        document.getElementById('fe-cron-exc-add').onclick = ()=>{
          const v = document.getElementById('fe-cron-exc-date').value;
          if (v) addExc(v);
        };
        function addExc(v){
          const s = document.createElement('span');
          s.className='fe-chip';
          s.textContent=v;
          s.title='Remove';
          s.onclick=()=> s.remove();
          excHost.appendChild(s);
        }

        function readSpec(){
          const activeBtn = document.querySelector('#fe-cron-tabs .active');
          const tab = activeBtn && activeBtn.getAttribute('data-tab');
          const out = { kind: tab||'quick' };
          if (out.kind==='advanced') {
            out.kind = 'advanced_cron';
            out.cronText = (cronRaw.value||'').trim();
          } else if (out.kind==='weekly') {
            out.by_weekday = getDays('fe-week-days');
            out.times = getTimes('fe-week-times');
            out.week_interval = Math.max(1, parseInt((document.getElementById('fe-week-interval').value||'1'),10));
          } else if (out.kind==='monthly') {
            out.month_mode = document.getElementById('fe-month-mode').value;
            out.times = getTimes('fe-month-times');
            out.month_interval = Math.max(1, parseInt((document.getElementById('fe-month-interval').value||'1'),10));
            if (out.month_mode==='dom') {
              out.month_days = (document.getElementById('fe-month-days').value||'').trim();
            } else {
              out.month_n = document.getElementById('fe-month-n').value;
              out.month_wd = document.getElementById('fe-month-wd').value;
            }
          } else {
            out.kind = 'quick';
            out.by_weekday = getDays('fe-cron-days');
            out.times = getTimes('fe-cron-times');
          }
          out.exclude_dates = Array.from(document.querySelectorAll('#fe-cron-exc-list .fe-chip')).map(x=>x.textContent);
          return out;
        }
        
        document.getElementById('fe-cron-close').onclick = ()=> document.getElementById('fe-cron-overlay').style.display='none';
        document.getElementById('fe-cron-cancel').onclick = ()=> document.getElementById('fe-cron-overlay').style.display='none';
        Array.from(document.querySelectorAll('#fe-cron-body input, #fe-cron-body select')).forEach(el=> el.oninput = refreshPreview);

        document.getElementById('fe-cron-overlay').style.display='block';
        refreshPreview();
      }

      // Public API
      window.FE_CRON = { open: openCron };

      // Remove legacy popups in DOM at runtime (if present)
      document.addEventListener('DOMContentLoaded', function(){
        ['feSchedulePopup','schedulePopup','scheduleModal'].forEach(id=>{
          const el = document.getElementById(id);
          if (el) el.remove();
        });
        // Hide timezone rows anywhere
        document.querySelectorAll('[data-field="timezone"], .timezone-row, .tz-row').forEach(el => el.style.display='none');
      });

      // Toolbar "Schedule" opens the new popup (no auto-node)
      document.addEventListener('click', function(e){
        const b = e.target && e.target.closest && e.target.closest('#addSchedule');
        if (!b) return;
        try{ e.preventDefault(); e.stopImmediatePropagation(); e.stopPropagation(); }catch(_){}
        openCron(null, null);
      }, true);

      // Double-click schedule node to edit
      document.addEventListener('DOMContentLoaded', function(){
        ensureCronModal();
        const df = document.getElementById('drawflow');
        if (!df || df.__fe_sched_dbl) return;
        df.__fe_sched_dbl = true;
        df.addEventListener('dblclick', function(e){
          const nodeEl = e.target && e.target.closest ? e.target.closest('.drawflow-node') : null;
          if(!nodeEl) return;
          const id = (nodeEl.id||'').replace('node-','');
          if(!id || !window.editor) return;
          try{
            const n = window.editor.getNodeFromId(id);
            if (!n || (n.name||'').toLowerCase()!=='schedule') return;
            const spec = (n.data && n.data.scheduleSpec) ? n.data.scheduleSpec : null;
            openCron(spec||null, parseInt(id,10));
          }catch(_){}
        });
      });

      // Insert Trigger: add or update node + sticky tile content
      document.addEventListener('click', function(e){
        const btn = e.target && e.target.closest && e.target.closest('#fe-cron-insert');
        if (!btn) return;
        try{ e.preventDefault(); e.stopImmediatePropagation(); e.stopPropagation(); }catch(_){}

        const ov = document.getElementById('fe-cron-overlay');
        function readSpecForSave(){
          const activeBtn = document.querySelector('#fe-cron-tabs .active');
          const tab = activeBtn && activeBtn.getAttribute('data-tab');
          const out = { kind: tab||'quick' };
          if (out.kind==='advanced') {
            out.kind='advanced_cron';
            out.cronText = (document.getElementById('fe-cron-raw')||{}).value || '';
            out.times = []; out.by_weekday = [];
          } else if (out.kind==='weekly') {
            out.by_weekday = Array.from(document.querySelectorAll('#fe-week-days input:checked')).map(i=>i.id.split('-').pop());
            out.times = Array.from(document.querySelectorAll('#fe-week-times input[type=time]')).map(i=>i.value).filter(Boolean);
            out.week_interval = Math.max(1, parseInt((document.getElementById('fe-week-interval')||{}).value||'1',10));
          } else if (out.kind==='monthly') {
            out.month_mode = (document.getElementById('fe-month-mode')||{}).value || 'dom';
            out.times = Array.from(document.querySelectorAll('#fe-month-times input[type=time]')).map(i=>i.value).filter(Boolean);
            out.month_interval = Math.max(1, parseInt((document.getElementById('fe-month-interval')||{}).value||'1',10));
            if (out.month_mode==='dom') out.month_days = (document.getElementById('fe-month-days')||{}).value || '';
            else { out.month_n = (document.getElementById('fe-month-n')||{}).value || '1'; out.month_wd = (document.getElementById('fe-month-wd')||{}).value || 'MO'; }
          } else {
            out.kind='quick';
            out.by_weekday = Array.from(document.querySelectorAll('#fe-cron-days input:checked')).map(i=>i.id.split('-').pop());
            out.times = Array.from(document.querySelectorAll('#fe-cron-times input[type=time]')).map(i=>i.value).filter(Boolean);
          }
          out.exclude_dates = Array.from(document.querySelectorAll('#fe-cron-exc-list .fe-chip')).map(x=>x.textContent);
          const by = (out.by_weekday && out.by_weekday.length) ? out.by_weekday : DAYS.slice();
          const times = out.times && out.times.length ? out.times : ['08:00'];
          const cronList = (out.kind==='advanced_cron') ? [out.cronText||''] : times.map(t=>buildCronFor(t, by));
          out.cronText = cronList.join(' ‚Ä¢ ');
          return out;
        }

        const spec = readSpecForSave();
        const by = (spec.by_weekday && spec.by_weekday.length) ? spec.by_weekday : DAYS.slice();
        const times = spec.times && spec.times.length ? spec.times : ['08:00'];

        const tileData = {
          cron: spec.cronText || '',
          repeatDays: by,
          time: times[0] || '',
          scheduleSpec: spec
        };

        if (ov && ov.dataset && ov.dataset.nodeId) {
          const id = parseInt(ov.dataset.nodeId,10);
          try{
            const ed = window.editor;
            const node = ed && ed.getNodeFromId ? ed.getNodeFromId(id) : null;
            if (node) {
              node.data = Object.assign({}, node.data, tileData);
              if (typeof ed.updateNodeHtmlFromId === 'function') {
                ed.updateNodeHtmlFromId(id, nodeTileHtml('schedule', node.data, id));
              }
            }
                  if (typeof ed.updateNodeDataFromId === 'function') { ed.updateNodeDataFromId(id, node.data); }
            }catch(_){}
        } else {
          try {
            const ed = window.editor;
            const vp = ed.precanvas.getBoundingClientRect();
            const x = (ed.canvas_x * -1) + vp.width/2 - 90;
            const y = (ed.canvas_y * -1) + vp.height/2 - 40;
            ed.addNode('schedule', 0, 1, x, y, 'schedule', tileData);
          } catch(_){}
        }

        try{ window.markFlowNeedsSave && window.markFlowNeedsSave(true); }catch(_){}
        document.getElementById('fe-cron-overlay').style.display='none';
      });

      // Tile rendering override (only schedule)
      (function installNodeTileHtmlOverride(){
        const orig = window.nodeTileHtml;
        function scheduleTileHtml(data){
          const daysTxt = daysSummary((data && data.scheduleSpec && data.scheduleSpec.by_weekday) || (data && data.repeatDays) || []);
          const timesArr = (data && data.scheduleSpec && data.scheduleSpec.times) || (data && data.times) || [];
          const timeTxt = (timesArr.length ? timesArr.map(fmtTime12).join(', ') : (data && data.time ? fmtTime12(data.time) : '‚Äî'));
          const cronTxt = (data && data.scheduleSpec && data.scheduleSpec.cronText) || (data && data.cron) || '';
          return `
            <div class="tile-title" style="font-weight:600;margin-bottom:4px">Schedule</div>
            <div class="tile-sub" style="font-size:12px;opacity:.9;line-height:1.35">
              <div>Days: ${daysTxt}</div>
              <div>Time: ${timeTxt}</div>
            </div>
            <div style="border-top:1px solid #3a454a;margin:8px 0"></div>
            <div class="tile-cron" style="font-family:ui-monospace,Consolas,monospace;font-size:12px;opacity:.95">${cronTxt||''}</div>
          `;
        }
        window.nodeTileHtml = function(name, data, id){
          if ((name||'').toLowerCase()==='schedule') return scheduleTileHtml(data||{});
          if (typeof orig === 'function') return orig(name, data, id);
          return `<div style="font-weight:600">${name||'Node'}</div>`;
        };
      })();

      // Back-compat: route any old callers
      window.openSchedulePopup = function(nodeId){
        openCron(null, nodeId || null);
      };
    })();
  </script>
  <!-- END_FE_CRON_ONLY -->
  <!-- === Injected: Schedule tile expanded summary === -->
  <script>
    (function(){
      // Helper: 24h "HH:MM" -> "h:MM AM/PM"
      function __fmtTime12(t){
        try {
          if (!t) return "‚Äî";
          // Already looks like 12h? Return as-is.
          if (/am|pm/i.test(t)) return t.replace(/\s+/g,' ').toUpperCase();
          const m = String(t).match(/^(\d{1,2}):(\d{2})$/);
          if (!m) return t;
          let h = parseInt(m[1], 10);
          const min = m[2];
          const ampm = h >= 12 ? 'PM' : 'AM';
          h = h % 12; if (h === 0) h = 12;
          return h + ":" + min + " " + ampm;
        } catch(_) { return t; }
      }

      // Render an expanded summary for the Schedule node
      window.scheduleTileHtml = function scheduleTileHtml(data){
        const spec = (data && data.scheduleSpec) || {};
        const kind = String(spec.kind || data.kind || 'quick').toLowerCase();

        const by = (spec.by_weekday && spec.by_weekday.length ? spec.by_weekday
                  : (Array.isArray(data.repeatDays) ? data.repeatDays : [])) || [];

        const timesArr = (Array.isArray(spec.times) && spec.times.length ? spec.times
                      : (Array.isArray(data.times) && data.times.length ? data.times
                      : (data.time ? [data.time] : [])));

        const cronTxt = spec.cronText || data.cronText || data.cron || '';

        const DNAME = {SU:"Sun", MO:"Mon", TU:"Tue", WE:"Wed", TH:"Thu", FR:"Fri", SA:"Sat"};
        const WD_FULL = {SU:"Sunday", MO:"Monday", TU:"Tuesday", WE:"Wednesday", TH:"Thursday", FR:"Friday", SA:"Saturday"};

        function commaList(arr){ return (arr||[]).filter(Boolean).join(', '); }

        function daysTxt(){
          try {
            if (typeof daysSummary === 'function') return daysSummary(by || []);
          } catch(_){}
          if (!by || !by.length) return "‚Äî";
          return by.map(d => DNAME[d] || d).join(', ');
        }

        function timesTxt(){
          if (!timesArr || !timesArr.length) return "‚Äî";
          return timesArr.map(t => (typeof fmtTime12 === 'function' ? fmtTime12(t) : __fmtTime12(t))).join(', ');
        }

        const lines = [];
        if (kind === 'advanced_cron' || kind === 'cron') {
          lines.push('<div>Mode: Advanced</div>');
        } else if (kind === 'weekly') {
          const every = Number(spec.week_interval || data.week_interval || 1);
          lines.push('<div>Mode: Weekly (every ' + every + ' week' + (every===1?'':'s') + ')</div>');
          lines.push('<div>Days: ' + daysTxt() + '</div>');
        } else if (kind === 'monthly') {
          const nMonths = Number(spec.month_interval || data.month_interval || 1);
          lines.push('<div>Mode: Monthly (every ' + nMonths + ' month' + (nMonths===1?'':'s') + ')</div>');
          const mode = (spec.month_mode || data.month_mode || 'dom'); // dom or nthweekday
          if (mode === 'dom') {
            const md = (spec.month_days != null ? spec.month_days : data.month_days);
            const mdText = (Array.isArray(md) ? md.join(', ') : (md || '')).toString().trim() || '‚Äî';
            lines.push('<div>On day(s): ' + mdText + '</div>');
          } else {
            const nth = (spec.month_n || data.month_n || '1');
            const wd  = (WD_FULL[spec.month_wd] || WD_FULL[data.month_wd]) || spec.month_wd || data.month_wd || 'Monday';
            lines.push('<div>On: ' + nth + ' ' + wd + '</div>');
          }
        } else {
          // quick (default)
          lines.push('<div>Mode: Quick</div>');
          lines.push('<div>Days: ' + daysTxt() + '</div>');
        }

        // Times shown for all non-advanced modes
        if (!(kind === 'advanced_cron' || kind === 'cron')) {
          lines.push('<div>Time' + ((timesArr && timesArr.length>1)?'s':'') + ': ' + timesTxt() + '</div>');
        }

        // Exclusions
        const ex = Array.isArray(spec.exclude_dates) ? spec.exclude_dates : (Array.isArray(data.exclude_dates) ? data.exclude_dates : []);
        if (ex.length) {
          const preview = ex.length <= 3 ? commaList(ex) : (ex.slice(0,3).join(', ') + ', +' + (ex.length-3) + ' more');
          lines.push('<div>Skip: ' + preview + '</div>');
        }

        return (
          '<div class="tile-title" style="font-weight:600;margin-bottom:4px">Schedule</div>' +
          '<div class="tile-sub" style="font-size:12px;opacity:.9;line-height:1.35">' +
            lines.join('') +
          '</div>' +
          '<div style="border-top:1px solid #ffffff;margin:8px 0;opacity:.7"></div>' +
          '<div class="tile-cron" style="font-family:ui-monospace,Consolas,monospace;font-size:12px;opacity:.95">' + (cronTxt || '') + '</div>'
        );
      };

      // Wrap nodeTileHtml to route Schedule tiles to our renderer
      function __installWrapper(){
        if (typeof window.nodeTileHtml !== 'function') return false;
        if (window.__nodeTileWrapped) return true;
        const __orig = window.nodeTileHtml;
        window.nodeTileHtml = function(type, data, nodeId){
          try {
            const t = String(type || '').toLowerCase();
            if (t === 'schedule' || t.indexOf('schedule') !== -1) {
              return window.scheduleTileHtml(data || {});
            }
          } catch(_) {}
          return __orig(type, data, nodeId);
        };
        window.__nodeTileWrapped = true;
        return true;
      }

      if (!__installWrapper()) {
        const iv = setInterval(function(){ if(__installWrapper()) clearInterval(iv); }, 50);
        setTimeout(function(){ try{ clearInterval(iv);}catch(_){}} , 4000);
      }
    })();
  </script>
  <!-- === /Injected: Schedule tile expanded summary === -->
  <script>
    // === FE: Minimap click ‚Üí center viewport using world mapping (Scroll Bars ON) ===
    (function FE_MINIMAP_CENTER_WORLD(){
      function isScrollbarMode(){
        try{
          const c=document.getElementById('drawflow'); if(!c) return false;
          const cs=getComputedStyle(c);
          return (cs.overflowX!=='hidden'||cs.overflowY!=='hidden');
        }catch(_){ return false; }
      }
      function getZoom(){
        const ed=window.editor;
        if (ed && typeof ed.zoom==='number') return ed.zoom;
        const pc = ed && (ed.precanvas || document.querySelector('.drawflow'));
        if (pc){
          const m = getComputedStyle(pc).transform;
          const a = /matrix\(([^)]+)\)/.exec(m||"");
          if (a){ const parts=a[1].split(','); const s=parseFloat(parts[0]||'1'); if (s) return s; }
        }
        return 1;
      }
      function getBoundsForMinimap(){
        // Mirror renderMinimap's logic exactly
        const df = window.editor && window.editor.drawflow && window.editor.drawflow.drawflow;
        if (!df || !df.Home || !window.getHomeDataFrom) return null;
        const data = window.getHomeDataFrom(df);
        const nodes = Object.entries(data||{});
        if (!nodes.length) return null;
        let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity;
        nodes.forEach(([id,n])=>{
          minX = Math.min(minX, n.pos_x);
          minY = Math.min(minY, n.pos_y);
          maxX = Math.max(maxX, n.pos_x + 170);
          maxY = Math.max(maxY, n.pos_y + 80);
        });
        minX -= 40; minY -= 40; maxX += 40; maxY += 40;
        return {minX, minY, maxX, maxY};
      }
      function centerAtWorld(worldX, worldY){
        const cont=document.getElementById('drawflow'); if(!cont) return;
        const z=getZoom();
        const maxX=Math.max(0, cont.scrollWidth - cont.clientWidth);
        const maxY=Math.max(0, cont.scrollHeight- cont.clientHeight);
        let targetLeft = Math.round(worldX * z - cont.clientWidth/2);
        let targetTop  = Math.round(worldY * z - cont.clientHeight/2);
        if (targetLeft<0) targetLeft=0; if (targetLeft>maxX) targetLeft=maxX;
        if (targetTop<0)  targetTop=0;  if (targetTop>maxY)  targetTop=maxY;
        cont.scrollLeft = targetLeft;
        cont.scrollTop  = targetTop;
        try{ if (typeof window.__fe_syncPanFromScroll==='function') window.__fe_syncPanFromScroll(); }catch(_){}
        try{ if (window.editor && typeof window.editor.updateConnectionNodesAll==='function') window.editor.updateConnectionNodesAll(); }catch(_){}
        try{ if (typeof window.renderMinimap==='function') window.renderMinimap(); }catch(_){}
      }

      window.addEventListener('DOMContentLoaded', function(){
        const mmOld=document.getElementById('minimap-canvas'); if(!mmOld) return;
        // Replace to clear prior handlers that may use translate-pan
        const p=mmOld.parentNode, mm=mmOld.cloneNode(true); p.replaceChild(mm, mmOld);

        mm.addEventListener('click', function(ev){
          if (!isScrollbarMode()) return; // leave legacy behavior when scrollbars off
          ev.preventDefault(); ev.stopPropagation(); ev.stopImmediatePropagation?.();

          const bounds = getBoundsForMinimap(); if(!bounds) return;
          const W = mm.width || 240, H = mm.height || 140;
          const rect = mm.getBoundingClientRect();
          const xCanvas = (ev.clientX - rect.left) * (mm.width ? (mm.width/rect.width) : 1);
          const yCanvas = (ev.clientY - rect.top)  * (mm.height? (mm.height/rect.height): 1);

          const worldW = Math.max(1, bounds.maxX - bounds.minX);
          const worldH = Math.max(1, bounds.maxY - bounds.minY);
          const scaleX = W / worldW;
          const scaleY = H / worldH;
          const scale  = Math.min(scaleX, scaleY);

          // renderMinimap anchors at top-left (no centering offsets), so world = min + canvas/scale
          let worldX = bounds.minX + xCanvas / scale;
          let worldY = bounds.minY + yCanvas / scale;

          // Clamp inside world bounds
          if (worldX < bounds.minX) worldX = bounds.minX;
          if (worldY < bounds.minY) worldY = bounds.minY;
          if (worldX > bounds.maxX) worldX = bounds.maxX;
          if (worldY > bounds.maxY) worldY = bounds.maxY;

          centerAtWorld(worldX, worldY);
        }, true); // capture=true
      });
    })();
  </script>
  <script>
    (function(){
      function bindToggle(hId, cId, aId){
        var h=document.getElementById(hId), c=document.getElementById(cId), a=document.getElementById(aId);
        if (a) a.style.transform = (c && c.style.display === 'none') ? 'rotate(-90deg)' : 'rotate(0deg)';
        if(!h||!c) return;
        h.addEventListener('click', function(){
          var open = (c.style.display==='none');
          c.style.display = open ? 'block' : 'none';
          if(a) a.style.transform = open ? 'rotate(0deg)' : 'rotate(-90deg)';
        });
      }
      bindToggle('variableDeleteHeader','variableDeleteContent','variableDeleteArrow');
      try{
        if (window.flowVars && typeof window.flowVars.renderDeleteSection === 'function') {
          window.flowVars.renderDeleteSection(document.getElementById('variableDeleteContent'));
        }
      }catch(e){ console.warn('renderDeleteSection failed', e); }
    })();
  </script>
  <script>
    (function(){
      function bindToggle(hId, cId, aId){
        var h=document.getElementById(hId), c=document.getElementById(cId), a=document.getElementById(aId);
        if (a) a.style.transform = (c && c.style.display === 'none') ? 'rotate(-90deg)' : 'rotate(0deg)';
        if(!h||!c) return;
        h.addEventListener('click', function(){
          var open = (c.style.display==='none');
          c.style.display = open ? 'block' : 'none';
          if(a) a.style.transform = open ? 'rotate(0deg)' : 'rotate(-90deg)';
        });
      }
      bindToggle('variableEditHeader','variableEditContent','variableEditArrow');
      try{
        if (window.flowVars && typeof window.flowVars.renderEditSection === 'function') {
          window.flowVars.renderEditSection(document.getElementById('variableEditContent'));
        }
      }catch(e){ console.warn('renderEditSection failed', e); }

      // Also refresh the dropdown when vars refresh
      try{
        if (typeof refreshVarsAndInspector === 'function' && !refreshVarsAndInspector.__patchedForEdit) {
          const _rv = refreshVarsAndInspector;
          window.refreshVarsAndInspector = async function() {
            const r = await _rv.apply(this, arguments);
            try { if (typeof window.updateEditVarDropdown === 'function') window.updateEditVarDropdown(); } catch(_) {}
            return r;
          }
          window.refreshVarsAndInspector.__patchedForEdit = true;
        }
      }catch(_){}
    })();
  </script>

<!-- Selection Guardian v2: authoritative paint from _multiSelectedNodes -->
<script>
(function(){
  if (window.__feSelGuardianV2) return; window.__feSelGuardianV2 = true;
  function norm(v){ return (v==null)? null : String(v).replace(/^node-/, ''); }
  function paint(){
    var has = (window._multiSelectedNodes && window._multiSelectedNodes.has.bind(window._multiSelectedNodes)) || function(){return false;};
    document.querySelectorAll('#drawflow .drawflow-node').forEach(function(node){
      var raw = node.id || '';
      var n = norm(raw);
      if (has(n) || has(raw)) node.classList.add('multi-selected'); else node.classList.remove('multi-selected');
    });
  }
  // Burst repaint near interactions & DOM mutations
  var raf=0, n=0;
  function burst(){
    if (raf) return;
    n=10;
    (function tick(){
      paint();
      if (--n>0) raf=requestAnimationFrame(tick); else raf=0;
    })();
  }
  ['mousedown','mouseup','click','keydown','input'].forEach(function(t){
    document.addEventListener(t, burst, true);
  });
  var root = document.getElementById('drawflow');
  if (root){
    var mo = new MutationObserver(burst);
    mo.observe(root, {childList:true, subtree:true, attributes:true, attributeFilter:['class','style']});
  }
  // First paint
  paint();
})();
</script>

<!-- FE CLEAN DnD v7 (body overlay, group-drag, normalized selection) -->
<style id="fe-clean-dnd-style-v7">
  #__feDndOverlay{position:fixed; z-index:99999; pointer-events:auto; background:transparent;}
</style>
<script>
(function(){
  if (window.__feCleanDndV7) return; window.__feCleanDndV7 = true;
  const root = document.getElementById('drawflow');
  if (!root) return;

  // Ensure normalized selection facade exists
  (function(){
    if (!window._multiSelectedNodes || !window._multiSelectedNodes.__patched){
      function norm(v){ return (v==null)? null : String(v).replace(/^node-/, ''); }
      const inner = new Set();
      window._multiSelectedNodes = {
        __patched: true,
        _inner: inner,
        add: function(v){ inner.add(norm(v)); return this; },
        delete: function(v){ return inner.delete(norm(v)); },
        has: function(v){ return inner.has(norm(v)); },
        clear: function(){ inner.clear(); },
        forEach: function(cb, thisArg){ inner.forEach(function(v){ cb.call(thisArg, v); }); },
        get size(){ return inner.size; },
        [Symbol.iterator]: function(){ return inner[Symbol.iterator](); }
      };
    }
  })();

  // Make overlay
  let overlay = document.getElementById('__feDndOverlay');
  if (!overlay){ overlay = document.createElement('div'); overlay.id='__feDndOverlay'; document.body.appendChild(overlay); }

  function placeOverlay(){
    const r = root.getBoundingClientRect();
    overlay.style.left = r.left + 'px';
    overlay.style.top  = r.top + 'px';
    overlay.style.width  = r.width + 'px';
    overlay.style.height = r.height + 'px';
  }
  placeOverlay();
  window.addEventListener('resize', placeOverlay);
  window.addEventListener('scroll', placeOverlay, true);
  const ro = new ResizeObserver(placeOverlay); try{ ro.observe(root); }catch(_){}

  function elAt(e){
    overlay.style.pointerEvents = 'none';
    const el = document.elementFromPoint(e.clientX, e.clientY);
    overlay.style.pointerEvents = 'auto';
    return el;
  }
  function nodeEl(el){ return el && el.closest ? el.closest('.drawflow-node') : null; }
  function nodeIdFromEl(el){ if (!el) return null; const raw=el.id||''; return String(raw).replace(/^node-/, ''); }
  function isPort(el){ return !!(el && el.closest && (el.closest('.point') || el.closest('.output, .input'))); }
  function isInteractive(el){ return !!(el && el.closest && el.closest('input,textarea,select,button,[contenteditable="true"]')); }
  function isBg(el){
    if (!el) return false;
    if (el === root) return true;
    return !!(el.classList && (el.classList.contains('precanvas') || el.classList.contains('drawflow')));
  }

  function getPos(id){
    try{
      if (window.editor && typeof window.editor.getNodeFromId === 'function'){
        const n = window.editor.getNodeFromId(id);
        return {x:Number(n?.pos_x||0), y:Number(n?.pos_y||0)};
      }
    }catch(_){}
    const el = document.getElementById('node-'+id);
    return {x:Number((el && parseFloat(el.style.left))||0), y:Number((el && parseFloat(el.style.top))||0)};
  }
  function moveTo(id,x,y){
    try{
      if (window.editor && typeof window.editor.moveNodeTo === 'function'){
        window.editor.moveNodeTo(Number(id), x, y);
        return;
      }
    }catch(_){}
    const el = document.getElementById('node-'+id);
    if (el){ el.style.left = x+'px'; el.style.top = y+'px'; }
  }

  function paintSel(){
    if (typeof updateNodeSelectionUI === 'function') { try{ updateNodeSelectionUI(); }catch(_){ } }
  }

  // DnD state
  let drag = null; // {ids:Set, origins:Map, sx, sy, moved}
  const CLICK_TOL = 4;
  let bgDown = null, bgDragging = false;

  // Prevent upstream capture listeners from acting on overlay-targeted events
  function swallow(e){ if (e.target === overlay){ try{ e.stopImmediatePropagation(); }catch(_){ } } }
overlay.addEventListener('mousedown', function(e){
    if (e.button !== 0) return;
    const under = elAt(e);
    if (!under) return;

    // Let inputs inside nodes work normally
    if (isInteractive(under)){
      // temporarily let this click through
      overlay.style.pointerEvents = 'none';
      setTimeout(()=>{ overlay.style.pointerEvents = 'auto'; }, 0);
      return;
    }

    
// üîß Allow Drawflow to start a connection when clicking on a port
const __portEl = (under && under.closest) ? under.closest('.input, .output') : null;
    if (__portEl) {
  // Let this entire drag pass through to the real canvas
  overlay.style.pointerEvents = 'none';
  const restore = function(){
    overlay.style.pointerEvents = 'auto';
    document.removeEventListener('mouseup', restore, true);
  };
  document.addEventListener('mouseup', restore, true);
  try {
    // Re-dispatch the original mousedown so Drawflow can begin the link
    __portEl.dispatchEvent(new MouseEvent('mousedown', {
      bubbles: true, cancelable: true, view: window,
      clientX: e.clientX, clientY: e.clientY, button: e.button || 0
    }));
  } catch (_){}
  return;
}

const nEl = nodeEl(under);
    const meta = e.ctrlKey || e.metaKey;

    if (nEl && !isPort(under)){
      const id = nodeIdFromEl(nEl);
      // Toggle or set selection
      if (meta){
        if (window._multiSelectedNodes.has(id)) window._multiSelectedNodes.delete(id);
        else window._multiSelectedNodes.add(id);
      } else if (!window._multiSelectedNodes.has(id) || window._multiSelectedNodes.size>1){
        window._multiSelectedNodes.clear();
        window._multiSelectedNodes.add(id);
      }
      paintSel();
                try {
                  window.__feSelectedId = id;
                  if (window.editor) {
                    window.editor.selected_id = String(id);
                    if (typeof window.renderEditor === 'function' && typeof window.editor.getNodeFromId === 'function') {
                      const nd = window.editor.getNodeFromId(id);
                      if (nd) window.renderEditor(nd);
                    }
                  }
                } catch(_) {}
                // Start group drag for the selection set
      const ids = new Set(); window._multiSelectedNodes.forEach(v => ids.add(String(v)));
      const origins = new Map();
      ids.forEach(nid => { const p = getPos(nid); origins.set(nid, p); });
      drag = { ids, origins, sx:e.clientX, sy:e.clientY, moved:false };
      e.preventDefault();
      return;
    }

    if (isBg(under)){
      bgDown = {x:e.clientX, y:e.clientY};
      bgDragging = false;
      return;
    }
  }, true);

  overlay.addEventListener('mousemove', function(e){
    if (!drag){
      if (bgDown){
        if (Math.abs(e.clientX - bgDown.x)>CLICK_TOL || Math.abs(e.clientY - bgDown.y)>CLICK_TOL) bgDragging = true;
      }
      return;
    }
    const dx = e.clientX - drag.sx;
    const dy = e.clientY - drag.sy;
    if (dx || dy) drag.moved = true;
    drag.ids.forEach(function(nid){
      const orig = drag.origins.get(nid) || {x:0,y:0};
      moveTo(nid, orig.x + dx, orig.y + dy);
    });
    e.preventDefault();
  }, true);

  overlay.addEventListener('mouseup', function(e){
    if (drag){
      if (drag.moved && typeof window.markFlowNeedsSave === 'function'){ try{ window.markFlowNeedsSave(true); }catch(_){ } }
      drag = null;
      e.preventDefault();
      return;
    }
  }, true);

  overlay.addEventListener('click', function(e){
    const under = elAt(e);
    if (!under) return;
    if (nodeEl(under) && !isPort(under)){
      // nothing: selection already handled on mousedown
      e.preventDefault();
      return;
    }
    if (isBg(under) && bgDown && !bgDragging){
       try{ window.__feSelectionAllowClear && window.__feSelectionAllowClear(240); }catch(_){} // true background click: clear selection
      if (window._multiSelectedNodes) window._multiSelectedNodes.clear();
      paintSel();
      e.preventDefault();
      return;
    }
  }, true);

  // Keep overlay selection painted through DOM churn
  const mo = new MutationObserver(paintSel);
  mo.observe(root, {childList:true, subtree:true});
  paintSel();

// Forward right-click/contextmenu to underlying element
overlay.addEventListener('contextmenu', function(e){
  const under = elAt(e);
  if (!under) return;
  try {
    const evt = new MouseEvent('contextmenu', {
      bubbles: true, cancelable: true, view: window,
      clientX: e.clientX, clientY: e.clientY, button: 2
    });
    under.dispatchEvent(evt);
    e.preventDefault();
    e.stopImmediatePropagation();
  } catch(_) {}
}, true);


// Forward double-click to underlying element
overlay.addEventListener('dblclick', function(e){
  const under = elAt(e);
  if (!under) return;
  try {
    const evt = new MouseEvent('dblclick', {
      bubbles: true, cancelable: true, view: window,
      clientX: e.clientX, clientY: e.clientY, button: e.button || 0
    });
    under.dispatchEvent(evt);
    e.preventDefault();
    e.stopImmediatePropagation();
  } catch(_) {}
}, true);

})();
</script>

<!-- FE Selection Protector v1: prevent unsolicited clears and normalize IDs -->
<script>
(function(){
  if (window.__feSelProtectorV1) return; window.__feSelProtectorV1 = true;
  const state = { inner: new Set(), allowClearUntil: 0 };
  function now(){ try { return performance.now(); } catch(_){ return Date.now(); } }
  function norm(v){ return (v==null)? null : String(v).replace(/^node-/, ''); }
  const api = {
    __patched: true,
    add: function(v){ state.inner.add(norm(v)); return this; },
    delete: function(v){ return state.inner.delete(norm(v)); },
    has: function(v){ return state.inner.has(norm(v)); },
    clear: function(){ if (now() <= state.allowClearUntil) { state.inner.clear(); } return this; },
    forEach: function(cb, thisArg){ state.inner.forEach(function(v){ cb.call(thisArg, v); }); },
    get size(){ return state.inner.size; },
    [Symbol.iterator]: function(){ return state.inner[Symbol.iterator](); }
  };
  Object.defineProperty(window, '_multiSelectedNodes', {
    configurable: true,
    get: function(){ return api; },
    set: function(val){
      try {
        const next = [];
        if (val && typeof val.forEach === 'function') { val.forEach(function(v){ next.push(norm(v)); }); }
        const wantClear = next.length === 0 && state.inner.size > 0;
        if (wantClear && now() > state.allowClearUntil) {
          // Ignore unsolicited clears
          return;
        }
        state.inner.clear();
        next.forEach(function(v){ state.inner.add(v); });
      } catch(_){}
    }
  });
  window.__feSelectionAllowClear = function(ms){ state.allowClearUntil = now() + (ms||160); };
  window.__feSelectionGet = function(){ return Array.from(state.inner); };
})();
</script>

<!-- FE Selection Heartbeat v1: re-assert selection & editor panel -->
<script>
(function(){
  if (window.__feSelHeartbeatV1) return; window.__feSelHeartbeatV1 = true;
  function paint(){
    try {
      if (typeof updateNodeSelectionUI === 'function') updateNodeSelectionUI();
      var ids = (window.__feSelectionGet && window.__feSelectionGet()) || [];
      if (ids && ids.length && window.editor) {
        var cur = String(window.editor.selected_id || '');
        var want = String(ids[0]);
        if (!cur || cur !== want) {
          window.editor.selected_id = want;
          if (typeof window.renderEditor === 'function' && typeof window.editor.getNodeFromId === 'function') {
            var nd = window.editor.getNodeFromId(want);
            if (nd) window.renderEditor(nd);
          }
        }
      }
    } catch(_){}
  }
  setInterval(paint, 900);
})();
</script>

<!-- FE ctx-menu passthrough patch -->
<script>
(function(){
  if (window.__feCtxMenuPassThrough) return; window.__feCtxMenuPassThrough = true;

  function $(id){ return document.getElementById(id); }
  function overlay(){ return $("__feDndOverlay"); }
  function menuEl(){
    return document.getElementById("df-ctx-menu") || document.getElementById("df-multi-menu");
  }
  function setOverlayPassThrough(pass){
    const ov = overlay();
    if (ov) ov.style.pointerEvents = pass ? "none" : "auto";
  }
  function closeMenus(){
    const a = $("df-ctx-menu"); if (a) a.remove();
    const b = $("df-multi-menu"); if (b) b.remove();
  }

  // When any context menu opens, temporarily disable overlay hit-testing,
  // so clicks land on the menu items (not the overlay).
  document.addEventListener("contextmenu", function(){
    setTimeout(function(){
      if (menuEl()) setOverlayPassThrough(true);
    }, 0);
  }, true);

  // Click anywhere outside an open menu closes it and restores overlay.
  document.addEventListener("click", function(e){
    const m = menuEl();
    if (!m){ setOverlayPassThrough(false)
      return;
    }
    if (!m.contains(e.target)){
      closeMenus();
      setOverlayPassThrough(false);
    }
  }, true);

  // Esc also closes
  document.addEventListener("keydown", function(e){
    if (e.key === "Escape"){
      closeMenus();
      setOverlayPassThrough(false);
    }
  }, true);

  // Safety net: if the menu disappears due to other code, restore overlay.
  const mo = new MutationObserver(function(){
    if (!menuEl()) setOverlayPassThrough(false);
  });
  try{ mo.observe(document.body, {childList:true, subtree:true}); }catch(_){}
})();
</script>

<!-- FE: Auto-hide Node Editor when nothing is selected -->
<script>
(function(){
  if (window.__feNodeEditorAutoHide) return;
  window.__feNodeEditorAutoHide = true;

  function panel(){ return document.getElementById('nodeEditorPanel'); }
  function drawflowEl(){ return document.getElementById('drawflow'); }

  function hasSelection(){
    // treat either single- or multi-select as "selected"
    return !!document.querySelector('.drawflow-node.selected, .drawflow-node.multi-selected');
  }

  function setPanelVisible(v){
    const p = panel();
    if (!p) return;
    p.style.display = v ? 'block' : 'none';
  }

  function update(){
    setPanelVisible(hasSelection());
  }

  // Initial state on load
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', update, {once:true});
  } else {
    update();
  }

  // Observe selection class changes and node add/removals
  const df = drawflowEl();
  if (df && window.MutationObserver){
    const mo = new MutationObserver(function(muts){
      for (const m of muts){
        if (m.type === 'attributes' && m.attributeName === 'class') { update(); return; }
        if (m.type === 'childList') { update(); return; }
      }
    });
    try{ mo.observe(df, {subtree:true, attributes:true, attributeFilter:['class'], childList:true}); }catch(_){}
  }

  // Also react to generic clicks and key events that tend to change selection
  document.addEventListener('click', update, true);
  document.addEventListener('keydown', function(e){
    if (e.key === 'Escape') setTimeout(update, 0);
  }, true);

  // If your editor exposes events, hook them conservatively (won't throw if absent)
  function hookEditorBus(){
    try {
      if (window.editor && typeof window.editor.on === 'function'){
        if (!window.editor.__nodeEditorHideHooked){
          window.editor.on('nodeSelected', function(){ update(); });
          window.editor.on('nodeUnselected', function(){ update(); });
          window.editor.__nodeEditorHideHooked = true;
        }
      }
    } catch(_){}
  }
  hookEditorBus();
  // Try again once later in case editor loads after
  setTimeout(hookEditorBus, 800);
})();
</script>
<script>
// --- FE patch: ensure you can start a new connection by dragging from the small circle ('.point') ---
(function(){
  try{
    var overlay = document.getElementById('__feDndOverlay');
    if (!overlay) return;
    overlay.addEventListener('mousedown', function(e){
      if (e.button !== 0) return;
      // If the original handler already handled it, nothing to do.
      // We only ensure that the event is re-fired on the most specific element ('.point' > '.input/.output').
      // Calculate the element under the mouse
      overlay.style.pointerEvents = 'none';
      var under = document.elementFromPoint(e.clientX, e.clientY);
      overlay.style.pointerEvents = 'auto';
      if (!under) return;
      var port = (under.closest && (under.closest('.point') || under.closest('.input, .output'))) || null;
      if (!port) return;
      // Pass through the drag fully
      overlay.style.pointerEvents = 'none';
      const restore = function(){
        overlay.style.pointerEvents = 'auto';
        document.removeEventListener('mouseup', restore, true);
      };
      document.addEventListener('mouseup', restore, true);
      try {
        port.dispatchEvent(new MouseEvent('mousedown', {
          bubbles: true, cancelable: true, view: window,
          clientX: e.clientX, clientY: e.clientY, button: e.button || 0
        }));
      } catch(_){}
    }, true);
  }catch(_){}
})();
</script>

<script>
(function(){
  try{
    var overlay = document.getElementById('__feDndOverlay');
    if (!overlay) return;
    // If Drawflow marks a connection drag (adds 'connecting' class) on the canvas, auto-disable overlay
    document.addEventListener('mousemove', function(){
      try{
        var df = document.querySelector('#drawflow');
        if (!df) return;
        var connecting = !!document.querySelector('.drawflow .connecting, .main-path'); // rough check
        if (connecting && overlay.style.pointerEvents !== 'none'){
          overlay.style.pointerEvents = 'none';
        }
      }catch(_){}
    }, true);
    document.addEventListener('mouseup', function(){
      if (overlay.style.pointerEvents === 'none'){
        overlay.style.pointerEvents = 'auto';
      }
    }, true);
  }catch(_){}
})();
</script>


<!-- FE patch: dirty-suppression shim + robust LastTrace loader -->
<script>
// --- beginDirtySuppression shim (safe if already defined) ---
if (typeof window.beginDirtySuppression !== 'function') {
  window.beginDirtySuppression = function(ms = 1500, reason = '') {
    try {
      var dur = Number(ms) || 0;
      window.__suppressDirtyUntil = Date.now() + dur;
      if (document.body && document.body.classList) {
        document.body.classList.add('is-saving');
        setTimeout(function(){ try { document.body.classList.remove('is-saving'); } catch(_) {} }, dur + 250);
      }
    } catch(_) {}
  };
}

// --- Helper: load LastTrace from either FE_lastTrace.json (new) or FE_lasttrace.json (legacy) ---
async function __fe_fetchLastTraceFlexible() {
  const urls = [
    `/local/FE_lastTrace.json?ts=${Date.now()}`,
    `/local/FE_lasttrace.json?ts=${Date.now()}`
  ];
  let lastErr = null;
  for (const u of urls) {
    try {
      const r = await fetch(u, { cache: 'no-store' });
      const t = await r.text();
      return JSON.parse(t);
    } catch (e) {
      lastErr = e;
    }
  }
  throw lastErr || new Error('No Last Trace file found');
}

// --- Replacement __fe_handleLastTraceFile (overrides any earlier version) ---
async function __fe_handleLastTraceFile(){
  // 1) Clear previous highlights
  document.querySelectorAll('.drawflow-node.executed, .drawflow-node.last-executed, .drawflow-node.flow-path')
    .forEach(n => n.classList.remove('executed','last-executed','flow-path'));
  document.querySelectorAll('.main-path.highlighted, .main-path.live-highlight')
    .forEach(p => { p.removeAttribute('stroke'); p.removeAttribute('style'); p.classList.remove('highlighted','live-highlight'); });

  // 2) Determine the active flow filename shown in the UI
  const nameEl = document.getElementById('flowName');
  const raw = (nameEl ? nameEl.textContent : (window.currentFlowFile || '')).trim();
  if (!raw) { (window.logAction||console.log)('No flow loaded.'); return; }
  const want = raw.toLowerCase().endsWith('.json') ? raw.toLowerCase() : (raw.toLowerCase() + '.json');

  // 3) Read the Last Trace file (try both legacy and new names)
  let resp;
  try {
    resp = await __fe_fetchLastTraceFlexible();
  } catch (e) {
    (window.logAction||console.error)('Failed to read FE_lastTrace/FE_lasttrace: ' + (e && e.message ? e.message : e));
    return;
  }

  // 4) Normalize ‚Üí array of runs, then filter for this flow
  const list = Array.isArray(resp) ? resp : (resp && Array.isArray(resp.flows) ? resp.flows : []);
  if (!list.length) { (window.logAction||console.log)('No previous runs recorded.'); return; }

  const runs = list.filter(r => String(r.flowFile || '').toLowerCase() === want);
  if (!runs.length) { (window.logAction||console.log)('No previous runs for this flow.'); return; }

  // 5) Sort newest first and prefer a completed run
  runs.sort((a,b) => {
    const ta = (a.steps && a.steps.length) ? (a.steps[a.steps.length - 1].ts || 0) : (a.started || 0);
    const tb = (b.steps && b.steps.length) ? (b.steps[b.steps.length - 1].ts || 0) : (b.started || 0);
    return tb - ta;
  });
  const isEndish = (s) => {
    const t = String(s?.nodeType || s?.step || '').toLowerCase();
    return t === 'endofflow' || t === 'cancelled' || t === 'end';
  };
  const completed = runs.find(r => r.finished || isEndish((r.steps||[])[(r.steps||[]).length-1])) || runs[0];

  // 6) Extract node steps and paint them
  const realSteps = (completed.steps || []).filter(s => s && s.nodeId);
  if (!realSteps.length) { (window.logAction||console.log)('Trace had no node steps.'); return; }

  // Nodes
  realSteps.forEach((step, idx) => {
    const el = document.getElementById(`node-${step.nodeId}`);
    if (el) {
      el.classList.add('executed');
      if (idx === realSteps.length - 1) el.classList.add('last-executed');
    }
  });

  // Edges
  for (let i = 0; i < realSteps.length - 1; i++) {
    const from = realSteps[i].nodeId, to = realSteps[i+1].nodeId;
    const sel = `.connection.node_out_node-${from}.node_in_node-${to} .main-path`;
    const path = document.querySelector(sel) ||
                 document.querySelector(`.connection[data-from="${from}"][data-to="${to}"] .main-path`);
    if (path) {
      path.setAttribute('stroke','limegreen');
      path.setAttribute('style','stroke: limegreen !important; stroke-width: 8px !important; filter: drop-shadow(0 0 6px #0f0) !important;');
      path.classList.add('highlighted');
    }
  }

  // 7) Update ‚ÄúLast Run‚Äù label
  const lastTs = (realSteps[realSteps.length - 1]?.ts) || completed.started || null;
  if (lastTs) {
    const d = new Date(lastTs);
    const el = document.getElementById('lastRunLine');
    if (el) el.textContent =
      `Last Run: ${d.toLocaleDateString(undefined,{year:'numeric',month:'short',day:'numeric'})} - ${d.toLocaleTimeString(undefined,{hour:'2-digit',minute:'2-digit',second:'2-digit'})}`;
  }

  (window.logAction||console.log)('Last Trace (FE_lasttrace.json) loaded.');
}

// Ensure button triggers the new handler even if injected later
(function(){
  const __btn=document.getElementById('lastTraceBtn');
  if(__btn) __btn.addEventListener('click', __fe_handleLastTraceFile);
  document.addEventListener('click', function(e){
    const t = e.target && (e.target.id === 'lastTraceBtn' || (e.target.closest && e.target.closest('#lastTraceBtn')));
    if(t) { e.preventDefault(); __fe_handleLastTraceFile(); }
  }, true);
})();
</script>


<!-- FE patch v3: LastTrace uses only FE_lasttrace.json -->
<script>
window.__fe_handleLastTraceFile = async function(){
  try {
    // Clear highlights
    document.querySelectorAll('.drawflow-node.executed, .drawflow-node.last-executed, .drawflow-node.flow-path')
      .forEach(n => n.classList.remove('executed','last-executed','flow-path'));
    document.querySelectorAll('.main-path.highlighted, .main-path.live-highlight')
      .forEach(p => { p.removeAttribute('stroke'); p.removeAttribute('style'); p.classList.remove('highlighted','live-highlight'); });

    const nameEl = document.getElementById('flowName');
    const raw = (nameEl ? nameEl.textContent : (window.currentFlowFile || '')).trim();
    if (!raw) { (window.logAction||console.log)('No flow loaded.'); return; }
    const want = raw.toLowerCase().endsWith('.json') ? raw.toLowerCase() : (raw.toLowerCase() + '.json');

    // Always read FE_lasttrace.json
    let resp;
    try {
      const r = await fetch(`/local/FE_lasttrace.json?ts=${Date.now()}`, { cache: 'no-store' });
      if (!r.ok) { (window.logAction||console.error)(`HTTP ${r.status} loading FE_lasttrace.json`); return; }
      const txt = await r.text();
      resp = JSON.parse(txt);
    } catch (e) {
      (window.logAction||console.error)('Failed to read FE_lasttrace.json: ' + (e && e.message ? e.message : e));
      return;
    }

    const list = Array.isArray(resp) ? resp : (resp && Array.isArray(resp.flows) ? resp.flows : []);
    if (!list.length) { (window.logAction||console.log)('No runs recorded in FE_lasttrace.json.'); return; }

    const runs = list.filter(r => String(r.flowFile || '').toLowerCase() === want);
    if (!runs.length) { (window.logAction||console.log)(`No runs for "${want}".`); return; }

    runs.sort((a,b) => {
      const ta = (a.steps && a.steps.length) ? (a.steps[a.steps.length - 1].ts || 0) : (a.started || 0);
      const tb = (b.steps && b.steps.length) ? (b.steps[b.steps.length - 1].ts || 0) : (b.started || 0);
      return tb - ta;
    });

    const completed = runs[0];
    const realSteps = (completed.steps || []).filter(s => s && s.nodeId);
    if (!realSteps.length) { (window.logAction||console.log)('Trace had no node steps.'); return; }

    realSteps.forEach((step, idx) => {
      const el = document.getElementById(`node-${step.nodeId}`);
      if (el) {
        el.classList.add('executed');
        if (idx === realSteps.length - 1) el.classList.add('last-executed');
      }
    });

    for (let i = 0; i < realSteps.length - 1; i++) {
      const from = realSteps[i].nodeId, to = realSteps[i+1].nodeId;
      const sel = `.connection.node_out_node-${from}.node_in_node-${to} .main-path`;
      const path = document.querySelector(sel) ||
                   document.querySelector(`.connection[data-from="${from}"][data-to="${to}"] .main-path`);
      if (path) {
        path.setAttribute('stroke','limegreen');
        path.setAttribute('style','stroke: limegreen !important; stroke-width: 8px !important; filter: drop-shadow(0 0 6px #0f0) !important;');
        path.classList.add('highlighted');
      }
    }

    const lastTs = (realSteps[realSteps.length - 1]?.ts) || completed.started || null;
    if (lastTs) {
      const d = new Date(lastTs);
      const el = document.getElementById('lastRunLine');
      if (el) el.textContent =
        `Last Run: ${d.toLocaleDateString(undefined,{year:'numeric',month:'short',day:'numeric'})} - ${d.toLocaleTimeString(undefined,{hour:'2-digit',minute:'2-digit',second:'2-digit'})}`;
    }

    (window.logAction||console.log)('Last Trace (FE_lasttrace.json) loaded from FE_lasttrace.json.');
  } catch (err) {
    (window.logAction||console.error)('Last Trace render error: ' + (err?.message || err));
  }
};

(function(){
  const __btn=document.getElementById('lastTraceBtn');
  if(__btn && !__btn.__lt_hooked) { __btn.__lt_hooked = true; __btn.addEventListener('click', window.__fe_handleLastTraceFile); }
  document.addEventListener('click', function(e){
    const t = e.target && (e.target.id === 'lastTraceBtn' || (e.target.closest && e.target.closest('#lastTraceBtn')));
    if(t) { e.preventDefault(); window.__fe_handleLastTraceFile(); }
  }, true);
})();
</script>

<script>
    document.addEventListener("DOMContentLoaded", () => {
    const hamburger = document.getElementById("feHamburger");
    const menu = document.getElementById("feMenu");

    // Toggle main menu
    hamburger.addEventListener("click", (e) => {
        e.stopPropagation();
        const isOpen = menu.style.display === "block";
        menu.style.display = isOpen ? "none" : "block";
        hamburger.setAttribute("aria-expanded", !isOpen);
    });

    // Close menu if clicking outside
    document.addEventListener("click", (e) => {
        if (!menu.contains(e.target) && e.target !== hamburger) {
        menu.style.display = "none";
        hamburger.setAttribute("aria-expanded", "false");
        }
    });

    // Submenu toggles
    const submenus = [
        { trigger: "feMenu-display", submenu: "feMenuDisplay" },
        { trigger: "feMenu-align", submenu: "feMenuAlign" },
        { trigger: "feMenu-mainnodes", submenu: "feMenuMainNodes" },
        { trigger: "feMenu-othernodes", submenu: "feMenuOtherNodes" },
        { trigger: "feMenu-specialnodes", submenu: "feMenuSpecialNodes" }
    ];

    submenus.forEach(({ trigger, submenu }) => {
        const btn = document.getElementById(trigger);
        const panel = document.getElementById(submenu);

        btn.addEventListener("mouseenter", () => {
        panel.style.display = "block";
        panel.classList.add("fe-open");
        });

        btn.addEventListener("mouseleave", () => {
        setTimeout(() => {
            if (!panel.matches(":hover")) {
            panel.style.display = "none";
            panel.classList.remove("fe-open");
            }
        }, 150);
        });

        panel.addEventListener("mouseleave", () => {
        panel.style.display = "none";
        panel.classList.remove("fe-open");
        });
    });
    });
    
// Sync header inputs and menu inputs
const tokenHeader = document.getElementById("hubitatToken");
const appIdHeader = document.getElementById("hubitatAppId");
const tokenMenu = document.getElementById("hubitatTokenMenu");
const appIdMenu = document.getElementById("hubitatAppIdMenu");

function syncInputs(src, dest) {
  if (dest && src) dest.value = src.value;
}

if (tokenHeader && tokenMenu) {
  tokenHeader.addEventListener("input", () => syncInputs(tokenHeader, tokenMenu));
  tokenMenu.addEventListener("input", () => syncInputs(tokenMenu, tokenHeader));
}
if (appIdHeader && appIdMenu) {
  appIdHeader.addEventListener("input", () => syncInputs(appIdHeader, appIdMenu));
  appIdMenu.addEventListener("input", () => syncInputs(appIdMenu, appIdHeader));
}

</script>

<!-- FE Hamburger: single, conflict-free controller -->
<script>
(function () {
  if (window.__feHamburgerInstalled) return;
  window.__feHamburgerInstalled = true;

  function byId(id){ return document.getElementById(id); }

  // Wait until DOM is really ready
  const boot = () => {
    const hamburger = byId("feHamburger");
    const menu = byId("feMenu");
    if (!hamburger || !menu) return;

    const map = [
      ["feMenu-display","feMenuDisplay"],
      ["feMenu-align","feMenuAlign"],
      ["feMenu-mainnodes","feMenuMainNodes"],
      ["feMenu-othernodes","feMenuOtherNodes"],
      ["feMenu-specialnodes","feMenuSpecialNodes"],
    ].map(([t,p]) => ({ t: byId(t), p: byId(p), id:p && p.id }))
     .filter(x => x.t && x.p);

    function openMenu(){
      menu.style.display = "block";
      hamburger.setAttribute("aria-expanded","true");
    }
    function closeMenu(){
      menu.style.display = "none";
      hamburger.setAttribute("aria-expanded","false");
      map.forEach(x => { x.p.style.display="none"; x.p.classList.remove("fe-open"); });
    }

    // Main toggle
    hamburger.addEventListener("click", function(ev){
      try{ ev.preventDefault(); ev.stopPropagation(); ev.stopImmediatePropagation(); }catch(_){}
      const isOpen = menu.style.display === "block";
      isOpen ? closeMenu() : openMenu();
    }, { capture:true });

    // Outside click (capture to beat other handlers)
    document.addEventListener("click", function(ev){
      if (menu.style.display !== "block") return;
      const t = ev.target;
      if (t === hamburger) return;
      if (!menu.contains(t)) closeMenu();
    }, { capture:true });

    // ESC closes
    document.addEventListener("keydown", function(ev){
      if (ev.key === "Escape" && menu.style.display === "block") {
        try{ ev.preventDefault(); }catch(_){}
        closeMenu();
        try{ hamburger.focus({ preventScroll:true }); }catch(_){}
      }
    });

    // Submenus (hover bridge + click toggle)
    map.forEach(({t,p,id}) => {
      function openPanel(){
        map.forEach(x => { if (x.id !== id) { x.p.style.display="none"; x.p.classList.remove("fe-open"); }});
        p.style.display = "block";
        p.classList.add("fe-open");
      }
      function armClose(){
        clearTimeout(p.__to);
        p.__to = setTimeout(() => {
          if (!p.matches(":hover") && !t.matches(":hover")) {
            p.style.display = "none";
            p.classList.remove("fe-open");
          }
        }, 220);
      }
      function disarm(){ clearTimeout(p.__to); }

      t.addEventListener("mouseenter", () => { disarm(); openPanel(); });
      t.addEventListener("mouseleave", armClose);
      p.addEventListener("mouseenter", disarm);
      p.addEventListener("mouseleave", armClose);

      // Touch/click support
      t.addEventListener("click", function(ev){
        try{ ev.stopPropagation(); ev.preventDefault(); }catch(_){}
        const on = p.style.display === "block";
        if (on) { p.style.display="none"; p.classList.remove("fe-open"); }
        else { openPanel(); }
      });
    });
  };

  if (document.readyState === "complete" || document.readyState === "interactive") {
    setTimeout(boot, 0);
  } else {
    document.addEventListener("DOMContentLoaded", boot, { once:true });
  }
})();
</script>

<script>
// Snap-to-Grid toggle (from scratch). Matches Status/Scrollbars styling, persists to localStorage.
(function setupSnapToGrid(){
  const btn = document.getElementById('snapToGridToggle');
  const GRID_KEY = 'fe_snap_to_grid';
  const SIZE_KEY = 'fe_snap_grid_size';
  const GRID_SIZE = Number(localStorage.getItem(SIZE_KEY) || 20);

  function isOn(){ return localStorage.getItem(GRID_KEY) === '1'; }
  function setOn(v){ localStorage.setItem(GRID_KEY, v ? '1' : '0'); }

  function updateBtn(){
    if (!btn) return;
    btn.style.backgroundColor = isOn() ? '#4CAF50' : '#808080';
    btn.textContent = 'Snap to Grid';
    btn.title = 'Toggle snapping nodes to ' + GRID_SIZE + 'px grid';
  }

  function nearest(n, g){ return Math.round(Number(n||0)/g)*g; }

  function snapNodeById(id){
    try{
      if (!window.editor || !id) return;
      const node = editor.getNodeFromId(String(id));
      if (!node) return;
      const x = nearest(node.pos_x, GRID_SIZE);
      const y = nearest(node.pos_y, GRID_SIZE);

      // Update node model
      node.pos_x = x;
      node.pos_y = y;

      // Update DOM
      const el = document.getElementById('node-' + id);
      if (el){
        el.style.left = x + 'px';
        el.style.top  = y + 'px';
      }

      // Refresh connections
      try {
        if (typeof editor.updateConnectionNodes === 'function') {
          editor.updateConnectionNodes(String(id));
        } else if (typeof editor.updateConnectionNodesAll === 'function') {
          editor.updateConnectionNodesAll();
        }
      } catch(_){}
    }catch(_){}
  }

  // Track when a node is being dragged (mousedown on a node header/body)
  let draggingId = null;
  document.addEventListener('mousedown', function(e){
    const nodeEl = e.target && (e.target.closest && e.target.closest('.drawflow-node'));
    if (!nodeEl) return;
    const id = nodeEl.id && nodeEl.id.startsWith('node-') ? nodeEl.id.replace('node-','') : null;
    if (!id) return;
    draggingId = id;
  }, true);

  // On mouseup, if snapping enabled and we had a drag target, snap it
  document.addEventListener('mouseup', function(){
    if (!isOn() || !draggingId) { draggingId = null; return; }
    // defer a tick so Drawflow finishes its own placement first
    const id = draggingId;
    draggingId = null;
    setTimeout(function(){ snapNodeById(id); }, 0);
  }, true);

  // Also snap any programmatic moves (align/center actions) by hooking refresh
  (function hookRefresh(){
    const fn = window.refreshConnectionsSoon;
    if (fn && !fn.__snapHooked){
      window.refreshConnectionsSoon = function(){
        try { fn.apply(this, arguments); } catch(_){}
        if (!isOn() || !window.editor) return;
        try{
          const data = (window.editor.drawflow && (window.editor.drawflow.Home?.data || window.editor.drawflow.drawflow?.Home?.data)) || {};
          Object.keys(data || {}).forEach(snapNodeById);
        }catch(_){}
      };
      window.refreshConnectionsSoon.__snapHooked = true;
    }
  })();

  if (btn){
    btn.addEventListener('click', function(){
      setOn(!(isOn()));
      updateBtn();
      try { markFlowNeedsSave(true); } catch(_){}
    }, {capture:true});
  }

  updateBtn();
})();
</script>






<script id="feHeadMeasure">
(function(){
  function setHeadVar(){
    try{
      var h = document.getElementById('headline');
      var px = (h ? Math.round(h.getBoundingClientRect().height) : 0) + 'px';
      document.documentElement.style.setProperty('--fe-head-h', px);
    }catch(_){}
  }
  window.addEventListener('load', setHeadVar, {once:true});
  window.addEventListener('resize', setHeadVar);
  // also update after UI mutations (menus open/close, etc.)
  new MutationObserver(setHeadVar).observe(document.body, {childList:true, subtree:true, attributes:true});
  setTimeout(setHeadVar, 50);
  setTimeout(setHeadVar, 250);
})();
</script>


<script id="feInlineCollapseJS">
(function(){
  function setCollapsed(on){
    document.body.classList.toggle('fe-sidebar-collapsed', !!on);
    try{ localStorage.setItem('fe_sidebar_collapsed', on ? '1' : '0'); }catch(_){}
  }
  function init(){
    var btn = document.getElementById('feCollapseInline');
    if(!btn) return;
    btn.addEventListener('click', function(){
      var on = !document.body.classList.contains('fe-sidebar-collapsed');
      setCollapsed(on);
    });
    // Restore saved state
    try{
      var saved = localStorage.getItem('fe_sidebar_collapsed') === '1';
      if(saved){ setCollapsed(true); }
    }catch(_){}
  }
  if(document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', init);
  } else {
    init();
  }
})();
</script>

<script>
document.addEventListener('DOMContentLoaded', function(){
  try {
    const burger = document.getElementById('feHamburger');
    if (burger && !burger.classList.contains('fe-dirty') && !burger.classList.contains('fe-clean')) {
      burger.classList.add('fe-clean');
    }
  } catch (e) {}
});
</script>

<!-- ===== Sync hamburger + Save dirty state (added by assistant) ===== -->
<script>
(function(){
  function _syncDirtyFromSave(){
    try{
      var btn = document.getElementById('sendFlow');
      var burger = document.getElementById('feHamburger');
      if(!btn || !burger) return;
      var dirty = btn.classList.contains('need-save');
      burger.classList.toggle('fe-dirty', dirty);
      burger.classList.toggle('fe-clean', !dirty);
      // tooltips
      burger.setAttribute('aria-label', dirty ? 'Unsaved changes' : 'All changes saved');
      burger.title = dirty ? 'Menu ‚Äî Unsaved changes' : 'Menu';
    }catch(e){}
  }

  // Override/unify the public API used around the app
  window.markFlowNeedsSave = function(needed){
    try{
      var btn = document.getElementById('sendFlow');
      if(btn){ btn.classList.toggle('need-save', !!needed); }
      _syncDirtyFromSave();
    }catch(e){}
  };

  // On load, and whenever legacy code toggles the Save class directly,
  // mirror that state to the hamburger so both always match.
  document.addEventListener('DOMContentLoaded', function(){
    _syncDirtyFromSave();
    var btn = document.getElementById('sendFlow');
    if(!btn) return;
    var mo = new MutationObserver(function(muts){
      for(var i=0;i<muts.length;i++){
        if(muts[i].type === 'attributes' && muts[i].attributeName === 'class'){
          _syncDirtyFromSave();
          break;
        }
      }
    });
    mo.observe(btn, { attributes:true, attributeFilter:['class'] });
  });
})();
</script>
<script>
(function(){
  function setHeadH(){
    const head = document.getElementById('headline');
    const h = head ? Math.round(head.getBoundingClientRect().height) : 0;
    document.documentElement.style.setProperty('--fe-head-h', h + 'px');
  }
  // Recalculate on load/resize and whenever the header‚Äôs size changes
  window.addEventListener('load', setHeadH, { passive: true });
  window.addEventListener('resize', setHeadH, { passive: true });
  if (document.fonts && document.fonts.ready) document.fonts.ready.then(setHeadH);
  const head = document.getElementById('headline');
  if (window.ResizeObserver && head) new ResizeObserver(setHeadH).observe(head);
  setHeadH();
})();
</script>



<!-- appended by fixer: restore ctrl-click + robust updateTileHtml WITHOUT removing any original code -->
<script>
  // Only install once
  (function() {
    // Robust re-definition of updateTileHtml that won't crash even if earlier version was truncated
    window.updateTileHtml = function(node) {
      try {
        if (!node || !window.editor || typeof window.editor.updateNodeHtmlFromId !== "function") return;
        var id = node.id || (node.data && node.data.id);
        if (!id) {
          // try to infer from DOM if possible
          try {
            var el = document.querySelector('.drawflow-node.selected');
            if (el) id = el.id.replace(/^node-/, '');
          } catch(_) {}
        }
        if (!id) return;
        var html = (typeof window.nodeTileHtml === "function") ? window.nodeTileHtml(node.name, node.data, id) : "";
        window.editor.updateNodeHtmlFromId(id, html);
      } catch (e) {
        console.error("updateTileHtml (appended) failed:", e);
      }
    };

    // Provide selection UI helper only if the project didn't define it already
    if (typeof window.updateNodeSelectionUI !== "function") {
      window.updateNodeSelectionUI = function() {
        var set = (window._multiSelectedNodes && window._multiSelectedNodes.size) ? window._multiSelectedNodes : new Set();
        document.querySelectorAll('#drawflow .drawflow-node').forEach(function(el) {
          var nid = (el.id || '').replace(/^node-/, '');
          if (set.has(nid)) {
            el.classList.add('selected');
            el.style.outline = '2px solid #66aaff';
          } else {
            el.classList.remove('selected');
            el.style.outline = '';
          }
        });
      };
    }

    // Reinstall ctrl/cmd multi-select and background clear if not already installed
    if (!window.__ctrlMultiSelectBound) {
      var draw = document.getElementById("drawflow");
      if (draw) {
        // ctrl/cmd + click toggles selection of the targeted node
        draw.addEventListener("mousedown", function(e) {
          if (!(e.ctrlKey || e.metaKey)) return;
          var nodeElem = e.target.closest && e.target.closest('.drawflow-node');
          if (!nodeElem) return;
          var nodeId = (nodeElem.id || "").replace(/^node-/, "");
          if (!nodeId) return;
          if (!window._multiSelectedNodes) window._multiSelectedNodes = new Set();
          if (window._multiSelectedNodes.has(nodeId)) {
            window._multiSelectedNodes.delete(nodeId);
          } else {
            window._multiSelectedNodes.add(nodeId);
          }
          window.updateNodeSelectionUI && window.updateNodeSelectionUI();
          // Prevent drawflow from starting a drag on ctrl-click
          e.preventDefault();
          e.stopPropagation();
        }, true);

        // click on background (no ctrl/cmd) clears selection
        draw.addEventListener("mousedown", function(e) {
          if (e.ctrlKey || e.metaKey) return;
          var nodeElem = e.target.closest && e.target.closest('.drawflow-node');
          if (nodeElem) return;
          if (window._multiSelectedNodes && window._multiSelectedNodes.size) {
             try{ window.__feSelectionAllowClear && window.__feSelectionAllowClear(240); }catch(_){} window._multiSelectedNodes.clear();
            window.updateNodeSelectionUI && window.updateNodeSelectionUI();
          }
        }, true);
      }
    }
  })();
</script>
<!-- BEGIN: Variable Manager Save Button Enforcer -->
<script>
  (function(){
    'use strict';
    if (window.__vmSaveEnforcer__) return;
    window.__vmSaveEnforcer__ = true;

    function toList(n){ return Array.prototype.slice.call(n||[]); }
    function norm(v){ return String(v==null?'':v).trim().toLowerCase(); }

    function isSelectReady(sel){
      if (!sel) return false;
      var v = norm(sel.value||'');
      if (v && v !== '(select)') return true;
      var txt = (sel.options && sel.selectedIndex>=0) ? norm(sel.options[sel.selectedIndex].text||'') : '';
      return !!txt && txt !== '(select)';
    }

    function setBtnStyle(btn, enabled){
      if (!btn) return;
      btn.style.fontSize = '14px';
      btn.style.padding = '6px 12px';
      btn.style.borderRadius = '7px';
      btn.style.boxShadow = '0 2px 8px #0004';
      btn.style.cursor = enabled ? 'pointer' : 'not-allowed';
      btn.style.backgroundColor = enabled ? '#4CAF50' : '#808080';
      btn.disabled = !enabled;
    }

    function findControls(vm){
      // Heuristically identify Save + fields in the Add Variable area
      var btns = toList(vm.querySelectorAll('button'));
      var delIdx = btns.findIndex(function(b){ return norm(b.textContent) === 'delete'; });
      var saveBtn = btns.find(function(b, idx){
        // Prefer a button before Delete; else first button in this section
        return (delIdx === -1 ? true : idx < delIdx);
      }) || null;

      // Fallback: if button text literally says 'save', prefer that
      var explicitSave = btns.find(function(b){ return norm(b.textContent)==='save'; });
      if (explicitSave) saveBtn = explicitSave;

      // Collect candidate fields that appear before save button
      var fields = [];
      if (saveBtn){
        var w = saveBtn.previousElementSibling, guard=0;
        while (w && guard++ < 80){
          if (w.tagName && /^(input|select|textarea)$/i.test(w.tagName)) fields.unshift(w);
          w = w.previousElementSibling;
        }
      } else {
        fields = toList(vm.querySelectorAll('input,select,textarea'));
      }

      var selects = fields.filter(function(el){ return el.tagName && el.tagName.toLowerCase()==='select'; });
      var inputs  = fields.filter(function(el){ return el.tagName && el.tagName.toLowerCase()==='input'; });
      var textInputs = inputs.filter(function(el){ return (el.type||'text').toLowerCase()==='text'; });

      var scopeSel = selects[0] || null;
      var typeSel  = selects.length ? selects[selects.length-1] : null;

      // Name is the first text input; Value is the next text input or textarea
      var nameEl = textInputs[0] || null;
      var valueEl = null;
      if (nameEl){
        var next = nameEl.nextElementSibling, guard2=0;
        while (next && guard2++ < 60 && !valueEl){
          if (next.tagName){
            var tag = next.tagName.toLowerCase();
            if (tag==='input' && (next.type||'text').toLowerCase()==='text') valueEl = next;
            else if (tag==='textarea') valueEl = next;
          }
          next = next.nextElementSibling;
        }
      }
      if (!valueEl){
        var textareas = fields.filter(function(el){ return el.tagName && el.tagName.toLowerCase()==='textarea'; });
        valueEl = textInputs[1] || textareas[0] || null;
      }

      return {saveBtn, scopeSel, nameEl, valueEl, typeSel};
    }

    function evaluateReady(fx){
      if (!fx || !fx.saveBtn) return false;
      var name = (fx.nameEl && fx.nameEl.value) ? fx.nameEl.value.trim() : '';
      var val  = (fx.valueEl && typeof fx.valueEl.value !== 'undefined') ? String(fx.valueEl.value).trim() : '';
      return !!name && !!val && isSelectReady(fx.scopeSel) && isSelectReady(fx.typeSel);
    }

    function wire(vm){
      if (!vm) return;
      var fx = findControls(vm);
      if (!fx.saveBtn) return;

      function refresh(){ setBtnStyle(fx.saveBtn, evaluateReady(fx)); }
      // Initial state
      refresh();
      // Bind listeners
      [fx.scopeSel, fx.typeSel, fx.nameEl, fx.valueEl].forEach(function(el){
        if (!el) return;
        el.addEventListener('input', refresh);
        if (el.tagName && el.tagName.toLowerCase()==='select') el.addEventListener('change', refresh);
      });
      // In case content gets re-rendered, a small polling fallback
      if (!vm.__savePoll){
        vm.__savePoll = setInterval(function(){
          var fx2 = findControls(vm);
          if (fx2 && fx2.saveBtn) setBtnStyle(fx2.saveBtn, evaluateReady(fx2));
        
  try{ window.__autoRefresh = false; }catch(_){}
  }, 400);
      }
    }

    function install(){
      var vm = document.getElementById('variableManager');
      if (vm) wire(vm);
      var root = document.getElementById('variableManagerPanel') || document;
      try{
        var mo = new MutationObserver(function(){ var c = document.getElementById('variableManager'); if (c) wire(c); });
        mo.observe(root, {childList:true, subtree:true});
      }catch(e){}
    }

    if (document.readyState==='loading') document.addEventListener('DOMContentLoaded', install);
    else install();
    window.addEventListener('load', function(){ setTimeout(install, 200); });
  })();
</script>
<!-- END: Variable Manager Save Button Enforcer -->
<!-- placement-fix: ensure new tiles land at top-left of current view -->
<script>
  (function(){
    try {
      // Safe defaults for offsets if project didn't set them
      if (typeof window.newNodeOffsetX !== 'number') window.newNodeOffsetX = 0;
      if (typeof window.newNodeOffsetY !== 'number') window.newNodeOffsetY = 0;
      if (typeof window.newNodeOffsetStep !== 'number') window.newNodeOffsetStep = 20;
      if (typeof window.newNodeOffsetLimit !== 'number') window.newNodeOffsetLimit = 10;

      // Helper: parse CSS transform matrix -> {scale, tx, ty}
      function _parseTransform(el){
        var scale = 1, tx = 0, ty = 0;
        if (!el) return {scale:1, tx:0, ty:0};
        var t = getComputedStyle(el).transform;
        if (t && t !== 'none') {
          var m = t.match(/matrix\(([^)]+)\)/);
          if (m) {
            var vals = m[1].split(',').map(function(v){ return parseFloat(v.trim()); });
            if (vals.length === 6) {
              scale = vals[0] || 1;
              tx = vals[4] || 0;
              ty = vals[5] || 0;
            }
          } else {
            // matrix3d(a,b,c,d,e,f,g,h,i,j,k,l, tx, ty, tz, w)
            var m3 = t.match(/matrix3d\(([^)]+)\)/);
            if (m3) {
              var v = m3[1].split(',').map(function(n){ return parseFloat(n.trim()); });
              if (v.length === 16) {
                // approximate uniform scale from a(0) and d(5)
                scale = (v[0] || 1);
                tx = v[12] || 0;
                ty = v[13] || 0;
              }
            }
          }
        }
        return {scale: scale || 1, tx: tx || 0, ty: ty || 0};
      }

      // Provide/override getTopLeftOnScreenCoords so adding nodes uses the visible top-left
      window.getTopLeftOnScreenCoords = function(){
        try {
          // Try known Drawflow precanvas element first
          var precanvas = (window.editor && window.editor.precanvas) || document.querySelector('#drawflow .drawflow');
          if (!precanvas) precanvas = document.querySelector('#drawflow') || document.body;
          var tr = _parseTransform(precanvas);

          // Convert screen (0,0) to canvas coordinates: (x - tx)/scale
          var baseX = (0 - tr.tx) / tr.scale;
          var baseY = (0 - tr.ty) / tr.scale;

          // Small padding from the literal top-left to avoid hugging the edge
          var pad = 10;

          return {
            x: Math.round(baseX + pad + (window.newNodeOffsetX || 0)),
            y: Math.round(baseY + pad + (window.newNodeOffsetY || 0))
          };
        } catch(e){
          console.warn('getTopLeftOnScreenCoords fallback due to error:', e);
          // Fallback: absolute top-left in canvas coords with offsets
          return {
            x: 10 + (window.newNodeOffsetX || 0),
            y: 10 + (window.newNodeOffsetY || 0)
          };
        }
      };
    } catch(e){
      console.warn('placement-fix init error', e);
    }
  })();

  document.addEventListener('DOMContentLoaded', () => {
    const tabs = document.querySelectorAll('.schedule-tabs button');
    tabs.forEach(btn => {
      btn.addEventListener('click', () => {
        tabs.forEach(b => b.classList.remove('selected'));
        btn.classList.add('selected');
      });
    });
  });
</script>
<script>
(function(){
  function zeroPan(){
    try{
      var ed = window.editor;
      if (ed && ed.precanvas){
        var z = (typeof ed.zoom === 'number') ? ed.zoom : 1;
        ed.canvas_x = 0; ed.canvas_y = 0;
        ed.precanvas.style.transform = 'translate(0px, 0px) scale(' + z + ')';
        return true;
      }
    }catch(_){}
    return false;
  }
  var tries = 0;
  var iv = setInterval(function(){
    tries++;
    if (zeroPan() || tries > 60) clearInterval(iv);
  }, 100);
  window.addEventListener('resize', zeroPan);
})();
</script>

<script id="feSidebarArrowSync">
(function(){
  function init(){
    var btn = document.getElementById('feCollapseInline');
    if (!btn || btn.__feArrowBound) return;
    btn.__feArrowBound = true;

    function sync(){
      var collapsed = document.body.classList.contains('fe-sidebar-collapsed');
      // ‚ñ∂ when collapsed (points right to "expand"), ‚óÄ when expanded
      btn.textContent = collapsed ? '‚ñ∂' : '‚óÄ';
      btn.setAttribute('aria-expanded', (!collapsed).toString());
      var label = collapsed ? 'Expand sidebar' : 'Collapse sidebar';
      btn.setAttribute('aria-label', label);
      btn.title = label;
    }

    // 1) Initial sync on load
    sync();

    // 2) If your existing code toggles the class, reflect it here
    try{
      var mo = new MutationObserver(sync);
      mo.observe(document.body, {attributes:true, attributeFilter:['class']});
    }catch(_){}

    // 3) Also sync on click (after your existing toggle runs)
    btn.addEventListener('click', function(){ setTimeout(sync, 0); }, {capture:false});
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init, {once:true});
  } else {
    init();
  }
})();
</script>
<script id="feLogPanelJS">
(function(){
  const header  = document.getElementById('logHeader');
  const arrow   = document.getElementById('logArrow');
  const content = document.getElementById('logContent');
  const clear   = document.getElementById('clearLogBtn');
  const lines   = document.getElementById('logLines');
  const autoCb  = document.getElementById('logAutoscroll');
  if (!header||!arrow||!content||!clear||!lines||!autoCb) return;

  const OPEN_KEY = 'fe_log_open';
  const AUTO_KEY = 'fe_log_autoscroll';

  function setOpen(on){
    content.style.display = on ? 'block' : 'none';
    arrow.style.transform = on ? 'rotate(0deg)' : 'rotate(-90deg)';
    try{ localStorage.setItem(OPEN_KEY, on?'1':'0'); }catch(_){}
  }
  function getOpenSaved(){
    const v = localStorage.getItem(OPEN_KEY);
    return v==='1'?true:(v==='0'?false:null);
  }

  function setAuto(v){ try{ localStorage.setItem(AUTO_KEY,v?'1':'0'); }catch(_){}}  
  function getAutoSaved(){ const v=localStorage.getItem(AUTO_KEY); return v===null?true:v==='1'; }

  header.addEventListener('click',(e)=>{
    if (e.target===clear || e.target===autoCb || e.target.closest('label')) return;
    setOpen(content.style.display==='none');
  });
  clear.addEventListener('click',()=>{ lines.innerHTML=''; });
  autoCb.checked=getAutoSaved();
  autoCb.addEventListener('change',()=>setAuto(autoCb.checked));

  new MutationObserver(()=>{ if(autoCb.checked) content.scrollTop=content.scrollHeight; })
    .observe(lines,{childList:true});

  const savedOpen=getOpenSaved();
  setOpen(savedOpen===null?false:savedOpen);
})();
</script>
<style id="feSidebarTransitions">
  #main{ transition: grid-template-columns .18s ease }
  #editor{ transition: min-width .18s ease, max-width .18s ease, width .18s ease, padding .18s ease }
</style>
<style id="feMenuA11y">
  .fe-menu-item:focus-visible{ outline:2px solid #4e9cff; outline-offset:2px }
</style>


<script id="feMinimapDrag">
(function setupMinimapDrag(){
  const mm = document.getElementById('minimap-container');
  const canvas = document.getElementById('minimap-canvas');
  if (!mm || !canvas) return;

  // Keep cursor as a hand while hovering; closed hand while dragging
  let dragging = false;
  let startX = 0, startY = 0, startLeft = 0, startTop = 0;
  let activePointerId = null;

  function clamp(v, min, max){ return Math.min(max, Math.max(min, v)); }
  function bounds(){
    return { vw: window.innerWidth, vh: window.innerHeight, mw: mm.offsetWidth, mh: mm.offsetHeight };
  }
  function wantsDragTarget(t){
    // allow drag on container or canvas; ignore inner label
    return t && (t.id === 'minimap-container' || t.id === 'minimap-canvas');
  }

  // Hover hand
  mm.addEventListener('pointerenter', () => { if (!dragging) mm.style.cursor = 'grab'; });
  mm.addEventListener('pointerleave', () => { if (!dragging) mm.style.cursor = 'grab'; });

  // Begin drag
  mm.addEventListener('pointerdown', (e) => {
    if (!wantsDragTarget(e.target) || e.button !== 0) return; // left button only
    dragging = true;
    activePointerId = e.pointerId;
    try { mm.setPointerCapture(activePointerId); } catch(_) {}
    mm.style.cursor = 'grabbing';
    startX = e.clientX; startY = e.clientY;
    // When positioned via bottom/right, offsetLeft/Top are still usable; we will switch to left/top.
    startLeft = mm.offsetLeft; startTop = mm.offsetTop;
    e.preventDefault();
  });

  // Drag move
  window.addEventListener('pointermove', (e) => {
    if (!dragging || e.pointerId !== activePointerId) return;
    const { vw, vh, mw, mh } = bounds();
    let left = startLeft + (e.clientX - startX);
    let top  = startTop  + (e.clientY - startY);
    // Clamp inside viewport
    left = clamp(left, 0, Math.max(0, vw - mw));
    top  = clamp(top,  0, Math.max(0, vh - mh));
    // Switch to left/top positioning and release bottom/right
    mm.style.left = left + 'px';
    mm.style.top  = top  + 'px';
    mm.style.right = 'auto';
    mm.style.bottom = 'auto';
  });

  function stopDrag(e){
    if (!dragging) return;
    dragging = false;
    if (e && e.pointerId === activePointerId) {
      try { mm.releasePointerCapture(activePointerId); } catch(_) {}
    }
    activePointerId = null;
    // remain a hand while hovering
    mm.style.cursor = 'grab';
    const rect = mm.getBoundingClientRect();
    try {
      localStorage.setItem('fe_minimap_pos', JSON.stringify({ left: Math.round(rect.left), top: Math.round(rect.top) }));
    } catch(_) {}
  }

  window.addEventListener('pointerup', stopDrag);
  window.addEventListener('pointercancel', stopDrag);
  window.addEventListener('blur', stopDrag);

  // Keep inside viewport after resize and persist new clamped pos
  window.addEventListener('resize', () => {
    const { vw, vh, mw, mh } = bounds();
    const rect = mm.getBoundingClientRect();
    const left = clamp(rect.left, 0, Math.max(0, vw - mw));
    const top  = clamp(rect.top,  0, Math.max(0, vh - mh));
    mm.style.left = left + 'px';
    mm.style.top  = top  + 'px';
    mm.style.right = 'auto';
    mm.style.bottom = 'auto';
    try { localStorage.setItem('fe_minimap_pos', JSON.stringify({ left, top })); } catch(_) {}
  });

  // Restore saved position (if present)
  try {
    const raw = localStorage.getItem('fe_minimap_pos');
    if (raw) {
      const pos = JSON.parse(raw);
      if (typeof pos.left === 'number' && typeof pos.top === 'number') {
        mm.style.left = pos.left + 'px';
        mm.style.top  = pos.top  + 'px';
        mm.style.right = 'auto';
        mm.style.bottom = 'auto';
      }
    }
  } catch(_) {}
})();
</script>

<style id="feQuickNodeMenuCSS">
#quickNodeMenu {
  position: fixed;
  z-index: 999999;
  min-width: 240px;
  max-width: 360px;
  max-height: 60vh;
  overflow: auto;
  background: #1e1f24;
  color: #eee;
  border: 1px solid #3b3f4c;
  border-radius: 10px;
  box-shadow: 0 12px 24px rgba(0,0,0,.45);
  padding: 6px;
  display: none;
  font: 13px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
}
#quickNodeMenu .qnm-item {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 8px 10px;
  border-radius: 8px;
  cursor: pointer;
  background: #252833;
  margin: 4px 0;
  color:#eee;
}
#quickNodeMenu .qnm-item:hover { background: #2d3140; }
#quickNodeMenu .qnm-label { flex: 1; color:#eee; }
</style>

<script id="feQuickNodeMenuJS">
(function(){
  if (window.__feQuickNodeMenuInstalled) return; window.__feQuickNodeMenuInstalled = true;

  const DRAW_ID = "drawflow";
  const items = [
  {id:"addDevice",label:"Action"},
  {id:"addComment",label:"Comment"},
  {id:"addCondition",label:"Condition"},
  {id:"addCountdown",label:"Countdown"},
  {id:"addDelay",label:"Delay (ms)"},
  {id:"addDelayMin",label:"Delay (minutes)"},
  {id:"addDoNothing",label:"Do Nothing"},
  {id:"addMotionDirection",label:"Motion Direction"},
  {id:"addNotify",label:"Notification"},
  {id:"addRepeat",label:"Repeat"},
  {id:"addRestoreDeviceState",label:"Restore Device State"},
  {id:"addSaveDeviceState",label:"Save Device State"},
  {id:"addSchedule",label:"Schedule Trigger"},
  {id:"addSetVariable",label:"Set Variable"},
  {id:"addTrigger",label:"Event Trigger"}
];

  const menu = document.createElement('div');
  menu.id = 'quickNodeMenu';
  menu.setAttribute('role','menu');
  const list = document.createElement('div');
  items.forEach(it => {
    const row = document.createElement('div');
    row.className = 'qnm-item';
    row.dataset.btnId = it.id;
    // ‚úÖ FIX: correct HTML string for label
    row.innerHTML = '<span class="qnm-label">' + (it.label || it.id) + '</span>';
    row.addEventListener('click', (ev) => {
      hideMenu();
      if (typeof window.newNodeOffsetX === 'number') window.newNodeOffsetX = (window.__qnmLastX||40);
      if (typeof window.newNodeOffsetY === 'number') window.newNodeOffsetY = (window.__qnmLastY||40);
      const btn = document.getElementById(it.id);
      if (btn && typeof btn.click === 'function') { btn.click(); return; }
      const fn = window[it.id];
      if (typeof fn === 'function') try { fn(); } catch(_) {}
    });
    list.appendChild(row);
  });
  menu.appendChild(list);
  document.body.appendChild(menu);

  function isOnGraphElement(t){
    if (!t) return false;
    const sel = '.drawflow-node, .connection, .main-path, .selectbox';
    return !!(t.closest && t.closest(sel));
  }

  function showMenu(x,y){
    menu.style.display = 'block';
    menu.style.visibility = 'hidden';
    menu.style.left = '-9999px';
    menu.style.top = '-9999px';
    void menu.offsetWidth;
    const pad = 6;
    const maxX = window.innerWidth - menu.offsetWidth - pad;
    const maxY = window.innerHeight - menu.offsetHeight - pad;
    const left = Math.min(Math.max(pad, x), Math.max(pad, maxX));
    const top  = Math.min(Math.max(pad, y), Math.max(pad, maxY));
    menu.style.left = left + 'px';
    menu.style.top  = top  + 'px';
    menu.style.visibility = 'visible';
  }
  function hideMenu(){ menu.style.display = 'none'; }

  const canvas = document.getElementById(DRAW_ID);
  if (!canvas) return;

  canvas.addEventListener('contextmenu', (e) => {
    if (isOnGraphElement(e.target)) return;
    e.preventDefault(); e.stopPropagation();
    window.__qnmLastX = e.clientX;
    window.__qnmLastY = e.clientY;
    showMenu(e.clientX, e.clientY);
  }, true);

  document.addEventListener('click', () => { if (menu.style.display!=='none') hideMenu(); }, true);
  document.addEventListener('keydown', (e) => { if (e.key === 'Escape') hideMenu(); }, true);
  window.addEventListener('blur', hideMenu);
  window.addEventListener('resize', hideMenu);
})();
</script>

<script>
(function guardImportLoops(){
  if (window.__feImportGuarded) return; window.__feImportGuarded = true;
  function wrapImportOnce(){
    try{
      if (!window.editor || !editor.import || editor.import.__feWrapped) return;
      const orig = editor.import;
      editor.import = async function __fe_import_wrapped(json){
        if (editor.__feImporting) return;
        editor.__feImporting = true;
        try { return await orig.call(this, json); }
        finally { editor.__feImporting = false; }
      };
      editor.import.__feWrapped = true;
    }catch(e){}
  }
  // Try now and also after load, just in case editor comes later
  wrapImportOnce();
  window.addEventListener('load', wrapImportOnce);
  document.addEventListener('DOMContentLoaded', wrapImportOnce);
})();
</script>



<script>
(function hardenCanvasContextMenu(){
  if (hardenCanvasContextMenu.__done) return; hardenCanvasContextMenu.__done = true;
  const menu = document.getElementById('fe-canvas-context');
  const canvas = document.getElementById('drawflow');
  if (!menu || !canvas) return;

  let tracking = false, raf = 0, lastX = 0, lastY = 0;
  function place(){
    const vw = window.innerWidth, vh = window.innerHeight;
    const rect = menu.getBoundingClientRect();
    let x = lastX, y = lastY;
    if (x + rect.width  > vw) x = vw - rect.width  - 8;
    if (y + rect.height > vh) y = vh - rect.height - 8;
    menu.style.left = x + 'px';
    menu.style.top  = y + 'px';
  }
  function onMove(e){
    lastX = e.clientX; lastY = e.clientY;
    if (raf) return;
    raf = requestAnimationFrame(()=>{ raf = 0; place(); });
  }
  function openAt(x,y){
    lastX = x; lastY = y;
    menu.style.display = 'block';
    place();
    if (!tracking){
      tracking = true;
      window.addEventListener('pointermove', onMove, {passive:true});
      window.addEventListener('resize', onMove, {passive:true});
    }
  }
  function close(){
    menu.style.display = 'none';
    if (tracking){
      tracking = false;
      window.removeEventListener('pointermove', onMove, {passive:true});
      window.removeEventListener('resize', onMove, {passive:true});
    }
  }
  canvas.addEventListener('contextmenu', (e)=>{
    if (e.target.closest('.drawflow-node')) return;
    e.preventDefault();
    openAt(e.clientX, e.clientY);
  });
  window.addEventListener('pointerdown', (e)=>{ if (!menu.contains(e.target)) close(); }, {passive:true});
  window.addEventListener('keydown', (e)=>{ if (e.key === 'Escape') close(); });
})();
</script>





<script id="feCanvasPanLite">
(function(){
  var precanvas = document.querySelector('#drawflow .precanvas');
  if (!precanvas || window.__fePanLite) return; window.__fePanLite = true;

  var isPanning = false, sx = 0, sy = 0, lastX = 0, lastY = 0, pending = false;

  function onDown(e){
    if (e.button !== 0) return;
    // Only if clicking the raw precanvas background
    if (e.target !== precanvas) return;
    // Do not start if user actually pressed on a node or connection
    if (e.target.closest && (e.target.closest('.drawflow-node') || e.target.closest('.connection'))) return;
    isPanning = true;
    sx = e.clientX; sy = e.clientY;
    document.body.style.cursor = 'grabbing';
    // Prevent drawflow from also starting a drag
    try { e.stopPropagation(); e.stopImmediatePropagation(); } catch(_){}
    try { e.preventDefault(); } catch(_){}
  }
  function onMove(e){
    if (!isPanning) return;
    if ((e.buttons & 1) === 0) { onUp(); return; }
    lastX = e.clientX; lastY = e.clientY;
    if (pending) return;
    pending = true;
    requestAnimationFrame(function(){
      pending = false;
      var dx = lastX - sx, dy = lastY - sy;
      sx = lastX; sy = lastY;
      try {
        if (window.editor && typeof editor.translate === 'function') {
          editor.translate(dx, dy);
          if (typeof editor.updateConnectionNodesAll === 'function') editor.updateConnectionNodesAll();
        } else {
          var root = document.querySelector('#drawflow .drawflow');
          if (root){
            var m = getComputedStyle(root).transform;
            var tx = 0, ty = 0;
            if (m && m !== 'none'){
              var v = m.match(/matrix\(([^)]+)\)/);
              if (v){ var a = v[1].split(',').map(Number); tx = a[4]||0; ty = a[5]||0; }
            }
            root.style.transform = 'translate('+(tx+dx)+'px,'+(ty+dy)+'px)';
          }
        }
      } catch(_){}
    });
  }
  function onUp(){
    if (!isPanning) return;
    isPanning = false;
    try { document.body.style.cursor = ''; } catch(_){}
  }
  precanvas.addEventListener('pointerdown', onDown, {passive:false});
  window.addEventListener('pointermove', onMove, {passive:true});
  window.addEventListener('pointerup', onUp, {passive:true});
  window.addEventListener('pointercancel', onUp, {passive:true});
  window.addEventListener('blur', onUp, {passive:true});
})();
</script>

<script id="feUltimateDragRelease">
(function(){
  // Track when a node/connection drag is plausibly happening
  let dragging = false;
  let lastReleaseAt = 0;

  function markDragStart(e){
    try {
      if (e && e.target && e.target.closest && e.target.closest('.drawflow-node, .connection')) {
        dragging = true;
      } else if (window.editor && (editor.drag || editor.dragging || editor.drag_node || editor.drag_connection)) {
        dragging = true;
      }
    } catch(_){}
  }

  function markDragEnd(){
    dragging = false;
  }

  function releaseDragNow(){
    const now = performance.now();
    // Debounce hard: don't spam releases more than once per 200ms, and only if we thought a drag was active
    if (!dragging && (now - lastReleaseAt) < 200) return;
    lastReleaseAt = now;

    try {
      const ed = window.editor || {};
      // Only do heavy cleanup if we believed a drag was occurring
      if (dragging) {
        const keys = [
          'drag','drag_point','drag_node','dragging','dragging_node',
          'drag_items','drag_connection','reroute_drag','editor_selected','canvas_drag'
        ];
        for (const k of keys){ try { if (k in ed) ed[k] = (typeof ed[k] === 'boolean' ? false : ed[k]); } catch(_){ } }
        // Drop dragging-related classes that can keep move handlers hot
        document.querySelectorAll('.drawflow .dragging, .drawflow .node_draggable, .connection .point_drag')
          .forEach(el => { try { el.classList.remove('dragging','node_draggable','point_drag'); } catch(_){} });
        try { if (typeof ed.updateConnectionNodesAll === 'function') ed.updateConnectionNodesAll(); } catch(_){}
      }
      // Always clear cursor
      try { document.body.style.cursor = ''; } catch(_){}
    } finally {
      markDragEnd();
    }
  }

  // Mark potential drags on pointerdown (capture to run before library)
  window.addEventListener('pointerdown', markDragStart, true);
  // Normal end-of-gesture signals
  ['pointerup','mouseup','pointercancel','touchend','touchcancel','blur','contextmenu']
    .forEach(ev => window.addEventListener(ev, releaseDragNow, true));

  // If pointer moves with no buttons down AND we thought a drag was active, release once.
  function onMove(e){
    if (!dragging) return;
    const noButtons = (typeof e.buttons === 'number') ? (e.buttons === 0) : false;
    if (noButtons) releaseDragNow();
  }
  window.addEventListener('pointermove', onMove, true);
  window.addEventListener('mousemove', onMove, true);

  document.addEventListener('visibilitychange', ()=>{ if (document.hidden) releaseDragNow(); }, true);
})();
</script>



<script id="feMultiDragMirror">
(function(){
  function getLT(el){
    const l = parseFloat(el.style.left) || 0;
    const t = parseFloat(el.style.top) || 0;
    return {l, t};
  }
  function getIdFromEl(el){
    const idStr = (el.id || '').replace('node-','');
    const id = parseInt(idStr, 10);
    return Number.isFinite(id) ? id : null;
  }
  function getSelectedNodes(){
    return Array.from(document.querySelectorAll(
      '.drawflow-node.selected, .drawflow-node.node_selected, .drawflow-node.fe-multi'
    ));
  }

  function enableCtrlClickToggle(){
    if (enableCtrlClickToggle.__done) return; enableCtrlClickToggle.__done = true;
    document.addEventListener('pointerdown', function(e){
      const node = e.target && e.target.closest && e.target.closest('.drawflow-node');
      if (!node) return;
      if (e.ctrlKey || e.metaKey){
        node.classList.toggle('fe-multi');
      } else {
        document.querySelectorAll('.drawflow-node.fe-multi').forEach(n=>{
          if (n !== node) { n.classList.remove('fe-multi'); n.style.outline=''; }
        });
      }
    }, true);
  }

  function enableMirrorDrag(){
    if (enableMirrorDrag.__done) return; enableMirrorDrag.__done = true;

    let dragging = false;
    let anchorX = 0, anchorY = 0;
    let primNode = null;
    let stash = new Map(); // element -> {l,t,id}

    function onDown(e){
      const node = e.target && e.target.closest && e.target.closest('.drawflow-node');
      if (!node) return;
      if (e.button !== 0) return;

      const selected = getSelectedNodes();
      const multi = selected.length > 1;

      if (!multi || !selected.includes(node)) {
        dragging = false; primNode = null; stash.clear(); return;
      }

      dragging = true;
      primNode = node;
      anchorX = e.clientX;
      anchorY = e.clientY;
      stash.clear();
      selected.forEach(el=>{
        if (el === primNode) return; // primary moved by the library
        const id = getIdFromEl(el);
        if (id == null) return;
        const pos = getLT(el);
        stash.set(el, {l: pos.l, t: pos.t, id});
      });
    }

    let pending = false;
    function onMove(e){
      if (!dragging) return;
      if ((e.buttons & 1) === 0){ onUp(); return; }
      if (pending) return;
      pending = true;
      requestAnimationFrame(function(){
        pending = false;
        const dx = e.clientX - anchorX;
        const dy = e.clientY - anchorY;
        anchorX = e.clientX;
        anchorY = e.clientY;

        stash.forEach((pos, el)=>{
          const nx = pos.l + dx;
          const ny = pos.t + dy;
          // Update internal model + DOM + connectors using our patched helper
          try {
            const id = pos.id;
            if (window.editor && typeof window.editor.moveNodeTo === 'function') {
              window.editor.moveNodeTo(id, nx, ny);
            } else {
              // fallback DOM only
              el.style.left = Math.round(nx) + 'px';
              el.style.top  = Math.round(ny) + 'px';
            }
          } catch(_){}
          // Store for next frame
          pos.l = nx; pos.t = ny;
          stash.set(el, pos);
        });

        try {
          if (window.editor && typeof editor.updateConnectionNodesAll === 'function') {
            editor.updateConnectionNodesAll();
          }
        } catch(_){}
      });
    }

    function onUp(){
      if (!dragging) return;
      dragging = false;
      primNode = null;
      stash.clear();
      try {
        if (window.editor && typeof editor.updateConnectionNodesAll === 'function') {
          editor.updateConnectionNodesAll();
        }
      } catch(_){}
      try { if (typeof markFlowNeedsSave === 'function') markFlowNeedsSave(true); } catch(_){}
    }

    window.addEventListener('pointerdown', onDown, true);
    window.addEventListener('pointermove', onMove, true);
    window.addEventListener('pointerup', onUp, true);
    window.addEventListener('pointercancel', onUp, true);
    window.addEventListener('blur', onUp, true);
  }

  enableCtrlClickToggle();
  enableMirrorDrag();
})();
</script>


<script id="feUnifiedBgController">
(function(){
  function setVar(name, value){ try{ document.documentElement.style.setProperty(name, value); }catch(_){} }
  function applySaved(){
    try{
      const url = localStorage.getItem('fe_bg_image_dataurl') || 'none';
      const br  = localStorage.getItem('fe_bg_brightness') || '1';
      setVar('--fe-bg-image', url);
      setVar('--fe-bg-brightness', br);
      const slider = document.getElementById('gridBrightnessSlider');
      if (slider) slider.value = String(parseFloat(br) || 1);
    }catch(_){}
  }
  function resetNode(id){
    const el = document.getElementById(id);
    if (!el) return null;
    const clone = el.cloneNode(true);
    el.parentNode.replaceChild(clone, el);
    return clone;
  }
  function toDataURL(file){
    return new Promise((resolve,reject)=>{
      const fr = new FileReader();
      fr.onerror = reject;
      fr.onload = () => resolve(fr.result);
      fr.readAsDataURL(file);
    });
  }
  async function init(){
    const pickBtn = resetNode('bgImageBtn');
    const rmBtn   = resetNode('removeBgBtn');
    const input   = resetNode('bgImageFile');
    const slider  = resetNode('gridBrightnessSlider');

    applySaved();

    if (pickBtn){
      pickBtn.addEventListener('click', function(e){
        e.preventDefault();
        if (input){ try{ input.value=''; }catch(_){ } input.click(); }
      });
    }
    if (input){
      input.addEventListener('change', async function(){
        const f = input.files && input.files[0];
        if (!f) return;
        try{
          const dataUrl = await toDataURL(f);
          const cssUrl  = 'url(\"' + dataUrl + '\")';
          localStorage.setItem('fe_bg_image_dataurl', cssUrl);
          setVar('--fe-bg-image', cssUrl);
        }catch(_){}
        try{ input.value = ''; }catch(_){}
      });
    }
    if (rmBtn){
      rmBtn.addEventListener('click', function(e){
        e.preventDefault();
        localStorage.removeItem('fe_bg_image_dataurl');
        setVar('--fe-bg-image', 'none');
      });
    }
    if (slider){
      const apply = ()=>{
        const v = String(slider.value || '1');
        localStorage.setItem('fe_bg_brightness', v);
        setVar('--fe-bg-brightness', v);
      };
      slider.addEventListener('input', apply);
      apply();
    }
  }
  if (document.readyState !== 'loading') init();
  else document.addEventListener('DOMContentLoaded', init, {once:true});
})();
</script>


<script id="feEnsurePrecanvas">
(function(){
  function ensurePrecanvas(){
    try{
      var drawflow = document.getElementById('drawflow');
      if (!drawflow) return;
      if (!drawflow.querySelector('.precanvas')){
        var pc = document.createElement('div');
        pc.className = 'precanvas';
        // give it basic layout so editor can adopt it later
        pc.style.cssText = 'position:relative; width:100%; height:100%;';
        drawflow.appendChild(pc);
      }
    }catch(_){}
  }
  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', ensurePrecanvas, {once:true});
  } else {
    ensurePrecanvas();
  }
  // expose a quick debug helper
  window.feDbgBg = function(){
    try{
      var el = document.querySelector('#drawflow .precanvas') || document.getElementById('drawflow');
      var cs = getComputedStyle(el, '::before');
      console.log('bgImage=', cs.backgroundImage, ' brightness=', cs.filter);
      return cs.backgroundImage;
    }catch(e){ console.warn(e); return null; }
  };
})();
</script>


<script id="feMinimapMagic">
(function(){
  const box  = document.getElementById('minimap-container');
  const cvs  = document.getElementById('minimap-canvas');
  if (!box || !cvs) return;
  const ctx = cvs.getContext('2d', { willReadFrequently: true });

  // --- keep box within viewport ---
  (function clampDrag(){
    let dragging=false, sx=0, sy=0, sl=0, st=0;
    function clamp(left, top){
      const vpW = window.innerWidth, vpH = window.innerHeight;
      const r = box.getBoundingClientRect();
      const w = r.width, h = r.height;
      return {
        left: Math.min(Math.max(left, 0), Math.max(0, vpW - w)),
        top:  Math.min(Math.max(top,  0), Math.max(0, vpH - h))
      };
    }
    box.addEventListener('pointerdown', e=>{
      if (e.button!==0) return;
      dragging=true; sx=e.clientX; sy=e.clientY;
      const r=box.getBoundingClientRect(); sl=r.left; st=r.top;
      try{ box.setPointerCapture(e.pointerId); }catch(_){}
      box.style.cursor='grabbing';
    });
    box.addEventListener('pointermove', e=>{
      if(!dragging) return;
      const dx=e.clientX-sx, dy=e.clientY-sy;
      const p=clamp(sl+dx, st+dy);
      box.style.left=p.left+'px'; box.style.top=p.top+'px';
      box.style.right='auto'; box.style.bottom='auto';
    });
    box.addEventListener('pointerup', e=>{
      if(!dragging) return; dragging=false;
      try{ box.releasePointerCapture(e.pointerId); }catch(_){}
      box.style.cursor='grab';
    });
    window.addEventListener('resize', ()=>{
      const r=box.getBoundingClientRect();
      const p=clamp(r.left, r.top);
      box.style.left=p.left+'px'; box.style.top=p.top+'px';
    });
  })();

  // --- helpers ---
  const getEd = ()=> window.editor || null;
  const getPC = ()=> (getEd() && getEd().precanvas) || document.querySelector('#drawflow .precanvas');
  const vpSize = ()=>{
    const host=document.getElementById('drawflow');
    const r=host?host.getBoundingClientRect():{width:0,height:0};
    return {w:r.width,h:r.height};
  };
  const panZoom = ()=>{
    const ed=getEd(); const z = (ed && typeof ed.zoom==='number')?ed.zoom:1;
    const x = (ed && typeof ed.canvas_x!=='undefined')?Number(ed.canvas_x||0):0;
    const y = (ed && typeof ed.canvas_y!=='undefined')?Number(ed.canvas_y||0):0;
    return {x,y,z};
  };
  function contentBounds(){
    const pc=getPC(); if(!pc) return {minX:0,minY:0,maxX:1200,maxY:800};
    const nodes=pc.querySelectorAll('.drawflow-node');
    if(!nodes.length) return {minX:0,minY:0,maxX:1200,maxY:800};
    let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity;
    nodes.forEach(n=>{
      const x=parseFloat(n.style.left)||0;
      const y=parseFloat(n.style.top)||0;
      const w=n.offsetWidth||160, h=n.offsetHeight||60;
      if(x<minX)minX=x; if(y<minY)minY=y;
      if(x+w>maxX)maxX=x+w; if(y+h>maxY)maxY=y+h;
    });
    const P=40; return {minX:minX-P,minY:minY-P,maxX:maxX+P,maxY:maxY+P};
  }
  function mapFns(){
    const W=cvs.width, H=cvs.height;
    const B=contentBounds();
    const worldW=Math.max(1,B.maxX-B.minX);
    const worldH=Math.max(1,B.maxY-B.minY);
    const s=Math.min(W/worldW, H/worldH);
    const offX=(W-worldW*s)*0.5, offY=(H-worldH*s)*0.5;
    const w2m=(wx,wy)=>({x:offX+(wx-B.minX)*s, y:offY+(wy-B.minY)*s});
    const m2w=(mx,my)=>({x:B.minX+(mx-offX)/s, y:B.minY+(my-offY)/s});
    return {w2m,m2w,s,B,offX,offY};
  }
  function roundRect(ctx,x,y,w,h,r){
    ctx.beginPath();
    ctx.moveTo(x+r,y); ctx.lineTo(x+w-r,y);
    ctx.quadraticCurveTo(x+w,y,x+w,y+r);
    ctx.lineTo(x+w,y+h-r);
    ctx.quadraticCurveTo(x+w,y+h,x+w-r,y+h);
    ctx.lineTo(x+r,y+h);
    ctx.quadraticCurveTo(x,y+h,x,y+h-r);
    ctx.lineTo(x,y+r);
    ctx.quadraticCurveTo(x,y,x+r,y);
    ctx.closePath();
  }

  function render(){
    if (box.style.display==='none') return;
    const W=cvs.width, H=cvs.height;
    ctx.clearRect(0,0,W,H);
    ctx.fillStyle='#111a1e'; ctx.fillRect(0,0,W,H);

    const pc=getPC(); if(!pc) return;
    const map=mapFns();

    pc.querySelectorAll('.drawflow-node').forEach(n=>{
      const x=parseFloat(n.style.left)||0;
      const y=parseFloat(n.style.top)||0;
      const w=n.offsetWidth||160, h=n.offsetHeight||60;
      const p1=map.w2m(x,y), p2=map.w2m(x+w,y+h);
      const mw=Math.max(2,p2.x-p1.x), mh=Math.max(2,p2.y-p1.y);
      const t=(n.getAttribute('data-node-type')||'').toLowerCase();
      let c='#5fa8f0';
      if(t.includes('trigger')) c='#f0a25f';
      else if(t.includes('condition')) c='#6fe08b';
      else if(t.includes('device')||t.includes('action')) c='#c889f2';
      else if(t.includes('comment')) c='#a0a0a0';
      ctx.fillStyle=c; roundRect(ctx,p1.x,p1.y,mw,mh,Math.min(4,Math.min(mw,mh)/4)); ctx.fill();
    });

    const {x,y,z}=panZoom(); const vp=vpSize();
    const wx1=(-x)/z, wy1=(-y)/z, wx2=(-x+vp.w)/z, wy2=(-y+vp.h)/z;
    const m1=map.w2m(wx1,wy1), m2=map.w2m(wx2,wy2);
    ctx.strokeStyle='#fff'; ctx.lineWidth=1.5; ctx.setLineDash([4,3]);
    ctx.strokeRect(m1.x,m1.y,m2.x-m1.x,m2.y-m1.y); ctx.setLineDash([]);
    ctx.fillStyle='rgba(255,255,255,0.06)'; ctx.fillRect(m1.x,m1.y,m2.x-m1.x,m2.y-m1.y);
  }

  // click/drag to pan
  let mmDrag=false;
  function panTo(mx,my){
    const ed=getEd(), pc=getPC(); if(!ed||!pc) return;
    const map=mapFns(), vp=vpSize(), {z}=panZoom();
    const w=map.m2w(mx,my);
    const wx = w.x - (vp.w/2)/z, wy = w.y - (vp.h/2)/z;
    ed.canvas_x = -wx * z; ed.canvas_y = -wy * z;
    pc.style.transform = 'translate(' + ed.canvas_x + 'px, ' + ed.canvas_y + 'px) scale(' + z + ')';
    if (typeof ed.updateConnectionNodesAll==='function') ed.updateConnectionNodesAll();
  }
  cvs.addEventListener('pointerdown', e=>{
    if (box.style.display==='none') return;
    mmDrag=true; try{ cvs.setPointerCapture(e.pointerId);}catch(_){}
    const r=cvs.getBoundingClientRect(); panTo(e.clientX-r.left, e.clientY-r.top); requestAnimationFrame(render);
  });
  cvs.addEventListener('pointermove', e=>{
    if (!mmDrag) return;
    const r=cvs.getBoundingClientRect(); panTo(e.clientX-r.left, e.clientY-r.top); requestAnimationFrame(render);
  });
  cvs.addEventListener('pointerup', e=>{ mmDrag=false; try{ cvs.releasePointerCapture(e.pointerId);}catch(_){}; requestAnimationFrame(render); });

  ['wheel','keydown','keyup','resize','pointerup','pointerdown','pointermove']
    .forEach(ev=>window.addEventListener(ev, ()=>requestAnimationFrame(render), {passive:true}));
  setInterval(()=>requestAnimationFrame(render), 1500);

  // first paint
  if (document.readyState==='loading') document.addEventListener('DOMContentLoaded', ()=>requestAnimationFrame(render), {once:true});
  else requestAnimationFrame(render);

  window.feMinimapRender = render;
})();
</script>

</body>
</html>
